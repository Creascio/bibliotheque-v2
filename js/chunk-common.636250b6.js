(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[1],{"641e":function(e,n,t){"use strict";var s=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"bg-grey-10 row justify-between items-center"},[t("q-btn",{staticClass:"q-mx-sm",attrs:{icon:"arrow_back_ios",size:"md",flat:""},on:{click:function(n){return e.goBack()}}}),t("div",{staticClass:"text-h6 q-py-sm text-center title"},[e._v(e._s(e.title.split("-").join(" ")))]),t("q-btn",{staticClass:"q-mx-sm",attrs:{size:"md",flat:""}})],1)},i=[],r=t("a6f4"),a=Object(r["b"])({props:{title:{type:String,required:!0}},methods:{goBack(){this.$router.back()}}}),o=a,u=(t("bb95"),t("2877")),l=t("9c40"),c=t("eebe"),d=t.n(c),p=Object(u["a"])(o,s,i,!1,null,"7a0804ef",null);n["a"]=p.exports;d()(p,"components",{QBtn:l["a"]})},"863e":function(e,n,t){},"8fcf":function(e,n,t){"use strict";var s=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("q-list",{class:e.listClass,attrs:{padding:"",bordered:"",separator:""}},e._l(e.content,(function(n){return t("q-item",{key:n.id,class:e.itemClass,attrs:{to:e.redirection+n.title.toLowerCase().split(" ").join("-"),clickable:""}},[t("q-item-section",{attrs:{avatar:""}},[t("div",[t("q-img",{staticStyle:{border:"solid 3px white",height:"60px",width:"60px","border-radius":"5px"},attrs:{src:n.icon}})],1)]),t("q-item-section",[t("q-item-label",[e._v(e._s(n.title))])],1)],1)})),1)},i=[],r=t("a6f4"),a=Object(r["b"])({props:{listClass:{type:String,required:!0},itemClass:{type:String,required:!0},content:{type:Array,required:!0},redirection:{type:String,required:!0}},setup(){}}),o=a,u=t("2877"),l=t("1c1c"),c=t("66e5"),d=t("4074"),p=t("068f"),m=t("0170"),v=t("eebe"),b=t.n(v),f=Object(u["a"])(o,s,i,!1,null,null,null);n["a"]=f.exports;b()(f,"components",{QList:l["a"],QItem:c["a"],QItemSection:d["a"],QImg:p["a"],QItemLabel:m["a"]})},ab91:function(e,n,t){"use strict";var s="# Présentation de Creascio\r\n\r\n## Introduction\r\n\r\nBienvenue dans Creascio ! Le but de notre communauté est de vous faire **découvrir des langages ou framework informatiques** au travers de **tutos, d'exercices et de projets** à réaliser.\r\n\r\nNous pouvons aussi vous offrir nos **témoignages, astuces et conseils** dans d'autres domaines pratiqués par nos membres.\r\n\r\nNous sommes également une communauté faite pour **rencontrer de nouvelle personnes** que ce soit pour faire des projets ou se faire des amis.\r\n\r\n_PS : Bien sur, nous ne sommes pas des professionnels donc cette communauté est plus une aide à votre autoformation ou un complément aux études que vous faites._\r\n\r\nLa communauté Creascio possède à ce jour deux outils : un [serveur Discord](https://discord.gg/TSjV4jH3Dq) ainsi qu'un [site Bibliothèque](https://creascio.github.io/bibliotheque-v2/#/). (sur lequel vous êtes :D)\r\n\r\n## Le Discord\r\n\r\nLe serveur Discord permet à la communauté d'échanger sur de nombreux domaines, de partager leurs connaissances ou tout simplement de papoter ensemble.\r\n\r\nIl y a différents rôles sur le Discord Creascio :\r\n\r\n- **Helper** : les membres créateurs de contenu pour Creascio\r\n- **Membre** : les membres actifs de la communauté et qui reçoivent les news du serveur\r\n- **Externe** : les membres présents mais qui ne reçoivent pas les news du serveur\r\n- **Visiteur** : les nouveaux membres\r\n\r\nLe Discord Creascio est divisé en plusieurs catégories :\r\n\r\n- **Accueil** : les salons dédiés aux **Visiteur** à leur arrivée.\r\n- **Infos** : les salons dédiés aux informations accessibles à tous les **Membre** et également aux news des **Helper**\r\n- **Podium** : les salons dédiées au partage de contenus divers avec la communauté (musique, art, etc.)\r\n- **General** : les salons dédiées aux discussions en tout genre\r\n- **Jeux** : les salons dédiées au partage de contenus liés aux jeux\r\n- **Aide** : les salons dédiées à tout type de question et à l'aide aux études / projets\r\n\r\n## Les activités\r\n\r\nSur le Discord les **Helpers** peuvent organiser des cours oraux ou des soutiens d'exercices et projets en fonction des besoins des membres.\r\n\r\nNous organisons également des soirées jeux pour papoter en vocal afin de mieux vous connaitre.\r\n\r\nEnfin si vous souhaitez faire un projet en groupe avec des membres de Creascio, les **Helpers** sont à votre disposition pour vous aider dans la limite de nos compétences. Nous pouvons, si vous le voulez, créer un espace sur le discord dédié à votre projet.\r\n\r\n## Le site\r\n\r\nLe site **Bibliothèque de Creascio** regroupe tout le contenu produit par les **Helper** pour les membres de la communauté. La bibliothèque contient tous nos cours sur des sujets divers.\r\n\r\nLes cours sont généralement divisés en plusieurs notions pour faciliter l'apprentissage. Nous nous efforçons d'accompagner les notions du plus d'exemples possibles ainsi que d'exercices pour pratiquer.\r\n\r\n## Pour commencer\r\n\r\nEn tant que nouvel arrivant, nous t'invitons a remplir ce petit questionnaire : [cliquez ici !](https://forms.gle/4XMKZJbRgDmJ38rU7)\r\n\r\n_Remarque : Il est aussi primordial de compléter le cours [Git](https://creascio.github.io/bibliotheque-v2/#/git) avant de commencer votre apprentissage !_\r\n\r\nBravo d'avoir tout lu, vous faites maintenant parti de Creascio !\r\n",i="# Devenir Helper\n\n## Introduction\n\nLes Helpers ont un rôle clé dans Creascio, ce sont les membres qui **créer du contenu** et qui souhaitent **aider les autres membres**.\n\nDans ce document nous allons détailler ce que l'on attend de vous si vous souhaitiez devenir un Helper pour Creascio.\n\n## Ce qu'il faut pour être Helper\n\nPour devenir Helper il faut déjà avoir une **certaine expérience dans une notion**, peu importe son sujet. Il n'est pas nécessaire qu'elle soit déjà abordée dans le cadre de Creascio bien au contraire.\n\nIl faut être capable au minimum de pouvoir **aiguiller les membres** sur cette notion en **répondant à leurs questions**, en faisant part de votre expérience ou bien encore en partageant des contenus utiles à leur formation (vidéos Youtube, sites internet, etc.).\n\nIl faut être capable de faire ceci **au moins à l'écrit** et éventuellement à l'oral sur le Discord.\n\nLes Helpers peuvent également être ammenés à **rédiger des supports de cours** ou bien des **énoncés d'exercices et de projets**.\n\nPour les cours il est possible d'organiser des **sessions de cours orale sur le Discord**.\n\nPour les exercices il faut se porter garant d'être **disponible** si un membre requiert une correction d'exercice.\n\nIl est également possible d'organiser des **sessions de travail en vocal** où les membres pourront poser des questions concernants le cours et/ou les exercices.\n\n## Fonctionnement\n\nN'importe quel membre de Creascio qui se retrouve dans la description du rôle faite au dessus peut proposer sa \"candidature\" aux **Modérateurs**.\n\nIl est très important de **communiquer un maximum** avec les autres Helpers sur vos souhaits, vos idées, vos initiatives, nous sommes une **équipe avant tout**.\n\nBien évidemment le rôle de Helper n'attribut **aucune autorité particulière sur le serveur Discord ou ailleurs**, tous les membres de Creascio sont sur un pied d'égalité.\n\nEn esperant que tout cela vous inspire !\n",r={presentation_creascio:s,devenir_helper:i},a="# Environnement de travail\n\n## Introduction\n\nGit est un outil de **gestion de projet**, il permet de travailler à **plusieurs sur le même projet** tout en évitant le problème de versionning (Le fait d'avoir plusieurs versions différentes d'un même projet).\n\nC'est aussi un outil pratique pour travailler seul étant donné que les données sont hébergées sur un **Cloud**.\n\nDans ce tutoriel, nous allons apprendre les bases de l'utilisation de Git.\n\nPour nous faciliter la vie, nous allons utiliser une application liée à Git qui se nomme **GitHub Desktop** mais sachez que ce n'est pas la seule manière d'utiliser Git.\n\nEn effet, vous pouvez aussi intéragir avec le cloud depuis le site de github, un terminal de commande ou d'autres applications clientes comme [Fork](https://git-fork.com/).\n\n## Setup\n\nPour ce cours nous aurons besoin de :\n\n+ créer un compte [GitHub](https://github.com/)\n+ télécharger l'outil bureau [GitHub Desktop](https://desktop.github.com/)\n\nGitHub est la plateforme centrale qui nous permet de **visualiser le contenu** que l'on héberge sur le Cloud git. Elle permet également de **paramétrer un projet**, d'inviter des **collaborateurs**.\n\nElle propose également de nombreux outils utiles à la **conception** et à la **planification** d'un projet.\n\nGitHub Desktop est un outil complémentaire à GitHub qui permet **manipuler le contenu** de projet git notamment.\n",o="# Base de GitHub\n\n## Introduction\n\nGitHub est un outil de **gestion de projets** git. C'est une plateforme en ligne qui permet à ses utilisateurs de **stocker leur contenu sur le cloud** pour facilier le versionning et la **collaboration entre les membres** d'une équipe.\n\nIl propose de nombreux autres outils qui facilitent la **conception** et la **gestion de projet**.\n\n*Remarque : il existe d'autres plateformes du même genre mais nous utiliserons GitHub dans le cadre de ce cours.*\n\n## Architecture\n\nLorsque vous créez un projet Git, vous créez un **repository**.\n\nUn **repository** est divisé en **branches** qui peuvent stocker des contenus différents. Attention, les branches ne sont pas des sous dossiers ! Ce sont plutôt des bouts de projets ou bien des versions différentes d'un même projet.\n\nAu départ, il n'existe qu'une seule branche, la branche **main**, qui est la branche principale. Vous pouvez créer autant de branches que vous voulez. Il faut juste faire attention au nommage. Deux branches ne peuvent pas avoir le même nom.\n\nLa branche **main** est la branche où sera votre projet final. En règle général, on créé une branche par collaborateur (donc même si vous êtes seul vous vous créez une branche). Cela permet, dès qu'une fonctionnalité marche, de la mettre sur la branche **main**. De plus, si vous faites des bétises sur votre branche, vous aurez une sauvegarde sur la branche **main**.\n\n## Créer un repository\n\nDepuis l'accueil de Github, cliquez sur le bouton **New** pour créer un repository.\nIl faudra lui donner un nom, une potentielle description et choisir sa visibilité.\n\nVous pouvez ajouter un **README**. C'est un document que l'on utilise lorsque\nl'on met en publique son code. Le but étant d'expliquer votre projet et comment le faire marcher. Cela peut être un .txt ou un .md.\n\nVous pouvez aussi ajouter un **.gitignore** si vous faites du node.js, du unity ou d'autres\ntechnologies avec de lourdes bibliothèques.Un **.gitignore** est un fichier qui comme son nom l'indique ignorera toutes les bibliothèques. Ainsi sur le cloud, il n'y aura que votre code.\n\nLorsque vous créez une repository sur Github, il sera totalement vide. (sauf si vous avez créé un README ou un .gitignore)\n\n## Interface repository\n\nLorsque vous cliquez sur l'un de vos repository ou lorsque vous en créez un, l'interface devrait\nressembler à ça. (si ce n'est pas le cas cliquer sur **<> Code** dans le menu)\n\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/825436230095077419/unknown.png\" align=\"center\"/>\n\nComme vous pouvez le voir vous tombez directement sur le code présent dans le main. Si vous avez un README, il est affiché en dessous de vos fichiers.\n\nDepuis cette endroit, vous pouvez ajouter, modifier et supprimer des fichiers ou simplement naviguer dans vos fichiers.\n\nVous pouvez aussi cloner votre repository afin de l'importer sur votre ordinateur en\ntéléchargent un .zip. Pour cela cliquer sur le bouton vert **Code** puis **Download ZIP**\n\n## Paramétrage\n\nIl existe de nombreuses options de personnalisation de votre repository que ce soit pour en filtrer l'accès ou bien le contenu.\n\n### Inviter des collaborateurs\n\nUn collaborateur est quelqu'un qui a accès en lecture ET en écriture à votre code.\n\nPour ajouter des personnes à votre projet, aller dans **Settings** puis dans **Manage access**\npuis cliquer sur **Invite a collaborator** enfin entrer le pseudo de la personne que vous souhaitez ajouter. Celui-ci recevra un mail qui l'invitera sur le repository avec un lien.\n\nVous pouvez à tout moment supprimer un collaborateur.\n\n### Changer la visibilité\n\nDans **Settings** si vous revenez dans **Options** et que vous scrollez tout en bas,\nvous pouvez changer la visibilité d'un repository.\n\nUn repository publique permet à n'importe qui de voir le code et de le copier sur son ordinateur mais il ne peutpas être modifier. Un repository privé est totalement caché, on ne peux pas le voir ni le changer à mois d'etre un collaborateur.\n\n### Archiver\n\nDans **Settings** si vous revenez dans **Options** et que vous scrollez tout en bas,\nvous pouvez archiver un repository.\n\nLorsqu'un repository est archiver vous et vos collaborateur ne pouvez plus le modifier mais\nvous avez toujours accès au code en lecture. Cette action est reversible.\n\n### Supprimer\n\nDans **Settings** si vous revenez dans **Options** et que vous scrollez tout en bas,\nvous pouvez supprimer un repository.\n\nCette action est irreversible donc attention !\n\n## Exercices\n\n### Question 1 : Création de projet\n\nCréez un repository appelé \"Test\", mettez en description \"Je suis un repository test\", mettez le en privé et ajouter un README.\n\nAprès avoir cliqué sur ``<> Code`` voici ce que vous devriez avoir comme résultat :\n\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/828643996434956328/unknown.png\" align=\"center\"/>\n\n### Question 2 :  Faire un commit\n\nModifiez le contenu de votre README : \"Premier projet git, c'est beau !\" (N'oubliez pas de commit !)*\nVous verrez son aperçu changer en revenant à la racine de votre branche.\n\n### Question 3 : Ajouter un collaborator\n\nInvitez `Shiropetite` dans votre repository.\n\n### Question 4 : Supprimer votre repository\n\nCe repository n'est pas très utile avec juste un README. Nous allons donc le supprimer.\n",u="# Base de GitHub Desktop\n\n## Introduction\n\nGithub Desktop est un outil de bureau en lien avec Github et qui permet la **gestion du contenu** de repository git.\n\nC'est une interface qui rend ce processus plus **graphique et intuitif** mais elle n'est en aucun cas nécessaire pour manipuler des projets git, une invite de commande suffit pour cela.\n\n## Interface\n\nVoici à quoi ressemble l'interface de **Github Desktop**.\n\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/825439994806140998/unknown.png\"/>\n\n## Gestion de repository\n\nA droite, cliquez sur `Current repository`. Cela vous ouvrira un menu qui contient **tout vos repository**. Dans ce menu, cliquez sur le bouton `Add`. (Si vous n'avez jamais fait de projet Git, on vous proposera tout de suite d'ajouter un repository).\n\nLorsque vous cliquez sur `Add` trois choix s'offrent à vous :\n\n+ `Clone repository` : **Copiez votre projet Git sur votre pc** (ou un repository public). Lorsque vous cliquez, cela vous ouvrira une fenêtre qui vous proposera soit de choisir parmi les repository auquels vous avez accès, soit d'insérer l'url ou nom d'un repository. Dans tout les cas vous devrez aussi insérer **l'endroit où vous voulez sauvegarder** ce repository.\n\n+ `Create new repository` : **Créez un repository de 0**. Lorsque vous cliquez, cela vous ouvrira une fenêtre qui vous demandera le nom, la potentielle description, le chemin où vous voulez stocker votre projet et enfin si vous voulez ajouter un README. Vous aurez en plus le choix d'ajouter un .gitignore (choisissez simplement le langage que vous allez utiliser).\n\n+ `Add existing repository` : **Ajoutez un repository git déjà présent localement sur votre pc** (il doit avoir le fichier .git). Lorsque vous cliquez, cela vous ouvrira une fenêtre qui vous demandera **le chemin du repository sur votre pc**.\n\n## gitignore\n\nUn .gitignore est un fichier qui permet au repository **d'ignorer certains types de fichiers** comme de lourdes bibliothèques (par exemple `node-modules`).\n\n## Gestion de branches\n\nIl est important de créer des branches afin de stocker plusieurs versions d'un même projet.\n\nPour créer un branche depuis Github Desktop, cliquer sur `Current branch`. Cela vous ouvrira un menu où vous pourrez **naviguer de branches en branches**.\n\nDepuis ce menu, cliquez sur `New branch` pour créer un nouvelle branche. Cela vous ouvrira une fenêtre qui vous demandera **le nom de votre nouvelle branche**.\n\n*Remarque : celui-ci ne doit pas être le même qu'une autre branche !*\n\nIl vous demandera aussi, si vous n'êtes pas sur la branche `main`, **depuis quel branche vous voulez créer la nouvelle**.\n\nSi vous sélectionner `main`, il prendra alors la version du projet de main et la mettra sur votre branche. Si vous sélectionner une autre branche, il prendra la version de la branche sélectionnée.\n\nN'oubliez pas une fois la branche créée de cliquez sur `Publish Branch`, sinon cette branche ne sera créé que **localement sur votre pc**.\n\nSi vous faites un clic droit sur une des branches depuis le menu de navigation de branches, vous pourrez renommer une branche ou en supprimer une.\n\n*Remarque : si vous le faites, n'hésiter pas à recloner votre projet et à demander à vos collaborateurs de le faire aussi. Sinon vous risquez de vous retrouver avec des branches fantômes.*\n\nPour recloner un projet, supprimer le dossier de votre projet local puis aller sur Github Desktop et cliquer sur `Clone Again`.\n\nN'oubliez pas de `Push` vos changements **AVANT** sinon ils seront perdus !\n\n## Commit\n\nLorsque vous allez effectuer des changements sur vos fichiers, Github Desktop affichera ceci sur la gauche de l'écran :\n\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/825442599301152818/unknown.png\" />\n\nDans le screen, nous pouvons voir que 7 fichiers ont été modifié. Le carré jaune signifie que **le contenu du fichier a changé**, le carré vert signifie que le fichier **a été créé ou ajouté** et le carré rouge signifie que **le fichier a été supprimé**.\n\nEn cliquant sur l'un des fichiers, vous pouvez voir **les modifications en détails**. Les lignes surlignées en **vert** sont les lignes **ajoutées** et les lignes surlignées en **rouge** sont les lignes **supprimées** du fichier.\n\nLorsque vous voudrez sauvegarder votre travail, vous devrez alors donner un nom à votre **commit** dans le champs `Sumarry (required)`.\n\nCe nom doit normalement représenter **les changements que vous avez fait** comme \"Update ... file\", celui-ci est **obligatoire** pour commit.\n\nVous pouvez aussi ajouter un description. Une fois que vous avez donner un nom à votre commit cliquer sur `Commit to [nom-de-la-branche-actuelle]`.\n\nUn commit est une sauvegarde **uniquement locale à votre pc**.\n\n## Push, Pull, Fetch\n\nLe bouton `Fetch origin` permet de **comparer votre version et celle du cloud**, il détecte donc quand vous devez **push** ou **pull**.\n\nLorsque vous effectuez un commit le bouton qui se nommait à l'origine `Fetch origin` se transformera en `Push`. Cet action permet\nde **mettre à jour votre commit sur le cloud de Git** afin que vos collaborateurs voient vos changements.\n\nLorsque vos amis **push** quelque chose, vous pourrez alors cliquer sur `Fetch origin`, une fois cela fait ce bouton se transformera en `Pull` ce qui permettra de **mettre à jour votre version depuis le cloud**.\n\nLorsque vous voulez **push** un commit, il faudra vérifier que votre version est bien à jour avec le cloud et donc si vous n'avez pas à **pull** avant. Dans notre cas, Github Desktop vous préviendra.\n\n## Exercices\n\n### Question 1 : Créer un projet\n\nCréer un projet sur Github Desktop, appeler le \"First-Project\" vous pouvez mettre la description que vous voulez.\n\n### Question 2 : Créer une branche\n\nCréer une branche qui vous nommerez \"develop\"\n\n### Question 3 :  Faire un commit\n\nDans la branche develop, créer un fichier texte avec n'importe quel texte dessus. Puis appeler votre commit \"Create a text file\" puis commiter !\n\n### Question 4 : Push le commit\n\nEnfin n'oubliez pas de push !\n",l="# Merge Request\n\n## Introduction\n\nLors d'un projet en équipe, la possibilité de merge différentes branches de travail est cruciale pour pouvoir **contrôler** que l'apport de **nouvelles fonctionnalités** dans la version principale du projet se fait correctement.\n\n## Merge\n\nL'action de merge se fait toujours d'une branche vers une autre, on dit qu'on merge la branche A dans la branche B. Ainsi le contenu de la branche A **va se retrouver dans la branche B** et la branche A peut être supprimé ensuite.\n\nLa bonne pratique veut que dans un projet en groupe ou chacun travaillerait sur une ou plusieurs tâches précises, une fois ces tâches accomplies on merge leurs branche vers la branche principale `main` (ou `master`).\n\nUn merge peut entraîner des **conflits sur la branche qui reçoit les modifications** si les deux branches contenaient un fichier avec une **signature identique** (même nom et extension) et que la branche entrante n'est pas à jour avec la branche recevante.\n\n## Conflits\n\nEn fonction du type de conflits, Github Desktop peut proposer de prendre en charge la gestion du conflit en proposant d'utiliser **Visual Studio Code** (un éditeur évolué de Microsoft). L'éditeur vous permet alors de choisir entre :\n\n+ garder uniquement les modifications actuelles, c'est à dire l'état du fichier **avant merge**\n+ garder uniquement les modifications entrantes, c'est à dire **remplacer le contenu** du fichier\n+ garder toutes les modifications, l'éditeur va tenter de **fusionner les deux états** du fichier.\n\n*Remarque : les conflits restent très rare vous n'avez pas a trop vous inquietez mais il faut savoir quoi faire quand on tombe dessus.*\n\n## Exercices\n\n*Coming soon...*\n",c="# Pull Request\n\n## Introduction\n\nLes Pull Requests sont une fonctionnalité permettant à un collaborateur d'un repository git de demander l'avis d'un autre collaborateur, que l'on appelle un **reviewer**, avant de **merge une branche dans une autre**.\n\nC'est un outil très pratique pour permettre de **détecter les coquilles éventuelles** dans un code et cela permet également de **maintenir l'équipe informée** du travail effectué s'ils sont reviewer.\n\n## Utilisation\n\nPour pouvoir effectuer des Pull Requests sur un repository il faut au moins qu'il contienne **deux branches**. La branche depuis laquelle la requête sera émise et la branche qui va recevoir les modifications.\n\nUne fois que du contenu a été **push** sur la version Cloud d'une branche, il est possible via GitHub ou bien GitHub Desktop d'émettre une Pull Request. Il faut alors désigner **les branches entrante et recevante** du merge a effectuer.\n\nAprès cela on peut choisir quel(s) reviewer(s) seront alertés par notre requête. Ces derniers reçoivent une alerte par mail.\n\n## Reviewing\n\nUne fois informé un reviewer peut voir le contenu de la branche entrante et notamment le **contenu du push** concerné. Il peut alors déposer des **commentaires** dans les fichiers et finalement **accepté ou refusé la demande de merge**.\n\n## Exercices\n\n*Coming soon...*\n",d={environnement_travail_git:a,bases_github:o,bases_github_desktop:u,merge_request:l,pull_request:c},p="# Environnement de travail\n\n## Introduction\n\nDans ce cours nous allons apprendre à manipuler un compilateur\n\n## Setup\n\nPour ce cours vous aurez besoin d'un moyen de compiler, c'est-à-dire éxécuter votre programme.\n\nPour ce faire, nous allons utiliser (https://www.tutorialspoint.com/compile_c_online.php)\n\nVous pourrez écrire votre code dans le champ de gauche puis **Execute** pour obtenir le résultat dans la console à droite\n\nIl sera possible de passer des informations en entrée de votre programme dans l'onglet STDIN.\n",m="# Variables et Types primitifs\n\n## Introduction\n\nUn programme informatique a généralement pour but de manipuler des **données**.\n\nCes données peuvent être très diverses et sont représentées de manière tout aussi diverses selon les langages de programmation.\n\nDans la plupart des langages, on utilise des **types**, qu'on pourrait décrire comme des **catégories**, pour caractériser les données.\n\n## Variables\n\nLes variables sont les éléments de notre code qui vont nous permettre de stocker des informations de manière durables. Une variable possède une donnée ainsi qu'un nom.\n\nLe nom permet d'identifier la variable donc il faut être assez clair lors du nommage pour que l'on comprenne la donnée qu'elle stocke.\n\nVoici quelques exemples:\n\n```\n  quantite_de_farine = 100\n  mot = patate\n  je_suis_un_robot = vrai\n```\n\nCe n'est pas du vrai code juste un exemple pour vous donnez une idée.\n\n## Types\n\nLes variables possède un type même si c'est parfois implicites.\n\nIl existe une multitude de types différents en fonction des langages de programmation mais certains se démarquent par le fait qu'ils sont présent dans tous les langages typés.\n\nOn appelle ces types des **types primitifs**. Ce sont les types les plus basiques. Ils sont rangés en plusieurs familles :\n\n- Les nombres (**number**) : permettent de stocker des **nombres**.\n  Ils sont parfois divisés en deux sous catégories :\n\n- Les types entiers : permettent de stocker un **nombre entier**.\n  Cette famille est composée de : **int**, **byte**, **short** et **long** (**int** est le plus courant).\n\n  ```\n    int quantiteDeFarine = 100\n  ```\n\n- Les types flottants : permettent de stocker un **nombre à virgule**.\n  Cette famille est composée de : **float** et **double** (**float** est le plus courant).\n\n  ```\n    float poidDuLivre = 0.5\n  ```\n\n- Le type caractère **char** permet de stocker un seul caractère de la table **ASCII**. Cette table contient toutes les lettres, les chiffres et les symboles occidentaux.\n\n  ```\n    char lettre = 'a'\n  ```\n\n- Le type booléen **boolean** permet de stocker une information booléene, c'est-à-dire, une information à **deux** valeurs possibles (Ex : oui ou non, vrai ou faux, 1 ou 0, etc.).\n\n  ```\n    boolean jeSuisUnRobot = true\n  ```\n\nEnfin, dans tout les langages il existe des tableaux. Un tableau est généralement représenter par des crochets comme ceci [ ]. Un tableau ne peut contenir qu'un seul type de donnée soit des **char**, soit des **nombres**,...\n\n```\n  char mot[7] = { 'b','o','n','j','o','u','r'};\n```\n\nIci le tableau a une taille de 7 cela veut dire qu'il stocke 7 éléments ni plus ni moins !\n\nUn tableau comme son nom l'indique est une suite d'emplacements. Pour naviguer dans un tableau, on utilise un index qui représente la position d'un élement dans un tableau. Attention ! En programmation, on compte à partir de 0 et pas de 1 donc le premier élément est à l'index 0 et non pas 1.\n\n```\n  mot[0] // affiche b\n  mot[1] // affiche o\n  mot[6] // affiche r\n```\n\n## Exercices\n\n*Coming soon...*\n",v="# Affichage Console\n\n## Introduction\n\n*Coming soon...*\n\n## Contenu\n\n*Coming soon...*\n\n## Exercices\n\n*Coming soon...*\n",b="# Conditions Booléennes\n\n## Introduction\n\n*Coming soon...*\n\n## Contenu\n\n*Coming soon...*\n\n## Exercices\n\n*Coming soon...*\n",f="# Boucles de Contrôle\n\n## Introduction\n\n*Coming soon...*\n\n## Contenu\n\n*Coming soon...*\n\n## Exercices\n\n*Coming soon...*\n",h={environnement_travail_c:p,types_primitifs_variables:m,affichage_console:v,conditions_booleennes:b,boucles_controle:f},g="# Environnement de travail\n\n## Introduction\n\nJava est un langage de programmation **orienté objet**. Le but de ce langage est de produire un code **facilement maintenable et modulable**.\n\nCe langage est généralement utilisé dans des contextes **client-serveur**. Ils existent de nombreux langages et outils qui dérivent du Java comme [Spring](https://spring.io/).\n\nDans ce cours nous allons configurer notre environnement de travail Java.\n\n## Setup\n\nPour le bien de ce cours nous aurons d'abord besoin d'installer :\n\n+ une version du [Java Development Kit](https://www.oracle.com/java/technologies/javase-downloads.html)\n+ l'environnement de travail [Eclipse](https://www.eclipse.org/downloads/)\n\nLe JDK est l'ensemble des outils nécessaire à notre machine pour pouvoir **lire et exécuter** du code Java.\n\nNous avons choisi Eclipse comme IDE (integrated development environment) pour ce cours mais il en existe d'autres, notamment [IntelliJ](https://www.jetbrains.com/fr-fr/idea/)\n\n## Architecture\n\nPour coder en Java, on créer des **projets** qui sont stockés en tant que **dossier** sur votre PC. Les projets peuvent être arrangés dans ce qu'on appelle une **workspace**.\n\n*Remarque : le concept de workspace ou d'espace de travail est présent et nécessaire sur Eclipse mais ce n'est pas le cas sur d'autres IDE notamment les plus récents.*\n\nChaque projet contient un dossier `src` qui est le dossier source qui contiendra votre code.\n\n*Remarque : le dossier de projet contient également un dossier `dist` ou `build` qui contient le code compilé du projet mais on ne modifie jamais soit même le contenu de ce dossier.*\n\nLe dossier src peut contenir des sous dossiers appelés **packages**. Les packages permettent d'organiser le code par \"famille\". Nous verrons plus tard sa vraie utilité lorsque nous aborderons le sujet des dépendances.\n\nEnfin on retrouve les **classes** qui sont le modèle de définition de nos objets comportant des **attributs**, c'est-à-dire des **caractéristiques**, et des **méthodes** qui décrivent le **comportement** des objets.\n\n## Créer un projet\n\nPour créer un projet Java sous Eclipse il faut tout d'abord lancer Eclipse sur une workspace existante ou bien en créer une nouvelle.\n\nUne fois dans votre workspace vous pouvez créer un projet :\n\n+ via le menu : `File > New > Java Project`\n+ via l'interface : `Clic droit > New > Java Project`\n\nIl vous sera ensuite demander de nommer votre projet, les autres options ne nous intéresse pas pour le moment et vous pouvez ensuite appuyer sur `Finish`.\n\nLe projet et son architecture sont alors créés, il ne vous reste plus qu'a créer :\n\n+ vos packages : `src (clic droit) > New > Package`\n+ vos classes : `package (clic droit) > New > Class`\n\n*Remarque : Eclipse créé un package de base lors de la création de la première classe de votre projet si vous n'aviez pas créer de package auparavant.*\n",q="# Classes et Attributs\n\n## Introduction\n\nUne classe Java est une **structure** permettant de décrire l'implémentation d'un **objet** dans notre programme. C'est le code de cette classe qui va nous permettre de décrire **à quoi va ressembler** notre objet à sa création et les **actions possibles** sur celui-ci.\n\nDans ce cous nous allons voir comment se construit un bloc classe ainsi que les objets et leurs caractéristiques.\n\n## Composition\n\nUne classe est un bloc de code qui va contenir toutes les informations concernant nos objets :\n\n```\npublic class Toto {\n  // code goes here\n}\n```\n\nIci la classe `Toto` va nous permettre de pouvoir manipuler des objets de type `Toto`.\n\nPour décrire un objet, la classe est composée d'**attributs** et de **méthodes**.\n\n### Les attributs\n\nLes attributs sont des **variables** qui décrivent l'état d'un objet. Comme toute variable, ils possèdent un **nom** et un **type de donnée**. Ils possèdent également une **visibilité** et éventuellement des **propriétés**.\n\nVoici un exemple tout simple :\n\n```\nint age;\n```\n\nIci on représente l'**age** d'un individu par un **nombre entier**. La variable s'appelle `age` et n'a pas encore de valeur.\n\n### Nommage\n\nPar convention on nomme **les classes** en respectant le **PascalCase** (majuscule à chaque mot, pas d'espace ou de tiret).\nOn nomme **les attributs et les méthodes** en respectant le **camelCase** (majuscule à partir du deuxième mot, pas d'espace ou de tiret).\n\n### Types\n\nIls existent en Java comme dans les autres langages deux catégories de type de donnée. Les types **primitifs** et les types **complexes**.\n\nLes types primitifs sont les suivants :\n\n+ `int, byte, short, long` : pour stocker des **nombres entiers**\n+ `float, double` : pour stocker des **nombres à virgule**\n+ `char` : pour stocker des **caractères** (lettres, chiffres, symboles, etc.)\n+ `boolean` : pour stocker une information booléenne c'est à dire qui ne peut prendre que **deux valeurs** (ex : vrai ou faux, 0 ou 1)\n\n*Remarque : les différents types permettants de stocker des nombres entier ou à virgule ne varie que par la taille de l'emplacement mémoire qui leur est attribué. Cela change la valeur maximale ou minimale que la variable peut prendre.*\n\n*Remarque : pour les nombres entier le `int` est le type le plus courant, pour les nombres à virgule c'est le `float`*\n\nLes types complexes sont des types composés eux même d'autres types comme par exemple `String` ou notre propre type `Toto`.\n\nOn peut créer des objets de types complexes mais **pas de types primitifs**.\n\nQuelques cas concrets :\n\n```\nint age = 20;\nfloat moyenne = 13.65;\nchar note = 'A'\nboolean estGenial = true;\n```\n\n## Les Tableaux\n\nTout comme dans de nombreux autres langages il est possible de créer des tableaux d'objets ou de valeurs en Java.\n\nCes tableaux peuvent stocker des objets d'un type donné dans des **cases mémoires**.\n\nUn tableau à une taille **non dynamique**, on peut effectuer des actions simples dessus comme **la récupération, l'ajout ou le retrait** d'éléments.\n\n*Remarque : il existe de nombreuses autres actions plus complexes sur les tableaux mais nous en parlerons plus tard.*\n\n**Exemple** :\n\n```\npublic class Toto {\n  int age;\n  int[] notes;\n}\n```\n\n## Visibilité\n\nIl existe plusieurs niveau de visibilité pour les classes, les attributs ou bien encore les méthodes :\n\n+ `public` : visible et accessible par **tout le reste du programme**.\n+ `private` : visible et accessible uniquement dans la **classe**.\n+ `protected` : visible et accessible uniquement dans le **package**.\n\nUne bonne utilisation de la visibilité serait la suivante :\n\n```\npublic class Toto {\n  private String nom;\n  private int age;\n  public boolean estUnIdiot = true;\n}\n```\n\nDans le bloc de code ci-dessus, la classe `Toto` est en `public` car on souhaite pouvoir accéder aux informations décrivant un objet de type `Toto` dans le reste du code pour pouvoir par exemple **créer et manipuler** des objets de ce type.\n\nLes attributs `nom` et `age` sont en `private` car la valeur de ces attributs ne doit être modifiable que par l'objet qui les stocke.\n\nL'attribut `estUnIdiot` est en public, la valeur de ce booléen peut être modifié n'importe où dans le code également.\n\n*Remarque : dans la grande majorité du temps les attributs d'objets sont en `private` pour maintenir la sécurité du code, on appelle ça l'encapsulation de donnée.*\n\n*Remarque : bien que la visibilité `protected` existe, on ne l'utilise quasiment jamais car il est rare de créer une situation où elle serait utile.*\n\n## Propriétés\n\nIl existe plusieurs propriétés pour les attributs :\n\n+ **static** : la valeur de l'attribut est **commune à toutes les instances de la classe**.\n+ **final** : la valeur de l'attribut **ne peut pas être modifié après la première instanciation**.\n\nPour reprendre l'exemple au dessus :\n\n```\npublic class Toto {\n  private final String nom;\n  private int age;\n  public static boolean estUnIdiot = true;\n}\n```\n\nL'attribut `nom` est en `final` car on ne change pas de nom une fois qu'on en a un généralement. C'est une **constante**.\nL'attribut `age` n'est en `final` car sa valeur va être amenée à **changer plusieurs fois**. (en tout cas on l'espère pour Toto).\nL'attribut `estUnIdiot` est en `static` ce qui indique que la valeur de cette attribut est **commune à tous les objets de type** `Toto`. Elle peut cependant être modifié ce qui effectuera la modification pour tous les `Toto`\n\nVoici un exemple plus spécifique :\n\n```\npublic class Chien {\n  private static final boolean estMoinsBienQueLesChats = true;\n}\n```\n\nIci l'attribut indique que **pour n'importe quel chien**, son attribut `estMoinsBienQueLesChats` est **toujours vrai** et il **ne peut pas être modifié**.\n\n## Exercices\n\n*Coming soon...*\n",x="# Méthodes\n\n## Introduction\n\nLes méthodes représentent **l'ensemble des comportements d'un objet** ou bien encore **les actions qu'il peut accomplir** ou bien **les changements que l'on peut effectuer sur celui-ci**.\n\nLes méthodes sont des fonctions qui font partie du bloc classe tout comme les attributs.\n\n## Composition\n\nLes méthodes sont des **blocs d'instructions composés** d'un **prototype** suivi d'une ou plusieurs lignes de code.\n\nLe prototype d'une méthode suit cette structure : `visibilité propriété valeur_de_retour nom (paramètres_entrées)` comme ci-dessous :\n\n```\npublic static int addition(int premierNombre, int deuxiemeNombre){\n  return premierNombre + deuxiemeNombre;\n}\n```\n\nLa méthode est `public`, elle est donc **visible par tout notre code**, elle est également `static` donc elle peut être appelée **sans l'aide d'un objet**.\n\n*Remarque : nous reviendrons sur la façon d'appeler une méthode un peu plus tard.*\n\nElle s'appelle `addition` et prend en paramètre d'entrée deux nombres de type `int` : `premierNombre` et `deuxiemeNombre`.\n\nElle **renvoie la somme** de ces deux nombres sous la forme d'une valeur entière d'où `int`.\n\n## Le constructeur\n\nLe constructeur est une méthode particulière qui permet **d'instancier des objets** c'est à dire de les **initialiser** pour pouvoir ensuite les manipuler.\n\nGénéralement un constructeur permet de **donner des valeurs aux attributs** du futur objet à créer mais on peut s'en servir pour faire bien d'autres choses.\n\nIl se déclare toujours par le **nom de la classe** en question. Comme toutes autres méthodes il peut prendre des paramètres d'entrées.\n\nVoici un exemple :\n\n```\npublic class Chien {\n  private int age;\n  private final String nom;\n\n  public Chien(int age, String nom){\n    this.age = age;\n    this.nom = nom;\n  }\n}\n```\n\nIci le constructeur de `Chien` nous permet d'attribuer des valeurs à l'`age` et au `nom` du chien que l'on souhaite créer.\n\nLe `this` fait référence à **l'objet courant**.\n\n*Remarque : une classe peut contenir plusieurs constructeurs tant que ceux ci ne créé pas des objets similaires, c'est à dire qu'ils ne prennent pas les mêmes paramètres d'entrées. Cela permet une plus versatilité des objets.*\n\n### Objet courant\n\nDans le contexte d'une méthode Java, l'objet courant est **un objet du type de la classe dans laquelle on se situe**.\n\nL'objet courant fait référence à **l'objet qui a appelé la méthode** ce qui nous permet d'accéder aux attributs de cet objet ou bien encore aux méthodes de la classe de cet objet.\n\n*Remarque : dans le cadre du constructeur, `this` fait référence à l'objet qu'on est en train de créer*\n\nC'est une notion assez abstraite alors voici un exemple :\n\n```\npublic class Chien {\n  private int age;\n  private String nom;\n  private String race;\n\n  // créer un chien qui possède un nom, un age mais pas de race\n  public Chien(int age, String nom) {\n    // l'age du chien créé aura pour valeur celle passée en entrée\n    this.age = age;\n    // de même pour le nom\n    this.nom = nom;\n  }\n\n  // créer un chien complet\n  public Chien(int age, String nom, String race) {\n    // on appelle le premier constructeur pour s'occuper de l'age et du nom de la même façon\n    this(age, nom);\n    // on associe la valeur pour la race du chien\n    this.race = race;\n  }\n}\n```\n\n*Remarque : l'exemple ci dessus sert a montrer la capacité de `this` à accéder a des attributs tout comme des méthodes. Dans les faits faire deux constructeurs ici n'est pas très utile.*\n\n## Getter et Setter\n\nLes getters et les setters sont des méthodes standardes de **manipulation d'attributs**.\n\nLes getters permettent de **récupérer une valeur** et les setters permettent de **modifier une valeur**.\n\nPar convention on nomme les getters `get[nomAttribut]` et les setters `set[nomAttribut]`.\n\nEn reprenant notre classe précédente :\n\n```\npublic class Chien {\n  private int age;\n  private String nom;\n\n  public int getAge(){\n    // on récupère l'age du chien qui appelle la méthode\n    return this.age;\n  }\n\n  public void setNom(String nom){\n    // on modifie le nom du chien qui appelle la méthode\n    this.nom = nom;\n  }\n}\n```\n\n*Remarque : Il est possible de générer automatiquement le constructeur, les getters et les setters sur la plupart des IDE modernes.*\n\n## ToString\n\nLa méthode `toString` est par convention la méthode que l'on utilise pour **afficher les informations d'un objet**.\n\n*Remarque : par convention la méthode `toString` ne permet pas d'afficher directement le message, seulement de le créer*\n\nElle se construit généralement de cette façon :\n\n```\npublic String toString() {\n  String s = // le message que l'on souhaite produire\n  return s; // renvoie le message pour un affichage possible plus tard\n}\n```\n\nUne fonctionnalité importante de la chaîne de caractère et donc de la génération de message est la **concaténation**.\n\n### La concaténation\n\nLa concaténation est une propriété de la chaîne de caractère à pouvoir convertir des données de types différents en chaîne de caractères.\n\nPour cela on utilise le symbole `+`.\n\n*Remarque : le symbole `+` ici n'a pas le même sens que le `+` de l'addition. C'est le cas d'autres symboles en Java ou dans d'autres langages. Leur sens dépend du contexte.*\n\nVoici un exemple :\n\n```\nString s = \"Bonjour je m'appelle \" + this.getNom() + \" et j'ai \" + 12 + \" ans !\";\n```\n\nOn obtient par exemple : `Bonjour je m'appelle Toto et j'ai 12 ans !`\n\n## Exercices\n\n*Coming soon...*\n",y="# Programme Principal\n\n## Introduction\n\nLe main en Java est une **méthode** qui représente le **programme principal**, c'est le bloc de code qui sera executé au lancement de l'**éxécution** du projet.\n\nLe main est généralement dans **une classe à part**. On peut le générer facilement dans tous les frameworks.\n\nC'est dans celui-ci qu'on **instancie et manipule nos objets** et que l'on **intéragit avec l'utilisateur** via la console par exemple.\n\n## Instancier des objets\n\nOn doit instancier nos objets Java pour pouvoir les manipuler. Pour cela on leur attribut de l'espace mémoire grâce à l'outil `new`.\n\nUn exemple d'instanciation :\n\n```\nChien chien = new Chien(4, \"Pluto\");\n```\n\nIci on instancie un objet de type `Chien`. Le nom de variable de l'objet est `chien`. Le chien a 4 ans et il s'appelle Pluto.\n\nOn a donc :\n\n```\nchien.age = 4\nchien.nom = Pluto\n```\n\nLes tableaux suivent le même comporter et doivent être instancier avant utilisation tout comme les objets :\n\n```\n// 10 indique la taille du tableau qui peut alors stocker 10 éléments\nint tab[] = new int[10]\n```\n\n## Affichage console\n\nOn peut afficher des **chaînes de caractères** dans la console via la commande `print()` ou `println()`\n\n*Remarque : la deuxième est la plus courante et permet de sauter une ligne dans l'affichage après avoir afficher le contenu.*\n\nVoici un exemple :\n\n```\nSystem.out.println(\"Hello World !\");\n```\n\nOn obtient alors dans la console : `Hello world !`\n\n## Exercices\n\n### Exercice 1 : Tel chien, tel maître\n\nOn souhaite représenter un chien et son maitre. Tous les deux possède un nom. Le maitre ne peut posséder qu'un seul chien.\nLe maître doit pouvoir produire le message suivant : `Je m'appelle [nom_du_maitre] et voici mon chien [nom_du_chien] !`\n\n1. Identifiez les **objets** à implémenter et créez en conséquence les **classes** nécessaires. Identifiez ensuite les **attributs** de ces objets et implémentez les dans vos classes. Vous créerez également les **constructeurs**, **getters**, **setters** et autres méthodes nécessaires à la manipulation de vos objets.\n\n2. Développez un **programme principal** permettant de produire ce résultat :\n\n`Je m'appelle Mario et voici mon chien Pito !`\n\n`Je m'appelle Luigi et voici mon chien Malo !`\n\n`Je m'appelle Mario et voici mon chien Malo !`\n\nIl n'y a pas d'**intervention utilisateur** dans le programme principal. Celui ci doit uniquement **instancier des objets** et **afficher le résultat** potentiel de méthodes dans la console. Il ne doit pas y avoir d'**algorithmie** dans le programme principal !\n\n### Exercice 2 : Compte bancaire\n\nOn souhaite représenter un utilisateur et son compte bancaire. Chaque utilisateur possède un nom et un solde de compte (en euros).\nL'utilisateur doit pouvoir produire le message suivant : `Je m'appelle [nom_utilisateur] et j'ai [solde_compte] euros !`\n\nOn doit pouvoir débiter et créditer le compte. Le débit ne peut se faire que si la somme souhaitée est présente sur le compte. L'action de débiter ou créditer doit produire des messages de réussite ou d'erreur comme suit :\n\n+ Pour le crédit : `Compte de [nom_utilisateur] crédité de [somme] euros !`\n+ Pour le débit (succès) : `Compte de [nom_utilisateur] débité de [somme] euros !`\n+ Pour le débit (échec) : `Erreur : Impossible de débiter le compte de [nom_utilisateur] de [somme] euros, solde insuffisant :(`\n\n1. Identifiez les **objets** à implémenter et créez en conséquence les **classes** nécessaires. Identifiez ensuite les **attributs** de ces objets et implémentez les dans vos classes. Vous créerez également les **constructeurs**, **getters**, **setters** et autres méthodes nécessaires à la manipulation de vos objets.\n\n2. Développez un **programme principal** permettant de produire ce résultat :\n\n`Je m'appelle Clubbo et j'ai 10 euros !`\n\n`Erreur : Impossible de débiter le compte de Clubbo de 20 euros, solde insuffisant :(`\n\n`Compte de Clubbo crédité de 35 euros !`\n\n`Compte de Clubbo débité de 20 euros !`\n\n`Je m'appelle Clubbo et j'ai 25 euros !`\n\nIl n'y a pas d'**intervention utilisateur** dans le programme principal. Celui ci doit uniquement **instancier des objets** et **afficher le résultat** potentiel de méthodes dans la console. Il ne doit pas y avoir d'**algorithmie** dans le programme principal !\n\n### Exercice 3 : Tableau de chasse\n\nLe but de cet exercice est de reprendre les structures de données de l'exercice 1 et d'automatiser le processus de production de message pour un **groupe de maître et de chien**. On doit pouvoir stocker en mémoire 5 maîtres et 5 chiens différents et **pour chacun** des maîtres produire leur message respectif.\n\nDéveloppez un **programme principal** permettant de produire ce résultat :\n\n`Je m'appelle Tata et voici mon chien Dada !`\n\n`Je m'appelle Tete et voici mon chien Dede !`\n\n`Je m'appelle Titi et voici mon chien Didi !`\n\n`Je m'appelle Toto et voici mon chien Dodo !`\n\n`Je m'appelle Tutu et voici mon chien Dudu !`\n\n**Attention !** Votre programme ne doit contenir qu'**un seul appel à la console** (un seul `System.out.print()`) !\n",j="# Enumerations\n\n## Introduction\n\nLes énumerations, ou Enum, permettent de créer une **famille de valeurs possibles pour représenter un concept**.\n\nL'Enum n'est pas une classe et ces valeurs ne sont pas des objets à part entière. Un Enum est **une liste de constantes**.\n\n## Usage\n\nOn peut se servir des valeurs d'un Enum pour attribuer une valeur à **des attributs ou des variables**.\n\nLes Enums sont utiles lorsque **l'on sait que l'on va avoir des valeurs qui ne vont jamais changer** comme les mois, les jours de la semaine ou encore les couleurs.\n\n## Composition et Utilisation\n\nUn Enum contient essentiellement des valeurs possibles :\n\n```\npublic Enum Couleur {\n  rouge, vert, bleu, jaune;\n}\n```\n\nVoici un cas d'utilisation dans une classe :\n\n```\npublic class Peinture {\n  private int prix;\n  private Couleur couleur;\n}\n```\n\nEt un exemple d'instanciation :\n\n```\nPeinture p = new Peinture();\np.couleur = Couleur.rouge;\n```\n\nOn voit ici un cas concret d'utilisation d'un Enum et comment accéder à une valeur de cet Enum.\n\nIci l'Enum est très simple et ne stocke que des valeurs mais il peut être plus complexe.\n\n## Paramétrage\n\nUn Enum peut avoir des **attributs**. **Chacune de ses constantes** possède une valeur pour ses attributs. On dit que l'Enum est **paramétré**.\n\nVoici un exemple :\n\n```\npublic Enum Couleur {\n  rouge('r'),\n  vert('v'),\n  bleu('b'),\n  jaune('j');\n\n  private char symbole;\n\n  private Couleur(char symbole){\n    this.symbole = symbole;\n  }\n\n  public char getSymbole(){\n    return this.symbole;\n  }\n}\n```\n\nDans l'exemple du dessus, on associe à chaque couleur un `symbole` représenté par un caractère.\n\nSi un Enum est paramétré alors on créé un **constructeur privé** capable d'instancier toutes ses constantes et éventuellement des **getters et des setters**.\n\n*Remarque : le constructeur n'est utile que pour paramétrer les constantes existantes ou pour ajouter de nouvelles constantes durant le programme (ici de nouvelles couleurs), on n'a pas besoin d'instancier les constantes d'un Enum avant emploi car ce ne sont pas des objets !*\n\n## Méthodes\n\nLes méthodes de la classe `Enum` sont les suivantes :\n\n+ `values()` : renvoie toutes les constantes de l'Enum sous forme de tableau\n+ `ordinal()` : renvoie l'index de la constante appelante dans la liste de constantes\n+ `valueOf(String)` : retourne la constante correspondante à la chaine de caractère si la constante du même nom existe dans l'Enum\n\n## Exercices\n\n*Coming soon...*\n",C="# Bibliothèques\n\n## Introduction\n\nEn Java comme dans bon nombre d'autres langages de programmation, il est possible d'exploiter du **code externe** a votre programme afin d'éviter de **recoder des fonctionnalitées qui existe déjà**.\n\nCela se fait via l'**importation de bibliothèques** qui contiennent des **classes** avec leurs attributs et leurs méthodes.\n\n## Importer des bibliothèques\n\nIl y a une syntaxe précise à respecter pour importer une bibliothèque dans un projet :\n\n`[nomDeLaBibliotheque].[nomDuPackage].[nomDeLaClasse];`\n\nLes imports se situe toujours au dessus du bloc classe qui souhaite les utiliser.\n\nAinsi, pour importer la classe `ArrayList` on écrit : `import java.util.ArrayList;`\n\nIci `java` fait référence à la bibliothèque Java standard. On recherche la classe `ArrayList` se trouvant dans le package `util`.\n\nGrâce à cet import on peut dorénavant, dans le cadre de la classe qui fait l'import, créer et manipuler des objets de type `Arraylist`. On peut également utiliser ses attributs et méthodes.\n\nVoici un exemple :\n\n```\n// on import la classe que l'on souhaite utiliser\nimport java.util.ArrayList;\n\npublic class Toto {\n  // un attribut de type ArrayList\n  // qui représente une liste de notes\n  private ArrayList<Note> notes;\n\n  public Toto() {\n    // une ArrayList est un objet\n    // donc on l'instancie avant emploi\n    // à la création de l'objet Toto\n    this.notes = new ArrayList<Note>();\n\n    // un exemple d'utilisation\n    // d'une méthode de la classe\n    // ArrayList, ici removeAll\n    this.notes.removeAll()\n  }\n}\n```\n\n*Remarque : on ne détaille pas le fonctionnement de la classe `ArrayList` ici. Cet exemple à pour but de montrer ce qu'il est possible grâce à un import*\n\nOn peut importer tout le contenu d'une bibliothèque ou d'un package en utilisant `*` :\n\n```\nimport java.util.*;\n```\n\nCet import permet de récupérer le contenu de toutes les classes contenu dans le package `util` de la bibliothèque `java`.\n\nVous pouvez également importer vos propres classes vers d'autres parties de votre programme si elle en ont besoin. Par exemple on import la classe à tester dans la feuille de tests unitaires.\n\n*Remarque : la plupart des IDE permettent l'importation automatique des bibliothèques nécessaires au fonctionnement de votre code. Vous aurez donc rarement besoin de vous en soucier.*\n\n*Remarque : Il existe d'autres outils permettant l'exploitation de code externe autre que l'import en brut dans le code mais nous n'en parlerons pas dans ce cours.*\n\n## Exercices\n\n*Coming soon...*\n",L="# Collection et Iterable\n\n## Introduction\n\nIl existe de nombreuses façon d'**organiser des données** autrement qu'avec des tableaux en Java.\n\nL'architecture des bibliothèques proposant des solutions est **très vaste** et nous allons la parcourir de manière succinte.\n\nToutes se basent sur `Collection` et `Iterable` qui sont des interfaces (pas besoin de savoir ce qu'est une interface pour le moment) donnant leurs propriétés aux classes qui nous intéresse dans ce cours.\n\nIl existe trois grandes familles d'iterable c'est à dire de **structure de données pouvant être parcourue** : Les `List`, Les `Queue` et Les `Set`.\n\nToutes ces classes sont ce qu'on appelle des `Collection` car elles regroupent un ensemble de données accessible en un point.\n\nAvant tout il faut savoir que les tableaux ainsi que les iterables peuvent être **parcouru via une boucle particulière** appelée le `forEach`.\n\n## forEach\n\nLe `forEach` en Java est une boucle très similaire au `for` et qui permet de **parcourir des structures de données de manière plus intuitive**.\n\nIl se construit de cette façon : `for([type_objet] [nom_objet] : [structure à parcourir])`\n\nLe paramètre de gauche représente un objet dans la structure à parcourir. C'est **l'objet courant dans la boucle**. Le nom de l'objet importe peu tout comme l'index dans un `for` classique.\n\nLe paramètre de droite est la variable qui représente la structure à parcourir. L'interêt majeur du `forEach` est que l'on a pas besoin de se soucier de la taille de structure à parcourir contrairement à un `for` classique.\n\nVoici un exemple d'utilisation :\n\n```\n// une variable représentation un livre\n// sous la forme d'un tableau d'objet\n// de type Page\nPage[] livre = new Page[10];\n\n// la boucle forEach parcourt\n// chaque page du livre\nfor (Page page : livre) {\n  // on écrit sur chaque page\n  // du livre\n  page.ecrire(\"Je suis une super page !\");\n}\n```\n\n*Remarque : on part du principe que la classe `Page` contient une méthode s'appelant `ecrire`. Son fonctionnement n'est pas le propos de l'exemple.*\n\nIci on parcourt le tableau de pages `livre`. Pour chaque page contenu dans `livre` on écrit dedans `Je suis une super page !`\n\n*Remarque : la boucle forEach permet de parcourir toutes les structures de données que nous allons voir dans ce cours.*\n\n## List\n\nUne `List` est une séquence d'objets qui peut être **organisée comme on le souhaite**.\n\nOn peut y **ajouter** et en **retirer** des éléments, **les doublons sont autorisé** ainsi que les **objets vide**.\n\nOn peut **récupérer** un élément grâce à son **index** tout comme on le ferait dans un tableau.\n\nLa différence majeure entre une liste et un tableau est que la liste est **dynamique** c'est à dire qu'elle adapte **automatiquement** sa **taille** en fonction des actions faite sur celle-ci (ajout et retrait d'éléments notamment).\n\nLorsqu'on instancie une liste on doit préciser le type d'objet qu'elle va contenir de cette façon :\n\n```\nList<Chien> chiens = new ArrayList<>();\n```\n\nLa liste `chiens` pourra donc stocker des objets de type `Chien`. On indique le type d'objet attendu dans la liste entre chevrons `<>`.\n\n`List` n'est pas un objet mais une interface on doit donc utiliser une implémentations de `List` pour pouvoir la manipuler.\n\nL'implémentation la plus courante de `List` est `ArrayList`.\n\nUne liste ne peut stocker que des objets, si on souhaite stocker des variables de types primitifs on utilisera les classes correspondantes (ex : `Integer` pour `int`, `Character` pour `char`, etc.).\n\nVoici un exemple :\n\n```\n// un tableau peut stocker\n// des variables de\n// types primitifs\nint[] notes;\n\n// son équivalent\n// sous forme de liste\nArrayList<Integer> notes;\n```\n\n*Remarque : ces objets fonctionnent de manière similaire aux types primitifs mais, tout comme les autres classes, possèdent des méthodes permettant des manipulations plus avancées (se referer à la documentation). Il ne faut cependant pas en abuser et remplacer tout vos types primitifs par des objets si ce n'est pas nécessaire !*\n\n### ArrayList\n\nL'ArrayList est l'une des implémentations de la liste la plus commune. En mémoire elle est équivalente à un **tableau dyamique**.\n\nCela implique qu'il est très **peu couteux d'accéder à un élément** dans la liste mais il est **plus compliqué d'ajouter ou de retirer des éléments** car ces deux actions ont des répercussions sur le tableau qui doit etre recréér afin d'avoir la bonne taille.\n\nVoici quelques méthodes de cette classe :\n\n+ `add(Object o)` : ajoute l'objet `o` à la liste si son type correspond\n+ `remove(Object o)` : enlève une occurence de l'objet `o` de la liste s'il s'y trouve au moins 1 fois\n+ `get(index i)` : récupère l'objet de la liste à l'index `i`\n+ `size()` : retourne la taille de la liste (nombre d'éléments dans la liste)\n+ `contains(Object o)` : indique si une occurence de l'objet `o` se trouve dans la liste ou non\n+ `isEmpty()` : indique si la liste est vide (si la taille de la liste est égale à 0)\n\n*Remarque : la méthode `get` ne marche pas si la liste contient un objet à l'index donné. Sinon la méthode fait planter le programme donc faite attention !*\n\n*Remarque : il existe d'autres méthodes dans la classe `ArrayList`, celles-ci sont les plus communéments utilisées.*\n\nVoici un petit exemple de manipulation d'une `ArrayList` :\n\n```\nPage sommaire = new Page(\"Ceci est un sommaire\");\nList<Page> livre = new ArrayList<>();\n\n// si le livre est vide\n// donc qu'il 0 page\nif (livre.isEmpty()) {\n  // on ajoute la page sommaire\n  // dans le livre\n  livre.add(sommaire);\n}\n```\n\n### Manipuler une liste avec Collections\n\nLa classe `Collections` permet de manipuler des listes et autres stuctures de données similaires (donc des collections), voici une liste non exhaustive de ses fonctionnalités :\n\n+ `sort(list)` : tri le contenu de la liste par **ordre croissant**\n+ `shuffle(list)` : mélange le contenu de la liste (change l'ordre des éléments de manière aléatoire)\n+ `max(collection)` : retourne la plus grande valeur de la collection\n+ `min(collection)` : retourne la plus petite valeur de la collection\n+ `addAll(collection, elements)` : permet d'ajouter `elements` à la collection, `elements` peut être un tableau ou bien les éléments listés un par un\n\n*Remarque : il existe beaucoup d'autres méthodes plus situationnelles dans la classe `Collections`.*\n\n*Remarque : la plupart des méthodes de `Collections` se basent sur la comparaison des objets contenus pour fonctionner. Cette comparaison marche très bien et automatiquement pour des variables de type primitif mais pas pour des types complexes.*\n\n### LinkedList\n\nLa `LinkedList` est une autre implémentation de la liste une peu moins commune. Elle représente en mémoire une **chaîne** ou une **file** de données. Chaque élément à un ordre dans la liste.\n\nPlus précisément, la `LinkedList` est une liste **doublement chaînée** c'est à dire que chaque élément stocké dans la liste est **relié à son précédent et à son suivant** ainsi il est très **peu couteux d'ajouter ou de retirer des éléments** mais il est **plus compliqué d'accéder à un élément** de la liste car on doit la parcourir depuis le départ pour arriver à la destination.\n\nVoici un exemple :\n\n```\nList<Personne> fileAttente = new LinkedList<>();\n```\n\nEn plus des méthodes que l'on retrouve dans les autres implémentations de `List` comme `ArrayList`, la `LinkedList` propose les fonctionnalitées suivantes :\n\n+ `addFirst(Object o)` : ajoute l'objet `o` au **début** de la liste\n+ `addLast(Object o)` : ajoute l'objet `o` à la **fin** de la liste\n+ `removeFirst()` : retire le **premier** élément de la liste\n+ `removeLast()` : retite le **dernier** élément de la liste\n+ `getFirst()` : retourne le **premier** élément de la liste\n+ `getLast()` : retourne le **dernier** élément de la liste\n\n*Remarque : il existe d'autres implémentations de List mais nous ne les verrons pas ici.*\n\n## Queue\n\nLa `Queue` est une **file de donnée**, on l'utilise pour stocker des éléments de **manière temporaire avant traitement**.\n\nElle n'offre aucune fonctionnalité particulière par rapport aux listes mais certaines de ces implémentations spécifiques peuvent être utile notamment la `PriorityQueue`.\n\nSes méthodes d'usages sont les suivantes :\n\n+ `push(Objet o)` : ajoute l'objet `o` au début de la file\n+ `pop()` : retire le premier élément de la file\n\nVoici un exemple :\n\n```\n// quelques personnes\n// pour notre exemple\nPersonne toto = new Personne();\nPersonne titi = new Personne();\n\n// une file d'attente\n// contenant des personnes\nQueue<Personne> fileAttente = new Queue<>();\n\n// on insère toto dans\n// la file d'attente\nfileAttente.push(toto);\n// puis on insère titi\nfileAttente.push(titi);\n// on retite la première\n// personne dans la file\n// à savoir toto\nfileAttente.pop();\n// à partir de cette ligne\n// il ne reste que titi\n// dans la file d'attente\n```\n\n### PriorityQueue\n\nLa `PriorityQueue` est une file de donnée dont l'ajout de donnée provoque un tri automatique. La PriorityQueue détecte un élément de comparaison entre les objets qui la composent et les trie. Autrement elle ne possède aucune fonctionnalité particulière supplémentaire.\n\n*Remarque : Il existe d'autres implémentations de Queue mais nous ne les verrons pas ici.*\n\n## Set\n\nLe `Set` est une structure de donnée similaire à la `List` mais il **n'autorise pas de doublon**.\n\nOn ne peut pas récupérer un élément précis dans un `Set`, seulement **ajouter**, **retirer** et **faire des vérifications**.\n\nUn `Set` peut dont être utile dans les cas où l'on souhaite stocker des informations en interdisant les doublons.\n\n*Remarque : les Set sont des structures particulières et rarement utile, à utiliser avec précaution.*\n\n## Exercices\n\n### Exercice 1 : Le Grand Hotel\n\nOn souhaite représenter l'ensemble des chambres d'un hotel de luxe ainsi que sa clientèle. L'hotel n'a besoin que de connaitre le nom de ses clients.\nL'hotel possède une infinité d'étages, chaque étage possède au maximum 2 chambres. Une chambre possède un numéro de chambre unique.\nUne chambre peut accueillir jusqu'a 3 personnes, elle peut également être vide.\n\nOn doit pouvoir générer pour chaque chambre le message suivant : `Chambre n°[numero_chambre] - Etage n°[numero_etage] - Clients ([noms_clients])`\n`noms_clients` se construit de cette façon : `Toto Titi Tutu` si la chambre contient 3 clients se nommant ainsi. Si la chambre est vide `noms_clients` = `vide`\n\n1. Identifiez les **objets** à implémenter et créez en conséquence les **classes** nécessaires. Identifiez ensuite les **attributs** de ces objets et implémentez les dans vos classes. Vous créerez également les **constructeurs**, **getters**, **setters** et autres méthodes nécessaires à la manipulation de vos objets.\n\n2. Développez un **programme principal** ou l'appel de la méthode `toString()` de la classe `Hotel` permet de produire ce résultat :\n\n`Chambre n°1 - Etage n°1 - Clients (Toto)`\n\n`Chambre n°2 - Etage n°1 - Clients (vide)`\n\n`Chambre n°3 - Etage n°2 - Clients (Titi Tata Tutu)`\n",E="# Interface Utilisateur\n\n## Introduction\n\nDans tous types de programme et en Java également, il est toujours plus agréable pour un utilisateur de manipuler un programme via une **interface utilisateur**. Le but d'une interface utilisateur est de rendre le programme **plus intuitif pour un humain** en lui indiquant des informations de diverses manières, notamment **visuelles**.\n\nDans ce cours nous allons voir comment mettre en place les bases d'une interface utilisateur rudimentaire via la **console Java**. L'interface utilisateur sera donc **uniquement textuelle**, nous ne parlerons pas d'interface plus graphique dans ce cours car le Java n'est pas un langage bien équipé pour cela car ce n'est pas son but.\n\n## Scanner\n\nUn `Scanner` en Java est un objet permettant de **récupérer des informations provenant d'un flux**. En Java il existe différents types de flux :\n\n- le flux de **sortie** : la console\n- le flux d'**entrée** : la saisie clavier\n- le flux d'**erreur** : réservé aux messages d'erreurs du programme\n- les fluxs **externes** : un fichier, une requête API ou HTTP, etc.\n\nOn peut positionner un `Scanner` sur l'un de ces flux pour en **récupérer le contenu** et l'interpréter par la suite. Ici c'est uniquement le **flux d'entrée** qui va nous intéresser.\n\nUn objet de type `Scanner` s'instancie de cette manière :\n\n```\nScanner sc = new Scanner(System.in);\n```\n\n_Remarque : pour utiliser la classe `Scanner`, il est nécessaire de l'importer dans votre projet._\n\nIci on vient de créer un objet de type `Scanner` s'appelant `sc` sur le flux d'entrée indiqué par le mot clé `System.in`.\n\nOn peut ensuite récupérer des informations depuis ce `Scanner`. Depuis le flux d'entrée les informations que l'on souhaite recueillir sont les **saisies clavier** de l'utilisateur c'est à dire **ce qu'il écrit dans la console**.\n\n### Saisie et Récuperation\n\nUne saisie clavier se caractérise par **la chaîne de caractère rentrée par l'utilisateur** qui peut ou pas contenir des espaces. La **validation** de cette saisie clavier par l'utilisateur se fait pas l'utilisation de `Enter` (la touche Entrée) du clavier qui appelle la méthode de récupération.\n\n_Remarque : la récupération se fait de manière différente pour les flux externes depuis des fichiers par exemple. Dans ce cas la récupération n'implique bien sur par la touche Entrée._\n\nLa récupération de la saisie clavier utilisateur possède des règles qui varie selon la méthode de récupération. De manière générale un `Scanner` possède un **separator** qui indique où **découper les informations** dans la saisie clavier. De base le séparator est l'**espace** ou le **white space**.\n\nDonnons un exemple pour comprendre ce fonctionnement :\n\nSi j'écris dans la console : `HelloWorld!` puis que j'appuie sur `Enter`...\n\nDans sa configuration de base, le `Scanner` récupère cette chaîne : `HelloWorld!`\n\nSi j'écris dans la console : `Hello World !` puis que j'appuie sur `Enter`...\n\nDans sa configuration de base, le `Scanner` récupère cette chaîne : `Hello`\n\nEn effet la chaîne `Hello World !` contient des espaces et correspond donc à 3 saisies claviers distinctes :\n\n`Hello`, `World` et enfin `!`\n\n### Méthodes\n\nVoici différentes méthodes pour récupérer des informations via un `Scanner` :\n\n- `next()` : permet de récupérer **une chaîne de caractères** (`String`). Cette méthode est sensible au **separator** du scanner.\n- `nextLine()` : permet de récupérer **la saisie entière** sans ce soucier du separator et sans faire de distinction sur **les types de données récupérés**.\n- `hasNext()` : retourne `true` ou `false` en fonction de si le scanner a encore du contenu à lire dans sa source.\n- `nextInt()` : permet de récupérer une valeur entière. Attention ! Plante si la saisie clavier ne contient pas de nombre.\n\n_Remarque : la méthode `hasNext` est principalement utilisée dans le cadre de la récupération de donnée dans un fichier externe car elle va permettre de lire tout le contenu du fichier._\n\n_Remarque : Tout comme pour les `int`, il existe des méthodes pour récupérer tous les autres types primitifs (ex: `nextFloat`, `nextBoolean`, etc.)_\n\n## Construire une interface utilisateur\n\nUne des règles d'or de la programmation est de **ne jamais faire confiance à l'utilisateur**. Il faut coder son interface en partant du principe que l'utilisateur **ne vas pas nous donner l'information que l'on souhaiterait**.\n\nAinsi il existe de nombreuses astuces pour que notre programme soit **paré à la majeure partie des éventualités**. Le but est d'éviter à tout prix que le programme plante.\n\nLes deux notions importantes d'une interface utilisateur sont que :\n\n- on **sait à l'avance** ce que l'on attend de la part de l'utilisateur\n- on souhaite recevoir la bonne information et ainsi on devra **recommencer jusqu'a l'obtenir**\n\nEn sachant ça, deux boucles de contrôles nous seront très utiles et fonctionnent de paires :\n\nLe `while` nous permet via l'utilisation d'une condition booléenne de **bloquer l'utilisateur** jusqu'a ce qu'il est indiqué l'information souhaitée (toujours pour éviter les bugs, pas pour être méchant).\n\nLe `switch` nous permet d'indiquer le **comportement de notre application** en fonction du résultat de la saisie utilisateur. Il permet aussi de gérer facilement le cas où **l'utilisateur s'est trompé**.\n\nVoici une petite mise en situation :\n\n```\nScanner sc = new Scanner(System.in);\n// permet de stocker l'information\n// le choix de l'utilisateur est il bon ?\nBoolean isValid = false;\n\n// tant que la saisie\n// utilisateur n'est pas\n// satisfaisante\nwhile (!isValid){\n    System.out.print(\"Tapez 1 pour les mails, Tapez 2 pour les SMS >\");\n    // on récupère une chaîne de caractère\n    // et pas un int car on veut éviter de\n    // faire planter le programme.\n    // on stocke la saisie clavier\n    // dans une variable String\n    String choix = sc.next();\n\n    // en fonction de ce qu'a\n    // écrit l'utilisateur...\n  switch(choix) {\n    // si l'utilisateur\n    // a écrit '1'\n    case \"1\" :\n      System.out.println(\"MAILS\");\n      // la saisie de l'utilisateur\n      //correspond à un cas valide\n      isValid = true;\n      break;\n\n    // si l'utilisateur\n    // a écrit '2'\n    case \"2\" :\n      System.out.println(\"SMS\");\n      // cas valide également\n      isValid = true;\n      break;\n\n    // si l'utilisateur\n    // a écrit autre chose\n    // que '1' ou '2'\n    default :\n      System.out.println(\"Saisie invalide, rééssayez\");\n      // isValid reste a false car la saisie n'est pas valide\n      // on repart au début du while\n      // et on redemande une saisie\n      break;\n  }\n}\n// si on arrive ici\n// c'est qu'on a quitté le while\n// et que l'utilisateur\n// a saisie correctement\nSystem.out.println(\"Fin du programme\");\n```\n\nUn exemple d'utilisation de l'interface du dessus :\n\n`Tapez 1 pour les mails, Tapez 2 pour les SMS > salade`\n\n`Saisie invalide`\n\n`Tapez 1 pour les mails, Tapez 2 pour les SMS > 2`\n\n`SMS`\n\n`Fin du programme`\n\n_Remarque : le code au dessus est seulement un exemple qui peut et doit être adapté en fonction de la situation._\n\n## Fichier externe\n\nDans cette partie nous allons voir comment utiliser le `Scanner` pour **lire** des données **textuelles** dans un fichier externe `txt`.\n\nTout d'abord il faut récupérer le fichier texte grâce à un objet de type `File`.\n\nOn doit instancier un objet de type `File` dans notre programme avec en paramètre d'entrée le **chemin** (relatif ou absolu) du fichier.\n\n_Remarque : pour les chemins relatifs, la racine de recherche est à la racine de votre projet c'est à dire au même niveau que le dossier `src`._\n\nVoici un exemple :\n\n```\n// on va récupérer\n// le fichier toto.txt\n// à la racine du projet\nFile file = new File(\"toto.txt\");\n\nScanner sc = new Scanner(file);\n\n// tant que le scanner n'est pas arrivé\n// à la fin du fichier\nwhile(sc.hasNext()){\n    // on affiche le fichier ligne par ligne\n    System.out.println(sc.nextLine());\n}\n```\n\n_Remarque : bien qu'on ne puisse pas écrire dans un fichier avec un Scanner il y a bien d'autres façons de traiter un fichier que dans cet exemple._\n\n## Exercices\n\n_Coming soon..._\n",A="# Valeurs Aléatoires\n\n## Introduction\n\nDans un programme informatique, on peut très souvent être ammené à devoir utiliser des **valeurs aléatoires** ou plutôt **pseudo-aléatoires**.\n\nIl y'a plusieurs façons de générer des valeurs aléatoires en Java. Nous allons en voir deux dans ce cours.\n\n## Random\n\nLa classe `Random` permet de générer des valeurs aléatoires de **différents types primitifs**.\n\nOn doit cependant indiquer la **borne maximale** dans le cas d'une génération de nombre c'est à dire la plus grande valeur possible que va générer l'objet `Random`.\n\nVoici un exemple pour une génération de nombre entier :\n\n```\n// création de l'objet\nRandom rand = new Random();\n\n// on génère un nombre\n// pseudo aléatoire\n// que l'on stocke dans i\nint i = rand.nextInt(100);\n```\n\n_Remarque : pour pouvoir utilise la classe `Random` il faut d'abord l'importer dans votre programme._\n\nDans cet exemple, la valeur de `i` sera comprise entre 0 et 99. A chaque éxécution du programme sa valeur sera regénerée.\n\nUn autre exemple qui simule un pile ou face (une situation avec une probabilité 50/50) :\n\n```\nRandom rand = new Random();\n\n// booléen aléatoire\n// true ou false\nboolean coinFlip = rand.nextBoolean();\n\n// si coinFlip\n// vaut true\nif (coinFlip) {\n  System.out.println(\"PILE\");\n} else {\n  System.out.println(\"FACE\");\n}\n```\n\n_Remarque : il est tout a fait possible d'obtenir la même valeur plusieurs fois d'affilée. Tout est une question de probabilité._\n\n## Math.random\n\nLa méthode `random()` de la classe `Math` permet de générer une valeur aléatoire **entre 0 et 1**. Le résultat est donc un nombre à virgule\n\n_Remarque : l'utilisation de la classe `Math` et de ses méthodes ne requiert pas d'import supplémentaire dans le programme car elle est comprise dans les imports de base d'un projet Java._\n\nVoici un exemple :\n\n```\nfloat rand = Math.random();\n```\n\nUn valeur possible pour le résultat stocké dans `rand` pourrait être ici : `0.5568515217910215`\n\nSi l'on souhaitait reproduire l'exemple proposé pour la classe `Random` pour une génération de nombre entier aléatoire il faudrait faire ceci :\n\n```\nint rand = (int) (Math.random() * 100);\n```\n\n_Remarque : `(int)` est ce qu'on appelle un cast qui permet de changer le type d'une valeur. Ici le cast permet de tronquer le résultat de `random` qui renvoie un nombre à virgule (`float`) en nombre entier (`int`) pour pouvoir le stocker dans `rand` de type `int` (ex: 14,1872 devient 14)_\n\n_Remarque : les cast sont a manipuler avec précautions et ne fontionnent généralement qu'entre types primitifs similaires._\n\n## Exercices\n\n### Exercice 1 : Envoie 'AMOUR' au 8 12 12\n\nOn souhaite créer une ~~arnaque~~ fonctionnalité permettant à un utilisateur d'entrer son nom ainsi que celui de son grand amour pour que l'application lui indique son taux de compatibilité avec celui ou celle qu'il ou elle aime. L'application peut délivrer différents résultats en fonction du taux de compatibilité :\n\n- Pour 0% : `[user1] et [user2] = bagarre`\n- Entre 1% et 25% : `[user1] et [user2] = osef`\n- Entre 26% et 50% : `[user1] et [user2] = potes à la compote`\n- Entre 51% et 75% : `[user1] et [user2] = BFF`\n- Entre 76% et 99% : `[user1] et [user2] = amour`\n- Pour 100% : `[user1] et [user2] = muy caliente`\n\nDéveloppez une interface utilisateur permettant de récupérer le nom des deux utilisateurs et de produire un message aléatoire (l'amour c'est plus ce que c'était...)\n",S="# Dictionnaires\n\n## Introduction\n\nLes dictionnaires ou `Map` sont des structures de données complexes qui permettent **d'associer une clé à une valeur**.\n**Il ne peut pas y avoir plusieurs fois la même clé** cependant.\n\nCette structure fonctionne de manière identique à un vrai dictionnaire pour faire une comparaison pratique. On associe à la lettre 'A' (qui est la clé), tous les mots commençant par cette lettre (les valeurs)\n\nNous allons voir dans ce cours l'implémentation la plus courante de `Map` en Java : `HashMap`.\n\n## HashMap\n\nUne `HashMap` est un dictionnaire qui **hache les données** qu'il contient c'est à dire qu'il **crypte les données** pour les rendre **plus courtes en mémoire** et accélerer la recherche dans le dictionnaire.\n\nL'**ordre de parution** des valeurs du dictionnaire n'est pas garanti lors d'un parcours c'est à dire qu'elles n'apparaitront **pas forcément dans l'ordre dans lequel elles ont été placé à la base**.\n\nOn peut parcourir **la liste des clés** d'un dictionnaire, ou bien **la liste des valeurs** ou bien encore une **liste des associations clé-valeur**.\n\n_Remarque : un dictionnaire ne peut stocker que des objets que ce soit les clés ou les valeurs, ainsi si l'on souhaite stocker des valeurs de types primitifs on utilisera les classes correspondantes tout comme pour les listes (ex : Integer pour int, Boolean pour boolean, Character pour char, etc.)_\n\n### Méthodes\n\nVoici une liste de quelques méthodes utiles de la classe `HashMap` :\n\n- `put(key, value)` : ajoute une association `key` -> `value` dans le dictionnaire, si une valeur pour la clé `key` existe déja dans le dictionnaire alors elle sera écrasée par la nouvelle `value`\n- `get(key)` : retourne la valeur associé à la clé `key` si cette clé existe dans le dictionnaire\n- `remove(key)` : supprime la clé `key` ainsi que sa valeur du dictionnaire\n- `size()` : retourne le nombre d'association clé-valeur dans le dictionnaire (ou plus simplement le nombre de clés)\n- `clear()` : supprime complétement tout le contenu du dictionnaire\n\nPour parcourir le dictionnaire on utilise :\n\n- `keySet()` : permet de parcourir la liste de clé du dictionnaire\n- `values()` : permet de parcourir la liste de valeurs du dictionnaire\n\nVoici un exemple d'utilisation :\n\n```\n// on créé un dictionnaire qui\n// associe un mot a un caractère\nMap<Character, String> dico = new HashMap<>();\n\n// on ajoute la clé 'a' associée\n// au mot 'abricot' qui sera sa valeur\ndico.put('a', \"abricot\");\n// on ajoute la clé 'c' associée\n// au mot 'creascio' qui sera sa valeur\ndico.put('c', \"creascio\");\n\n// on parcourt toutes les clés\n// du dictionnaire\nfor (Character c : dico.keySet()){\n    // pour chaque clé dans le dictionnaire\n    // on affiche cette clé et la valeur associée\n    System.out.println(\"Key :\" + c + \" value : \" + dico.get(c));\n}\n```\n\nDans l'exemple ci-dessus notre dictionnaire n'est pas très pratique car il ne peut associer **qu'un seul mot à une lettre**.\n\nPour pouvoir répresenter un dictionnaire plus fidèle on devrait faire en sorte que la valeur associée à une lettre soit **une liste de mots** comme dans l'exemple ci-dessous :\n\n```\n// une liste de mots\n// commençant par\n// la lettre 'c'\nList<String> motsQuiCommenceParC = new ArrayList<>() {{\n    // on ajoute directement quelques mots qui commencent\n    // par la lettre c\n    add(\"clubby\");\n    add(\"clubbo\");\n}};\n\n// le dictionnaire\nMap<Character, ArrayList<String>> dico = new HashMap<>();\n\n// on créer une association\n// clé valeur entre la lettre\n// 'c' et notre liste de mots\n// commençant par 'c' dans le dico\ndico.put('c', motsQuiCommenceParC);\n```\n\n## Exercices\n\n_Coming soon..._\n",_="# Mode Debug\n\n## Introduction\n\nLorsque notre programme plante ou ne produit pas le résultat attendu sans que l'on puisse facilement trouver la cause du problème, une bonne pratique est de lancer le programme en **mode Debug**.\n\nCe mode possède plusieurs fonctionnalités permettant de faire progresser le programme **pas à pas** c'est à dire **ligne par ligne**.\n\nNous allons voir dans ce cours comment se servir du mode Debug sous Eclipse.\n\n## Setup\n\nAvant de lancer le programme on doit déterminer des potentiels **points d'arrêts** dans notre code où le compilateur va s'arrêter et laisser la main à l'utilisateur pour poursuivre comme il le souhaite l'éxécution du programme.\n\nGénéralement on place des points d'arrêts avant **les instructions qui pourraient poser problème**. Si vous n'avez aucune idée d'où provient le problème vous pouvez placer le point d'arrêt **en haut du main**.\n\n_Remarque : il existe d'autres points que les Breakpoints (points d'arrêts) mais leur usage spécifique ne sera pas couvert dans ce cours._\n\nIl faut ensuite lancer le programme en mode Debug ce qui lance une configuration particulière.\n\nSur Eclipse, pour lancer le programme en mode débug on peut faire ceci :\n\n- `Clic droit > Debug As > Java Application`\n- `Icone d'insecte dans la barre d'actions > Debug As > Java Application`\n\nUne fois le programme lancé de cette manière le compilateur ammène le programme **jusqu'au premier point d'arrêt** rencontré dans l'exécution.\n\n_Remarque : si le programme nécessite des entrées utilisateurs avant ou apres un point d'arrêt il faudra les remplir comme normalement dans la console puis appuyer sur `Enter` pour continuer le debug._\n\n## Mécaniques de debug\n\nL'utilisateur à ensuite à sa disposition différentes fonctionnalités :\n\n- `Step Into (F5)` : redirige vers le **code appelant** (la méthode généralement)\n- `Step Over (F6)` : passe à la **ligne suivante** sans rentrer dans le code\n- `Step Return (F7)` : retourne dans le **bloc de code précédent**\n\n_Remarque : La fonctionnalité la plus utile reste le `Step Into` pour faire un parcours en profondeur de l'éxécution de votre programme._\n\nEn fonction de votre IDE vous pouvez également avoir une **vue Debug** qui permet de voir différentes informations comme **l'état de la pile d'execution** ou bien encore **la valeur de chaque variable de votre programme** au fil de l'éxécution.\n\n_Remarque : en parallèle de l'utilisation du mode Debug, une pratique plus simple mais limité reviens à placer des `print` d'informations dans votre programme pour suivre comment l'éxécution se déroule et comment évolue vos variables._\n\n## Exercices\n\n_Coming soon..._\n",I="# Tests Unitaires\n\n## Introduction\n\nLa phase de test est une partie non négligeable de tout projet informatique. Un développeur doit savoir utiliser les tests unitaires durant le développement d'un programme pour **s'assurer du fonctionnement de ces mécaniques**.\n\nEn Java les tests unitaires permettent notamment de s'assurer du **bon fonctionnement des classes d'un programme** en testant le fonctionnement des **méthodes** de ses classes dans **différentes circonstances**. Le but étant de soumettre le programme à **toutes les éventualités possibles**.\n\n## Setup\n\nPour mettre en place des tests unitaires en Java, on utilise la bibliothèque `JUnit`. On peut rédiger un test unitaire dans un fichier prévu à cet effet appelé un `JUnit Test Case` (une fiche de test).\n\nLa création d'un Test Case entraîne automatiquement l'ajout de la bibliothèque `JUnit` dans le projet Java.\n\nGénéralement on place les Test Case dans **un package de test à part**. On peut aussi les créer dans **un dossier de test** en dehors du dossier `src`.\n\nPour créer un Test Case (sous Eclipse) : `Clic droit > New > JUnit Test Case`\n\n## Utilisation\n\nPour chaque classe que l'on souhaite tester, on créer un Test Case qui va contenir les tests nécessaires à la **couverture** des méthodes de la classe. La **couverture** d'une classe représente **tous les cas de figure possibles** lors de l'appel des méthodes de cette classe.\n\nUn Test Case est alors une **classe** composée de tests qui sont eux-même des **méthodes**.\n\n_Remarque : un Test Case peut donc, tout comme n'importe quelle classe avoir des attributs mais il n'est pas nécessaire d'avoir un constructeur pour celui-ci. Il faut voir le fonctionnement du Test Case comme assez proche d'un `main` qui peut avoir éventuellement des attributs `static`._\n\nPour fonctionner un Test Case se base sur des **annotations** que va interpréter le compilateur ce qui va lui permettre de comprendre que la méthode en question est un test. L'annotation en question est `@Test` (les annotations sont toujours précédées d'un `@` comme dans `@deprecated` ou `@Override`).\n\n_Remarque : il existe d'autres annotations pour les tests que nous verrons plus loin dans ce cours._\n\nLe principe de base d'un test et de comparer un **résultat attendu** au **résultat de la méthode** à tester.\n\nLors de l'exécution, chaque test sera lancé et indiquera s'il est **validé ou non**. S'il n'est pas validé le compilateur indiquera qu'elle a été **la valeur obtenue au lieu de celle attendue**.\n\nVoici un exemple, on va ici créer une fausse classe à tester suivi du Test Case correspondant :\n\nLa classe à tester...\n\n```\n// une classe exemple\npublic class Toto {\n\n  private int note;\n\n  public Toto(){\n    this.note = 0;\n  }\n\n  public int addition(int nombre1, int nombre2){\n    return nombre1 + nombre2;\n  }\n}\n```\n\net le Test Case...\n\n```\n// par convention on nomme la classe de test \"[nom_classe_a_tester]Test\"\npublic class TotoTest {\n\n    // l'annotation indique que la méthode\n    // en dessous est un test\n    // ce test va permettre de couvrir\n    // la méthode addition de la classe Toto\n    @Test\n    public void additionTest(){\n\n    }\n}\n```\n\nLors de l'éxécution de `TotoTest`, la méthode de test `additionTest` va être lancée, pour le moment elle ne fait rien mais nous allons voir maintenant comment construire un test efficace.\n\n## Construction\n\nUn test unitaire est divisé en trois parties :\n\n- `Arrange`, **l'initialisation ou l'arrangement** : la section du test où l'on **instancie les objets** donc on aura besoin pour le test (cette phase n'est pas obligatoire)\n- `Act`, **l'action** : la section qui contient les **appels de méthodes** ou les **modifications de valeurs éventuelles** nécessaire à la mise en situation du test (cette phase n'est pas obligatoire)\n- `Assert`, **l'assertion** : la section qui contient la **vérification que l'on souhaite faire pour valider** le fonctionnement de la méthode.\n\n_Remarque : nous mettrons en lumière cette organisation un peu plus tard avec un exemple._\n\n## Les assertions\n\nLorsqu'on veut tester des méthodes, on utilise les **assertions** pour **comparer le résultat d'un morceau de code à un résultat attendu**. Il existe de nombreuses assertions pour tester différents cas de figure.\n\nToutes sont des méthodes qui nécessite le résultat attendu et/ ou la variable, l'objet, la méthode a tester.\n\nVoici quelques exemples d'assertions :\n\n- `assertEquals()` : validé si les deux valeurs sont **égales**\n- `assertNotEquals()` : validé si les deux valeurs ne **sont pas égales**\n- `assertTrue()` : validé si la condition booléenne testée est **vraie**\n- `assertFalse()` : validé si la condition booléenne testée est **fausse**\n\n_Remarque : ces assertions sont les plus simples et les plus communes, il en existe bien d'autres._\n\nVoici un exemple d'usage des assertions avec la même classe à tester `Toto` :\n\n```\n// rappel de la classe à tester\npublic class Toto {\n\n  private int note;\n\n  public Toto(){\n    this.note = 0;\n  }\n\n  public int addition(int nombre1, int nombre2){\n    return nombre1 + nombre2;\n  }\n}\n```\n\nLe Test Case :\n\n```\npublic class TotoTest {\n\n  // on souhaite tester que\n  // l'objet Toto soit créé\n  // correctement par le\n  // constructeur\n  @Test\n  public void totoTest() {\n    // on appelle le\n    // constructeur qui\n    // initialise la valeur\n    // de la note\n    Toto toto = new Toto();\n\n    // deux façons de vérifier\n    // que la note de l'objet toto\n    // vaut bien 0\n    assertEquals(0, toto.note);\n    assertTrue(toto.note == 0);\n  }\n}\n```\n\nVoici un deuxième exemple un peu plus complet\n\n```\npublic class TotoTest {\n\n    @Test\n    public void createTotoTest(){\n      // Arrange\n      // on instancie l'objet\n      // toto.note = 0\n      Toto toto = new Toto();\n\n      // Act\n      // on modifie une valeur\n      // toto.note = 12\n      toto.setNote(12);\n\n      // Assert\n      // 12 est bien\n      // différent de 0,\n      // le test valide\n      assertNotEquals(0, toto.getNote());\n    }\n\n    @Test\n    public void additionTest(){\n        // Assert\n        assertEquals(13, addition(6, 7));\n    }\n}\n```\n\n_Remarque : dans la pratique, on teste rarement le bon fonctionnement du constructeur ou bien encore des getters et des setters qui sont considérés comme acquis. On teste plutôt les méthodes propres aux programmes, qui contiennent de l'algorithmie._\n\n_Remarque : il n'est pas vraiment possible de tester les méthodes impliquant de l'interface utilisateur et donc des attentes de saisie. De même pour les méthodes impliquant des valeurs aléatoires. Dans les deux cas on ne peut pas décider d'un résultat attendu pour faire une comparaison._\n\n## Les annotations\n\nIl existe d'autres annotations qui peuvent être utiles lors de l'implémentation de tests unitaires. Certains bloc de code peuvent être éxecuté **à des moments précis** durant l'éxecution du Test Case.\n\nVoici une liste d'annotations utiles et courantes :\n\n- `@BeforeAll` : le bloc de code est exécuté **une fois** au début de l'exécution du Test Case avant tous les autres tests\n- `@BeforeEach` : le bloc de code est exécuté **avant chaque** test\n- `@AfterAll` : le bloc de code est exécuté à la toute de l'éxécution fin après tout les tests.\n- `@AfterEach` : le bloc de code est exécuté **après chaque** test\n\nCes annotations viennent remplacer l'annotation de base `@Test` et indique un fonctionnement différent au compilateur.\n\nVoici un exemple :\n\n```\npublic class TotoTest(){\n\n    private Toto toto;\n\n    @BeforeAll\n    public static void init(){\n      // instancie l'objet toto avant\n      // qu'il soit utilisé ailleurs\n      // dans d'autres tests\n      toto = new Toto();\n    }\n\n    @BeforeEach\n    public void reset(){\n      // remet la note de toto à 0\n      // comme lors de sa création\n      // pour éviter les confusions\n      // entre plusieurs tests\n      toto.setNote(0);\n    }\n\n    @Test\n    public void test1(){\n      assertEquals(0, toto.getNote());\n      // avant de finir le test on modifie la note de toto\n      toto.setNote(12);\n    }\n\n    public void test2(){\n      // le test valide, même si\n      // on a changé la note de Toto à 12\n      // dans le test précédent,\n      // la méthode reset a été appelée\n      // entre temps avant test2 et\n      // ainsi la note de toto\n      // a été remise à 0\n      assertEquals(0, toto.getNote());\n\n      // on modifie la note de toto\n      // pour qu'elle vale 1+5\n      toto.setNote(addition(1, 5));\n      // 6 est bien différent de 0\n      // test valide\n      assertFalse(0, toto.getNote());\n    }\n}\n```\n\n_Remarque : l'exemple ci-dessus essaye de montrer la meilleure pratique de ces annotations, `BeforeAll` est très utile pour initialiser des éléments utiles à plusieurs tests comme des objets. `BeforeEach` (ou `AfterEach`) permet de remettre des éléments dans les mêmes conditions qu'avant un test, comme une réinitialisation._\n\n## Test paramétré\n\nGrâce aux annotations, il est possible de créer des tests paramétrés qui permettent de soumettre **plusieurs valeurs au même test** en une seule fois. Le test va fonctionner alors similairement à une boucle `forEach` qui va éxécuter le **même code pour chaque valeur** donnée en paramètre.\n\nPour cela on utilise l'annotation `@ParameterizedTest` à la place de `@Test`.\n\nIl existe plusieurs façons de fournir un ensemble de valeurs à tester au test paramétré :\n\n- Pour tester **une valeur à la fois**, on utilise `@ValueSource` suivi d'un **tableau contenant les valeurs**\n- Pour tester **une famille de valeur d'un coup**, on utilise `@CsvSource` suivi d'**un tableau contenant les familles** de valeurs (couples, triplets, etc.)\n\n_Remarque : pour faire une comparaison avec une méthode traditionnelle, `@ValueSource` indique que la méthode nécessite un seul paramètre d'entrée pour fonctionner alors que `@CsvSource` indique qu'il en faut plusieurs._\n\nVoici un exemple :\n\nOn part du principe qu'on a codé une méthode `multiplication(nombre1, nombre2)` qui permet de multiplier `nombre1` par `nombre2` et que l'on souhaite la tester sur plusieurs valeurs.\n\n```\npublic class CalculTest {\n\n  // un test paramétré avec\n  // ValueSource qui indique qu'on\n  // ne teste qu'une valeur en\n  // entrée à la fois.\n  // on va donc ici faire le test\n  // pour chaque valeur dans ints\n  // donc '1', puis '2', etc.\n  @ParameterizedTest\n  @ValueSource(ints = { 1, 2, 3, 4 })\n  // on passe en paramètre de\n  // la méthode un seul int à la fois\n  public void multiplicationTest1(int arg){\n\n    // on multiplie la valeur par 0\n    // et on stocke dans result\n    int result = multiplication(0, arg);\n\n    // on s'assure que result\n    // contienne bien 0\n    assertEquals(0, result);\n  }\n}\n```\n\nIci le test revient à vérifier que pour **n'importe quelle valeur de `ints`**, si on la multiplie par 0, le résultat de cette multiplication vaut bien 0.\n\nVous n'êtes pas sans savoir que 1x0 vaut 0, tout comme 2x0, etc. Le test valide pour toutes les valeurs.\n\n_Remarque : pour qu'un test paramétré valide totalement il faut que toute les valeurs en entrée soient validées par le test._\n\nVoyons maintenant un test paramétré similaire sur la méthode `multiplication` mais avec des familles de valeurs en entrée. Chaque famille est composée des deux nombres à multiplier ainsi que du résultat attendu de cette multiplication.\n\n```\npublic class CalculTest {\n\n  // un test paramétré avec\n  // CsvSource qui indique qu'on\n  // teste une famille entière\n  // de valeurs (entre crochets)\n  // à la fois.\n  @ParameterizedTest\n  @CsvSource({ \"1,1,1\", \"2,2,4\", \"3,4,12\" })\n  // on passe en paramètre de\n  // la méthode les trois\n  // membres de la famille dans l'ordre\n  public void multiplicationTest2(int firstNumber, int secondNumber, int expectedResult) {\n\n    // on multiplie le premier par le deuxième\n    // et on stocke dans result\n    int result = multiplication(firstNumber, secondNumber);\n\n    // on s'assure que le résultat\n    // de la multiplication donc result\n    // est égal au résultat attendu\n    // donnée par la famille à tester\n    assertEquals(expectedResult, result);\n  }\n}\n```\n\nPour donner un exemple de comment se déroule `multiplicationTest2`, pour la famille de valeurs `\"3, 4, 12\"`, on souhaite s'assurer que `3 x 4 = 12` (ce qui est le cas je vous assure).\n\n## Exercices\n\n_Coming soon..._\n",k="# Gestion des Exceptions\n\n## Introduction\n\nLes exceptions font partie intégrante du développement d'un programme, sauf si vous êtes très doué.\n\nElles indiquent **le type et la provenance d'une erreur** durant l'exécution du programme. Heureusement on peut se prévenir de ces erreurs et les gérer correctement pour ne pas que le programme **plante**.\n\n## Les Exceptions\n\nLes `Exceptions` sont des classes très simples associée à un type d'erreur, à une cause d'un problème est sera levée lorsque les conditions seront remplies pour. Les exceptions existantes ont des noms évocants l'erreur qu'elle indique.\n\nCes exceptions stockent en attribut un **message** ou bien une **trace** qui sera inscrite dans le **flux d'erreur** de la console lorsque l'exception sera levée (lorsqu'elle sera provoquée).\n\nToutes exceptions possèdent les méthodes suivantes :\n\n- `getMessage()` : retourne le **message** correspondant à l'erreur\n- `printStackTrace()` : affiche l'exception ainsi que **l'état de la pile d'exécution** au moment de son appel\n\nPour gérer les exceptions dans notre programme on **lève** nous même une exception (on provoque son appel) dans du code qui pourrait remplir **les conditions de levée de celle-ci**. Il faut ensuite la **propager** en dehors du code émetteur vers le code capable de l'**attraper** pour pouvoir la traiter correctement, toujours pour éviter que le programme plante.\n\nToutes ces actions sur les exceptions sont rendues possibles par différents outils que nous allons voir maintenant.\n\n### Lever une exception : throw\n\nOn peut lever une exception dans le bloc de code d'une méthode en utilisant le mot clé `throw`.\n\nLorsque le contenu du code d'une méthode **risque de lever une exception**, on doit l'indiquer dans son prototype grâce au mot clé `throws`.\n\nOn construit donc la méthode de cette façon :\n\n```\n// la méthode est susceptible de faire planter\n// le programme dans des conditions spécifiques\n// elle lèvera une exception sur le calcul arithmétique\n// de la division d'où l'erreur ArithmeticException\npublic float division(int diviseur, int dividende) throws ArithmeticException {\n\n    // le cas d'utilisation de la méthode\n    // division posant problème est dans\n    // le cas d'une division par 0\n    // ce qui est impossible\n    if (diviseur == 0){\n        // on créer un objet de type ArithmeticException qui va levé une\n        // exception avec le message passé en paramètre\n        throw new ArithmeticException(\"On ne peut pas diviser par 0 !\");\n    }\n\n    // sinon la méthode fonctionne correctement\n    // dans tous les autres cas\n    return dividende / diviseur;\n}\n```\n\n_Remarque : l'exemple ci-dessus veut montrer la meilleure pratique pour l'usage des `throw`. Il est toujours préférable d'isoler le ou les cas d'utilisation de la méthode dans des conditions `if` qui vont levé une exception. Ensuite on code en dessous le fonctionnement normal de la méthode. C'est la solution la plus efficace pour traiter les erreurs ainsi._\n\nAinsi on peut **prévenir les risques** dans notre programme et provoquer des erreurs qui pourront être gérées plus tard(ce qui n'est pas encore le cas).\n\nOn peut également être ammené à créer nos **propres erreurs**.\n\n### Exceptions customisées\n\nLes exceptions customisées sont des classes de la famille `Exception` que l'on aurait codé soit même dans notre programme. Elles suivent les mêmes règles que les autres exceptions.\n\nPar convention, leur nom se finit par `Exception` comme pour les autres exceptions.\n\nVoici un exemple :\n\n```\npublic class ErreurSaisieException extends Exception {\n\n  // renvoie un objet de ce type\n  // d'exception sans message\n  // particulier\n  public ErreurSaisieException(){\n    super();\n  }\n\n  // renvoie un exception avec\n  // un message customisable\n  public ErreurSaisieException(String message){\n    super(message);\n  }\n}\n```\n\n_Remarque : Nous ne nous atterderons pas dans ce cours sur le fonctionnement du mot clé `extends`, vous devez seulement savoir qu'il est nécessaire au fonctionnement de toute exception._\n\nL'usage d'exceptions customisées est possible mais il n'est pas recommandé car il n'apporte **aucune fonctionnalité pratique**.\n\nIl est possible de générer des exceptions existantes avec vos propres messages sans passé par des exceptions de votre création.\n\nLe seul interêt des exceptions custom est que, sous certains IDE, elles **forcent à inscrire le** `throws` dans les méthodes qui lèvent ces exceptions ce qui peut permettre aux débutants de ne pas oublier de le faire.\n\nSi vous n'êtes pas à l'aise avec les exceptions, l'usage le plus simple de celles-ci est de, en toutes circonstances, lever des exceptions de type `IllegalArgumentException` (l'exception la plus classique) avec ou sans des messages personnalisés.\n\n### Capturer les exceptions : try catch finally\n\nUne fois que notre programme est capable de lever des exceptions, on doit pouvoir les **capturer** pour faire en sorte que le code **s'exécute correctement si tout va bien**. Pour tout cela on utilise le bloc de code `try catch finally` :\n\n- `try` : contient les appels de méthodes **suceptibles de lever des exceptions**\n- `catch` : contient le code à executer **si une exception à préciser est levée**\n- `finally` : contient le code qui sera executé **peu importe si une exception a été levée ou non** ensuite (facultatif)\n\nLes clauses catch **ne devrait pas contenir d'algorithmie** et seulement des appels de méthodes liés aux exceptions.\n\n_Remarque : par soucis de transparence, le cours montre l'existence du bloc `finally` mais honnêtement, il ne sert à rien puisqu'il ne dépend d'aucune condition pour s'éxécuter._\n\nVoici un exemple :\n\n```\n// on tente d'éxécuter\n// un morceau de code\ntry {\n  // la méthode susceptible\n  // de faire planter\n  // le programme et qui\n  // peut faire levé une\n  // exception de type\n  // ErreurSaisieException\n  uneMethodeRisquée();\n}\n// dans le cas où le\n// contenu du bloc try\n// lève une exception du\n// type indiqué\ncatch(ErreurSaisieException e){\n  // on affiche le message\n  // de l'exception levée\n  // dans le flux d'erreur\n  System.err.println(e.getMessage());\n}\n// si une exception de\n// n'importe quel autre\n// type venait à être\n// levée\ncatch (Exception e){\n  e.printStackTrace();\n}\n// dans tous les cas\n// on éxécute le contenu\n// de ce bloc\nfinally {\n  resetApplication();\n}\n```\n\n_Remarque : si aucune exception n'est levée par `uneMethodeRisquée()`, le programme passe directement au bloc `finally` en sautant les blocs `catch`._\n\nSi les méthodes invoquées dans le bloc `try` peuvent lever plusieurs méthodes on pourra traiter les exceptions comme ici avec plusieurs catchs. Il est également possible, dans le cas où, peut importe l'erreur, on souhaite appliquer le même code, d'utiliser un `multicatch`.\n\nVoici un exemple :\n\n```\ntry {\n  uneMethodeRisquée();\n}\n// un multicatch qui tente\n// de capturer une\n// multitude d'erreurs\n// différentes\ncatch (IllegalArgumentException | NumberFormatException | ArithmeticException e) {\n  e.printStackTrace();\n}\n```\n\n_Remarque : il suffit qu'une seule exception d'un type présent dans le multicatch soit levée pour executer le code de celui-ci._\n\n_Remarque : même si cela peut paraître lourd, il ne faut pas hésitez à utiliser un bloc try catch même pour un seul appel de méthode à risque lorsque cela est nécessaire._\n\n### Exercices\n\n_Coming soon..._\n",w="# Abstraction et Héritage\n\n## Introduction\n\nLe but principal du Java est de pouvoir produire du code **le plus généraliste possible** pour pouvoir **faciliter la maintenance** et les **modifications ultérieures**.\n\nAinsi on essaye toujours de coder en partant du **cas le plus général** vers **les spécialisations éventuelles** de ce cas en gardant toujours en tête que le but est de supprimer la **redondance de code**.\n\nCette façon de coder tend à entraîner une **hiérarchie entre les classes** d'où la notion d'héritage.\n\n## Principe\n\nL'héritage repose sur une relation **\"mère-fille\"** entre les classes. Cette relation est representée par le mot clé `extends` dans la signature d'une classe.\n\nVoici un exemple :\n\n```\npublic class Chien extends Animal {\n    // code goes here\n}\n```\n\nCe qu'il faut comprendre ici c'est que la classe `Chien` hérite de la classe `Animal`. Un chien **EST UN** animal.\n\nEn Java une classe ne peut hériter au maximum que d'**une seule autre classe**. Ce n'est pas le cas en C++ par exemple où l'on peut créer des liens d'héritages multiples entre les classes.\n\nCependant les relations sont **infinies en profondeur**, c'est à dire qu'une classe peut hériter d'une classe qui elle même hérite d'une autre classe et ainsi de suite sans limite.\n\nUn lien d'héritage implique que la classe fille **possède les attributs de sa classe mère**. Elle peut également posséder **ses propres attributs en plus** de ceux de sa mère.\n\n_Remarque : la classe mère ne possède pas les attributs de la classe fille. Les liens d'héritage se font toujours de la mère vers la fille._\n\nLa classe fille peut également **faire appel aux méthodes de la classe mère**. Elle peut également avoir ses propres méthodes en plus.\n\n_Remarque : la classe mère ne peut pas utiliser les méthodes de la classe fille. Les liens d'héritage se font toujours de la mère vers la fille._\n\nPour faire appel à des éléments de la classe mère on utilise le mot clé `super`. `super` représente l'**objet père** la où `this` représente l'objet courant.\n\nVoici un exemple :\n\nLa classe mère `Animal`\n\n```\npublic class Animal {\n  private String nom;\n  private int age;\n\n  public Animal(String nom, int age) {\n    this.nom = nom;\n    this.age = age;\n  }\n\n  public void manger() {\n    System.out.println(\"MIAM MIAM\");\n  }\n}\n```\n\nLa classe fille `Chien` qui hérite de `Animal`\n\n```\npublic class Chien {\n\n  // un chien possède implicitement\n  // un nom et un age en plus\n  // de sa race car c'est\n  // un animal\n  private String race;\n\n  // on indique tous les\n  // attributs explicitement\n  // dans le constructeur\n  public Chien(String nom, int age, String race) {\n\n    // super() fait appel\n    // au constructeur de\n    // la classe Animal\n    super(nom, age);\n    // on s'occupe de l'attribut\n    // race propre aux chiens\n    // ici\n    this.race = race;\n  }\n\n  public void aboyer() {\n    System.out.println(\"OUAF OUAF\");\n  }\n}\n```\n\net enfin un exemple de programme manipulant un objet de type `Chien`\n\n```\npublic static void main(String[] args) {\n  Chien doggo = new Chien(\"paf\", 4, \"Labrador\");\n  doggo.aboyer();\n  doggo.manger();\n}\n```\n\nVoici ce que l'on obtient dans la console après execution du code ci-dessus :\n\n`OUAF OUAF`\n\n`MIAM MIAM`\n\nOn observe que l'objet `doggo` de type `Chien` possède une race mais également un nom et un age.\n\nIl peut utiliser la méthode `aboyer()` ce qui est tout a fait normal puisque cette méthode est définie dans la classe `Chien`.\n\nIl peut également utiliser la méthode `manger()` qui est définie dans la classe `Animal`.\n\nIci la classe `Animal` représente **le cas général** et doit regrouper toutes les **caractéristiques** (attributs) et les **comportements** (méthodes) commun(es) à **tous les types d'animaux**.\n\nRien n'empêche ensuite les **spécifications** de la classe `Animal`, comme `Chien` (ou bien `Chat`, `Souris`, etc.) d'ajouter à ces propriétés communes de nouvelles propriétés qui les définissent de manière **plus précise**.\n\n## Abstraction\n\nLorsqu'on développe une classe représentant le cas général et ses spécifications, la norme veut que le cas général serve de **point de concentration des éléments en commun des spécifications** (attributs et méthodes).\n\nLa classe mère ne représente alors généralement pas **des objets qui pourraient exister** en tant que tel. Si on reprend l'exemple du dessus, dans la nature il y a des chiens, des chats, des oiseaus mais pas des \"Animal\". Aucun animal dans la nature n'est de l'espèce \"Animal\".\n\nAinsi la classe mère, généralement **ne doit pas instancier des objets de son propre type**. C'est ce que l'on appelle l'**abstraction**. Pour rendre une classe abstraite on utilise le mot clé `abstract`.\n\nL'abstraction **force la présence de classes filles** car la classe mère ne peut rien faire seule. Elle sert uniquement de point de concentration.\n\nLe mot clé `abstract` peut également être utilisé pour **les méthodes** d'une classe abstraite. Ce sont alors des méthodes **sans code** qui doivent être **redéfinies** par les classes filles.\n\n_Remarque : cette pratique peut sembler n'avoir aucun interêt pour le moment mais nous verrons plus tard son utilité._\n\nVoici un exemple :\n\n```\n// la classe Animal est abstraite\n// on ne peut donc pas créer des\n// objets de type Animal\npublic abstract class Animal {\n\n  // la classe possède les\n  // attributs utiles à\n  // toutes les classes filles\n  private String nom;\n  private int age;\n\n  // une classe abstract peut quand\n  // même avoir un/des constructeur(s) qui\n  // seront utilisés via le mot clé super\n  // dans les classes filles\n  public Animal(String nom, int age) {\n    this.nom = nom;\n    this.age = age;\n  }\n\n  public String getNom(){\n    return nom;\n  }\n\n  public abstract void crier();\n}\n```\n\nIci la classe `Animal` est abstract ce qui veut dire qu'**on ne peut pas directement créer des objets** de type `Animal`, on est contraint à créer une spécification de la classe `Animal`.\n\n`getNom()` est un getter sur un attribut de la classe `Animal` ainsi, **peu importe le type d'objet** qui appelera cette méthode, elle fera toujours la même chose que ce soit pour un `Animal` ou pour un objet d'une classe fille.\n\nPour la méthode `crier()`, comme un objet de type `Animal` n'a pas de cri la classe `Animal` n'a **pas de raison de spécifier cette méthode**. Cependant il est sensé de la placer ici quand même car **tous les animaux ont en commun d'avoir un cri**.\n\nAinsi la méthode est `abstract` et ne possède pas de **corps de méthode**. La spécification sera à la charge des classes filles car **chaque espèce d'animal a son propre cri spécifique**.\n\nVoici un exemple d'implémentation de la classe `Animal` :\n\n```\npublic class Chien extends Animal {\n  private String race;\n\n  public Chien(String nom, int age, String race){\n    super(nom, age);\n    this.race = race;\n  }\n\n  public void crier(){\n    System.out.println(\"OUAF OUAF\");\n  }\n}\n```\n\net un exemple de programme utilisant nos classes\n\n```\npublic static void main (String[] args) {\n  // la variable toto\n  // est de type Chien et non pas\n  // de type Animal\n  Animal toto = new Chien(\"Polux\", 7, \"Skye Terrier\");\n\n  System.out.println(toto.getNom());\n  toto.crier();\n}\n```\n\nVoici ce que l'on obtient dans la console après execution du code ci-dessus :\n\n`Polux`\n\n`OUAF OUAF`\n\nDans cet exemple on voit l'un des premiers réels interêt de l'abstraction et l'héritage.\n\nIl est possible d'instancier un objet de type abstrait dans notre programme, ici `Animal`, en y **injectant un objet concret** qui hérite de ce type abstrait, ici `Chien`.\n\nCette façon de faire permet de grandement réduire la **dépendance du programme principal vers les autres classes** et surtout la **redondance**.\n\nUne variable de \"type\" `Animal` peut contenir des objets de types totalement différents tant que ces types hérite du type `Animal`.\n\n## Réduire les relations\n\nEn structurant notre code en faisant l'usage des **classes mères plutot que directement leurs spécifications**, comme on l'a fait dans l'exemple du `main` au dessus, on peut **réduire les dépendances entre les classes** de notre code et le rendre plus **durable** et **modulable**.\n\nVoici un exemple :\n\nOn veut représenter une animalerie qui pourrait contenir différents types d'animaux à savoir des chiens, des chats et des oiseaux. Sans notion d'héritage il faudrait faire ainsi :\n\n```\npublic class Animalerie {\n  // l'animalerie stocke\n  // des animaux de chaque type\n  // sous forme de liste\n  private List<Chien> chiens;\n  private List<Chat> chats;\n  private List<Oiseau> oiseaux;\n}\n```\n\nIl y a un gros problème avec cette solution. Si l'on souhaite un jour pouvoir rajouter de **nouveaux types d'animaux** (comme des poissons par exemple) ou en enlever de ceux déjà présent, il va falloir **modifier le code de toutes les classes qui utilises ces types d'animaux**, ici il n'y a que `Animalerie` mais dans un vrai programme il pourrait y en avoir bien plus.\n\nLes classes manipulant des animaux **ne doivent pas dépendre des classes filles** de `Animal`.\n\nAinsi pour réduire les dépendances on préfèrera **manipuler en priorité la classe mère** c'est à dire le type le plus **général** et **abstrait**.\n\nLe code de `Animalerie` deviendrait donc le suivant :\n\n```\npublic class Animalerie {\n  // une liste d'objet de\n  // type Animal\n  private List<Animal> animaux;\n}\n```\n\nIci, en partant du principe que les classes `Chien`, `Chat` et `Oiseau` héritent de la classe `Animal`, la liste `animaux` peut contenir des objets de **tous ces types**.\n\nSi à l'avenir on **rajoute** ou bien on **enlève** des spécifications de la classe `Animal` donc des classes filles, le code de la classe `Animalerie` et des autres classes manipulant des animaux (comme le `main par exemple) **n'aura pas besoin d'être modifié**.\n\nC'est en ça que l'abstraction et l'héritage permettent de produire du code modulable c'est à dire facilement modifiable.\n\n## Exercices\n\n_Coming soon..._\n",T="# Polymorphisme\n\n## Introduction\n\nDans un lien d'**héritage** entre **une classe mère et sa classe fille**, la classe fille peut accéder aux méthodes de la classe mère.\n\nIl est possible de construire les **méthodes** d'une certaines façons dans des liens d'héritage permettant de rendre le code **encore plus modulable**. C'est le **polymorphisme**.\n\n## Principe\n\nPour utiliser le polymorphisme sur une méthode entre une classe mère et une de ses classes filles, il faut que la méthode soit **implémentée de la même façon dans les deux classes** du point de vue du compilateur.\n\nPour cela il faut que les méthodes possèdent le même **prototype**. Elles doivent possèder exactement le même **nom**, la même **valeur de retour**, les mêmes **propriétés** et les mêmes **paramètres** d'entrée **dans le même ordre**.\n\nLe **code à l'intérieur de la méthode** peut quand à lui être **différent** entre la version de la classe mère et la version de la classe fille, c'est justement la tout l'interêt du polymorphisme.\n\nSi toutes ces conditions sont réunies, un lien **polymorphique** est établie entre la version de la méthode dans la classe mère et la classe fille. On dit que la version de la méthode de la classe fille `Override` la version de la méthode de la classe mère.\n\nVoici un exemple :\n\nUne classe mère `Animal`\n\n```\n// la classe mère abstraite\n// représentant un animal\n// standard qui peut crier\npublic class Animal {\n\n  public void cri(){\n    System.out.println(\"OWO\");\n  }\n}\n```\n\nDifférentes spécifications de la classe `Animal`\n\n```\npublic class Chien extends Animal {\n\n  // la méthode cri de la classe Chien\n  // possède le même prototype que\n  // la version de la classe Animal\n  // cependant le code à l'intérieur\n  // est différent\n  @Override\n  public void cri() {\n    System.out.println(\"OUAF\");\n  }\n}\n```\n\n_Remarque : l'annotation `@Override` permet d'indiquer au compilateur qu'un lien polymorphique est établi sur la méthode annoté mais cette annotation n'est plus obligatoire aujourd'hui._\n\n```\npublic class Chat extends Animal {\n\n  // de même pour l'implémentation\n  // de la méthode cri dans cette\n  // classe Chat\n  @Override\n  public void cri() {\n    System.out.println(\"MIAOU\");\n  }\n}\n```\n\n```\npublic class Cochon extends Animal {\n  // la classe Cochon est vide\n  // elle n'apporte aucune\n  // spécification en plus de celles\n  // présente dans la classe Animal\n}\n```\n\nUn programme mettant en scène le fonctionnenement du polymorphisme :\n\n```\npublic static void main(String[] args){\n  Animal pito = new Chien();\n  Animal malo = new Chat();\n  Animal porky = new Cochon();\n\n  pito.cri();\n  malo.cri();\n  porky.cri();\n}\n```\n\nVoici ce que l'on obtient dans la console après execution du code ci-dessus :\n\n`OUAF`\n\n`MIAOU`\n\n`OWO`\n\nLe lien polymorphique sur la méthode `cri()` indique au compilateur de préférer la version de la méthode **la plus proche hierarchiquement du type de l'objet appelant** la méthode.\n\nLorsqu'une classe **ne contient pas de spécification de la méthode appelée**, comme par exemple la classe `Cochon` qui ne contient pas d'implémentation de la méthode `cri()`, la version existante de la méthode **la plus proche dans la hierachie** sera utilisée, ici la version de la classe mère `Animal`.\n\n_Remarque : le compilateur remonte dans la hierarchie autant de fois qu'il le faudra jusqu'à trouver une version valide a la méthode appelée._\n\nLe polymorphisme est une mécanique qui fonctionne de paire avec l'abstraction et l'héritage. Pour un **même code** il est donc possible grâce au polymorphisme de produire des **résultats différents**.\n\nDans l'exemple du `main` au dessus, si l'on changeait le type des objets `pito` ou bien `porky`, le code complilerait toujours mais on obtiendrait des résultats différents.\n\nSi l'on rajoutait de nouveaux types d'animaux comme un `Oiseau`, cette nouvelle classe fille pour redéfinir sa méthode `cri()` et fonctionner **sans avoir besoin de modifier le reste du code du programme**.\n\n## Exercices\n\n_Coming soon..._\n",z="# Abstraction et Interface\n\n## Introduction\n\nIl existe d'autres mécaniques que les liens d'héritage pour rendre plus durable et modulable du code Java.\n\nOn peut établir des **contrats** avec les classes pour qu'elles implémente des **comportements** donc des méthodes. Cela se fait au travers des **interfaces** qui permettent de réunir les comportements en commun entre plusieurs classes.\n\n_Remarque : il ne faut pas confondre les interfaces de programmation avec des interfaces graphiques._\n\n## Principe\n\nUne interface **n'est pas une classe**, elle contient uniquement les **prototypes des méthodes** qui devront être implémenté par la classe qui signe un \"contrat\" avec l'interface.\n\nOn représente ce contrat par le mot clé `implements`. Une classe qui **implémente une interface** doit **obligatoirement** spécifié les méthodes du contrat de l'interface. Cette spécification se repose sur le **polymorphisme**.\n\nVoici un exemple :\n\nL'interface `Machine` décris un comportement composé de trois méthodes\n\n```\npublic interface Machine {\n  public void démarrer();\n  public void veille();\n  public void arrêter();\n}\n```\n\n_Remarque : une interface peut contenir n'importe quelles méthodes sauf des constructeurs._\n\nLa classe `Ordinateur` possède le comportement d'une machine, elle implémente donc `Machine`\n\n```\npublic class Ordinateur implements Machine {\n  private int id;\n\n  public Ordinateur(int id) {\n    this.id = id;\n  }\n\n  // la classe Ordinateur doit obligatoirement\n  // implémenter les méthodes démarrer,\n  // veille et arrêter\n  @Override\n  public void démarrer() {\n    System.out.println(\"Démarrage en cours...\");\n  }\n\n  @Override\n  public void veille() {\n    System.out.println(\"Mise en veille...\");\n  }\n\n  @Override\n  public void arrêter() {\n    System.out.println(\"Arrêt en cours...\");\n  }\n}\n```\n\nDans cet exemple, la classe `Ordinateur` est contrainte à spécifier les méthodes de l'interface `Machine`. Il en irait de même pour **n'importe qu'elle autre classe** implémentant l'interface `Machine`, le but étant, de **réunir du code** derrière une seule entité pour éviter encore et toujours la **redondance**.\n\nUne interface **ne peut pas contenir d'attributs**, comme ce n'est pas une classe **on ne peut pas instancier des objets du type de l'interface**. Il n'y pas de constructeur pour les interfaces.\n\nUne classe peut implémenter **plusieurs interfaces à la fois**. Une classe peut hériter d'une classe et en même temps implémenter une ou plusieurs interfaces.\n\nVoici un exemple de formulation d'une telle classe :\n\n```\npublic classe Voiture extends Vehicule implements Machine, Transport {\n  // la classe Voiture hérite de la classe Vehicule\n  // et implémente les interfaces Machine et Transport\n}\n```\n\n_Remarque : il est obligatoire de placer la notion d'héritage éventuelle donc `extends` avant les implémentations d'interface donc le `implements`. On met toujours une virgule entre les interfaces implémentées s'il y en a plusieurs._\n\nBien qu'il ne soit pas possible de manipuler des objets du type d'une interface, les interfaces peuvent quand même être utilisées pour réduire les dépendandes tout comme l'héritage.\n\nVoici un exemple :\n\n```\npublic class Usine {\n  // cette liste peut contenir des objets de n'importe\n  // quel type qui implémente l'interface Machine\n  // comme Ordinateur par exemple\n  private List<Machine> machines;\n}\n```\n\nLa même mécanique dans un `main`\n\n```\npublic static void main(String[] args){\n  // on ne peut pas instancier d'objet\n  // de type Machine mais on peut\n  // s'en servir pour instancier\n  // des objets de type implémentant\n  // cette interface\n  Machine machine = new Ordinateur(42);\n}\n```\n\n## Héritage ou Interface ?\n\nL'héritage et l'interface sont des mécanismes qui **ne sont pas incompatibles**, ils ne répondent juste pas aux mêmes problématiques.\n\nOn choisira l'héritage lorsqu'on a besoin pour des objets de **représenter un cas général** dont les propriétés pourront être **spécifiées dans des classes filles**. L'héritage est d'autant plus utile pour éviter la redondance pour les **attributs**. Il est possible d'utiliser l'**abstraction** pour les méthodes en communs qui n'ont pas besoin d'un cas général.\n\nOn choisira l'interface pour décrire **les comportements abstraits** d'une catégorie d'objets. Les interfaces sont utiles tout particulièrement pour éviter la redondance sur des méthodes entre plusieurs classes. De plus contrairement à l'héritage, elles **forcent les classes** à implémenter les méthodes là où une classe mère n'oblige en rien une classe fille à spécifier des méthodes.\n\n## Exercices\n\n_Coming soon..._\n",P={environnement_travail_java:g,classes_attributs:q,methodes:x,programme_principal:y,enumerations:j,bibliotheques:C,collection_iterable:L,interface_utilisateur:E,valeurs_aleatoires:A,dictionnaires:S,mode_debug:_,tests_unitaires:I,gestion_exceptions:k,abstraction_heritage:w,polymorphisme:T,abstraction_interface:z},D="# Bases de Javascript\n\n## Introduction\n\nLe Javascript est un langage de programmation permettant de construire des applications logicielles ou web. C'est un langage proche du script extrêmement polyvalent qui est utilisé dans de nombreux domaines. Il est également la base de nombreux frameworks et autres outils spécialisés. Le but de ce cours est de vous présenter le fonctionnement de ce langage pour pouvoir ensuite l'exploiter dans un contexte d'application web.\n\n## Structure\n\n### Types\n\nLe Javascript est un langage faiblement typé. Ils ne sont pas requis pour la manipulation de donnée mais il existe quand même des types de base :\n\n+ ``number`` : nombre entier, relatif, etc.\n+ ``string`` : chaîne de caractères\n+ ``boolean`` : information booléenne\n+ ``null, undefined`` : variable vide\n+ ``symbol``\n\n### Variables\n\nLes variables fonctionnent comme dans n'importe quel autre langage de programmation, elles permettent de stocker une information, une valeur, pour pouvoir être traiter. Il y a plusieurs façon d'instancier une variable :\n\n**Exemple** :\n\n```js\nvar prenom = 'titi' // string\nlet nom = 'toto' // string\nlet age = 2 // number\nvar sexe = true // boolean\nconst vérité = 'Les chats sont mieux que les chiens'\n```\n\nIl existe de subtiles différences entre les mots clés `var` et `let`, les deux permettent d'instancier des variables et il est préférables d'utiliser `let` la majeure partie du temps. Le but de cet exemple était de présenter les possibilités mais nous n'allons pas nous attarder sur une vraie comparaison.\n\nLe mot clé `const` permet d'instancier une constante, c'est à dire qu'une fois que cette variable se verra attribuer une première fois une valeur, cette valeur ne pourra plus être changée par la suite. Il est très fréquent d'utiliser des constantes en Javascript car on manipule souvent des références mais nous y reviendrons.\n\n*Remarque : les fins d'instructions n'ont pas besoin d'être représentées en Javascript, le `;` n'est pas obligatoire*\n\n*Remarque : les opérandes entre les données de type number (+, -, /, etc) restent inchangées.*\n\n*Remarque : Il est possible de définir des strings avec les simples `''` ou les doubles cotes `\"\"`. Le contexte web utilise les doubles cotes dans certains contextes et il est donc possibles d'utiliser des simples cotes à l'intérieur de doubles cotes (Ex : machin()=\"'phrase'\")*\n\n### Tableaux\n\nEn Javascript les tableaux sont eux aussi non typés et peuvent contenir tous types de valeurs.\n\n**Exemple** :\n\n```js\nlet membres = ['titi', 'toto', 'tutu']\n\nlet premierMembre = membres[0] // 'titi'\n```\n\nLes tableaux possèdent leur propre logique :\n\n+ `length` : un attribut qui indique la taille du tableau c'est à dire le nombre d'éléments qu'il contient\n+ `push(element)` : ajoute un élément à la fin du tableau\n+ `unshift(element)` : ajoute un element au début du tableau\n+ `pop()` : retire le dernier élément du tableau\n\n**Exemple** :\n\n```js\nlet membres = []\nmembres.push('titi') // membres = ['titi']\nmembres.unshift('toto') // membres = ['toto', 'titi']\nlet taille = membres.length // 2\nmembres.pop() // membres = ['toto']\n```\n\n### Objets\n\nLes objets Javascript permettent de réunir plusieurs informations ou caractéristiques derrière une seule variable par association clé-valeur. Ils sont décrits par le biais de blocs qui contiennent leurs attributs :\n\n**Exemple** :\n\n```js\nlet chat = {\n  nom: 'pito',\n  age : 2\n}\n\nlet nomDuChat = chat.nom // 'pito'\nlet ageDuChat = chat['age'] // 2\n```\n\n*Remarque : il est possible d'utiliser la syntaxe par pointeur ou par crochet pour accéder à la valeur d'un attribut d'un objet. Tout dépend des informations disponibles sur l'objet en fonction du contexte mais la syntaxe par pointeur reste la plus courante.*\n\nLes éléments d'un tableau ainsi que les attributs d'un objet sont accédés par référence, c'est à dire que modifier ces éléments ne modifie pas le tableau ou l'objet en lui même. De ce fait les tableaux et les objets sont généralement déclarés comme des constantes :\n\n**Exemple** :\n\n```js\nconst membre = {\n  nom : 'toto',\n  age: 21\n}\n\nconst membres = [membre] // un tableau contenant l'objet membre\n\nmembre.age = 22 // on modifie l'objet\n\nconsole.log(membres) // Output : { nom: 'toto', age: 22 }\n```\n\n## Algoritmie\n\n### Conditions\n\nLes instructions `if / else / switch`, les opérateurs `<, >, <=, >=, !=` et `&&, ||` fonctionnent de manières similaires aux autres langages.\n\n*Remarque : La comparaison `==` vérifie uniquement la valeur des deux variables, `===` permet de vérifier la valeur et le type des deux variables*\n\n**Exemple** :\n\n```js\nlet titi = 6\nlet toto = '6'\n\nconsole.log(titi == toto) // true\nconsole.log(titi === toto) // false\n```\n\n### Boucles de contrôle\n\nLa boucle `while` est présente en Javascript mais pas la boucle `do while`. Il existe plusieurs types de boucles `for` :\n\n+ le for \"classique\"\n+ le for...in\n+ le for...of\n\n**Exemple** :\n\n```js\nlet membres = ['titi', 'toto', 'tutu']\n\nfor (let i = 0; i < membres.length; i++) {\n  console.log('Tu es un membre !')\n}\n\nfor (let i in members) {\n  console.log(members[i] + ' est un SUPER membre !)\n}\n\nfor (let member of members) {\n  console.log(member + 'est un INCROYABLE membre)\n}\n```\n\n*Remarque : le for...in n'est quasiment jamais utilisé au profit du for...of.*\n\n### Fonctions\n\nLes fonctions en Javascript fonctionnent légerement différement du au contexte sous typé. De plus elles possèdent des propriétés différentes que dans les autres langages mais nous n'aborderons ces propriétés qu'a partir des cours en contexte web.\n\n**Exemple** :\n\n```js\nfunction afficherDesValeurs(valeur1, valeur2) {\n  console.log('Première valeur : ' + valeur1)\n  console.log('Deuxième valeur : ' + valeur2)\n}\n\nfunction additionner(nombre1, nombre2) {\n  return nombre1 + nombre2\n}\n\nafficherDesValeurs(6, 'toto') // Output : Première valeur : 6 Deuxième valeur : toto\nconsole.log(additionner(2, 7)) // Output : 9\n```\n\n*Remarque : la recursivité est possible en Javascript.*\n\n### Exceptions\n\nLe bloc `try catch` est présent en Javascript et se construit de cette manière :\n\n```js\ntry {\n\n// code susceptible à l'erreur ici\n\n} catch (error) {\n\n// réaction aux erreurs ici\n\n}\n```\n\n## Classes et méthodes\n\nLes classes sont des blocs qui permettent de réunir à la fois un modèle de données pour un objet mais aussi des fonctions qui lui sont propres grâce aux méthodes d'instances. Les types de données ainsi créés fonctionnent commes les autres types du Javascript à l'exception de l'instanciation.\n\n**Exemple** :\n\n```js\nclass Chat {\n\n  constructor(nom, age) {\n    this.nom = nom\n    this.age = age\n  }\n\n  miauler() {\n    console.log('miaou !')\n  }\n\n  static verite(nombre) {\n    return 'Les chats sont ' + nombre + ' fois meilleurs que les chiens :)'\n  }\n\n}\n\nlet chat = new Chat('malo', 3)\nchat.miauler() // 'miaou !'\nconst laVerite = Chat.verite(10) // 'Les chats sont 10 fois meilleurs que les chiens :)'\n```\n\n## Tests unitaires\n\n*Coming soon...*\n\n## Exercices\n\n*Coming soon...*\n",R="# Bases de Javascript pour le Web\n\n## Introduction\n\nLe Javascript est une pièce maitresse du développement Web, c'est le langage de compilation de tous les navigateurs existants, c'est à dire que c'est ce langage qui permet au navigateur de produire des pages web sous la forme à laquelle nous sommes habitués. Le Javascript permet également de rendre le contenu d'une page web dynamique, d'y injecter de l'algorithmie et du traitement de donnée, d'intéragir avec des API, bref, la liste est longue.\n\nHistoriquement le Javascript était reservé à la construction de la partie front-end d'une application Web, c'est à dire le contenu visible et les interactions avec l'utilisateur. Ce n'est aujourd'hui plus le cas et de plus de nombreux outils modernes, des frameworks, permettent de créer des applications web très puissantes de A à Z et bien plus facilement qu'auparavant.\n\nDans ce cours nous allons découvrir le fonctionnement de base du Javascript et de son interaction avec le contenu d'une page Web. Chaque interaction sera accompagnées d'exemples mais il est impossible et inutile de couvrir tous les cas possibles dans ce cours, ainsi il est fortement conseillé de consulter la documentation en ligne sur [Developper Mozilla](https://developer.mozilla.org/fr/)\n\n## Compilation\n\nLorsqu'on déploie une application Web composé notamment d'éléments HTML (ou de balises) accompagnées de style CSS et éventuellement de script JS, tout ce contenu est d'abord réuni en un seul fichier pour faciliter la compilation auprès du navigateur. Tout est mis en oeuvre pour que cette compilation soit la plus rapide possible car tout le monde sait qu'une page web qui ralentit fait fuir les utilisateurs et peut entraîner des bugs.\n\nIl existe de nombreux outils, couplés aux fonctionnalités du Javascript, qui permettent d'optimiser au maximum la compilation. Le fichier produit ensuite est bien sur absolument illisible pour un être humain mais bien pratique pour le navigateur de votre choix.\n\n## Le DOM\n\nLe Document Object Model, ou DOM, pose les fondations de l'architecture d'une application Web, c'est ce modèle qui explique les interactions entre les balises HTML et c'est auprès de celui-ci que les scripts JS se réfère pour accéder à des éléments dans la page web.\n\n*Remarque : On réfère au DOM dans le Javascript via le mot clé `document`.*\n\n## Interactions\n\nLes interactions de bases possibles entre un script JS et une page web sont les suivantes :\n\n+ récupérer un élément HTML et son contenu\n+ modifier un élément HTML\n+ modifier le style d'un élément\n+ écouter des évènements sur un élément\n\n*Remarque : un évènement est une action qui s'effectue sur la page, un évènement peut être un changement d'état d'un élément de la page (ex: chargement de l'élément terminé) ou bien une intervention de l'utilisateur (ex: clic sur un bouton, un Link).*\n\n### Recuperer un élément HTML\n\nLes balises HTML sont caractérisées par differentes propriétés qui permettent de facilement récupérer ce que l'on souhaite dans une page. Toute balise possède un type et eventuellement une classe, ces deux caractéristiques permettent d'isoler des groupes de balise dans la page. Une balise peut également posséder un id qui va alors permettre d'identifier une balise de manière unique.\n\nLe Javascript permet d'exploiter ces caractéristiques avec différents sélécteurs :\n\n+ `getElementsByTagName('tag')` : retourne un tableau contenant les éléments de type `tag` (nom de la balise)\n+ `getElementsByClassName('class')` : retourne un tableau contenant les éléments possèdant la classe `class`\n+ `getElementById('id')` : retourne l'élément identifié par `id`\n\n**Exemple** :\n\n```js\nconst monTableau = document.getElementById('tableau')\nconst cellules = monTableau.getElementsByTagName('td')\n```\n\nIl est possible d'effectuer une recherche plus pointue avec le querySelector qui permet de combiner différents outils de recherche :\n\n**Exemple** :\n\n```html\n<div id=\"myId\">\n    <p>\n        <span><a href=\"#\">Link 1</a></span>\n        <a href=\"#\">Link 2</a>\n        <span><a href=\"#\">Link 3</a></span>\n    </p>\n    <p class=\"toto\">\n        <span><a href=\"#\">Link 4</a></span>\n        <span><a href=\"#\">Link 5</a></span>\n        <a href=\"#\">Link 6</a>\n    </p>\n    <p>\n        <a href=\"#\">Link 7</a>\n        <span><a href=\"#\">Link 8</a></span>\n        <span><a href=\"#\">Link 9</a></span>\n    </p>\n</div>\n```\n\n```js\nconst preciseElement = document.querySelector(\"#myId p.toto > a\")\n```\n\nOn recherche dans un élément ayant pour id 'myId' les éléments de type `<p>` ayant pour classe `toto` afin de récupérer l'enfant direct de type Link `<a>`. `preciseElement` contient donc le Link 6.\n\nOn peut également récupérer des éléments liés hierarchiquement avec d'autres :\n\n+ `element.children` : retourne un tableau contenant tous les éléments enfants de `element`\n+ `element.parentElement` : retourne l'élément parent de `element`\n+ `element.nextElementSibling / element.previousElementSibling` : retourne l'élément suivant ou précédent `element` au même niveau hierarchique.\n\n**Exemple** :\n\n```html\n<div id=\"parent\">\n    <div id=\"toto\">Previous</div>\n    <div id=\"main\">\n        <p>Text 1</p>\n        <p>Text 2</p>\n    </div>\n    <div id=\"titi\">Next</div>\n</div>\n```\n\n```js\nconst elt = document.getElementById('main')\n```\n\n+ `elt.children` renvoient les éléments `<p>` enfants de la div ayant pour id `main`\n+ `elt.parentElement` renvoie la div ayant pour id `parent`\n+ `elt.nextElementSibling` renvoie la div ayant pour id `titi`\n\n*Remarque : Toutes ces méthodes de recherche renvoie un élément `null` si la recherche ne porte pas ses fruits, le programme ne plante pas nécessairement.*\n\n### Modifier un élément\n\nUne fois que l'on a récupéré un élément du DOM on peut modifier ses propriétés. La modification la plus courante est celle du contenu HTML lui même de cet élément. Plusieurs méthodes existent :\n\n+ `innerHTML` : remplace le contenu actuel de l'élément par un nouveau contenu HTML\n+ `textContent` : remplace le contenu actuel de l'élément par un nouveua contenu textuel\n\n*Remarque : Il existe d'autres façons, celles-ci sont les plus courantes. `textContent` ne peut pas interpréter la syntaxe html et est donc beaucoup moins utile.*\n\n**Exemple** :\n\n```js\nlet elt = document.getElementById('toto')\nelt.innerHTML = \"<ul><li>Ligne 1</li><li>Ligne 2</li></ul>\"\n```\n\nRésultat :\n\n```html\n<div id=\"toto\">\n    <ul>\n        <li>Ligne 1</li>\n        <li>Ligne 2</li>\n    </ul>\n</div>\n```\n\nUne autre modification possible est le changement de classe d'un élément grâce à la propriété `classList` :\n\n**Exemple** :\n\n```js\nelt.classList.add(\"nouvelleClasse\")           // Ajoute la classe nouvelleClasse à l'élément\nelt.classList.remove(\"nouvelleClasse\")        // Supprime la classe nouvelleClasse que l'on venait d'ajouter\nelt.classList.contains(\"nouvelleClasse\")      // Retournera false car on vient de la supprimer\nelt.classList.replace(\"oldClass\", \"newClass\") // Remplacera oldClass par newClass si oldClass était présente sur l'élément\n```\n\n*Remarque : il est possible d'ajouter et de retirer plusieurs classes à la fois.*\n\nOn peut modifier le style d'un élément sans passer par une feuille de style CSS grâce à la propriété `style` :\n\n**Exemple** :\n\n```js\nelt.style.color = \"#fff\";           // Change la couleur du texte de l'élément à blanche\nelt.style.backgroundColor = \"#000\"; // Change la couleur de fond de l'élément en noir\nelt.style.fontWeight = \"bold\";      // Met le texte de l'élément en gras\n```\n\nSi un élément peut posséder des attributs, on peut les modifier :\n\n**Exemple** :\n\nPour un élément de type input qui est un type possédant des attributs\n\n```js\nelt.setAttribute(\"type\", \"password\");    // Change le type de l'input en un type password\nelt.setAttribute(\"name\", \"my-password\"); // Change le nom de l'input en my-password\nelt.getAttribute(\"name\");                // Retourne my-password\n```\n\n### Créer un élément\n\nIl est possible de créer de nouveaux éléments depuis un script JS cependant pour que ces éléments soient visibles sur la page il faut impérativement les rattacher à des éléments déjà existants dans le DOM.\n\nPour créer un élément on utilise `createElement` puis `appendChild` pour le rattacher à la page via un autre élément :\n\n**Exemple** :\n\n```js\nconst newElt = document.createElement(\"div\");\nlet parent = document.getElementById(\"toto\");\n\nparent.appendChild(newElt);\n```\n\nComme il est possible de créer, il est également possible de supprimer un élément si celui-ci est enfant d'un élément du DOM, pour cela on utilise `removeChild` ou bien `replaceChild` :\n\n**Exemple** :\n\n```js\nconst newElt = document.createElement(\"div\");\nlet elt = document.getElementById(\"main\");\nelt.appendChild(newElt);\n\nelt.removeChild(newElt);                                     // Supprime l'élément newElt de l'élément elt\nelt.replaceChild(document.createElement(\"article\"), newElt); // Remplace l'élément newElt par un nouvel élément de type article\n```\n\n## Exercices\n\n*Coming soon...*\n",O={bases_javascript:D,bases_javascript_web:R};const M=[{id:"1",title:"Creascio",icon:"https://cdn.discordapp.com/attachments/822839106001829908/822839194099384360/discord_pdp.png",chapters:[{id:"1-1",title:"Présentation de Creascio",icon:"",markdown:r.presentation_creascio},{id:"1-2",title:"Devenir Helper",icon:"",markdown:r.devenir_helper}]},{id:"2",title:"Git",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850371933118791690/AdKzmNKdPeteAAAAABJRU5ErkJggg.png",chapters:[{id:"2-1",title:"Environnement de travail (Git)",icon:"",markdown:d.environnement_travail_git},{id:"2-2",title:"GitHub",icon:"",markdown:d.bases_github},{id:"2-3",title:"GitHub Desktop",icon:"",markdown:d.bases_github_desktop},{id:"2-4",title:"Merge Request",icon:"",markdown:d.merge_request},{id:"2-5",title:"Pull Request",icon:"",markdown:d.pull_request}]},{id:"3",title:"Bases de la Programmation",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850372098277900318/c-programming.png",chapters:[{id:"3-1",title:"Environnement de travail (C)",icon:"",markdown:h.environnement_travail_c},{id:"3-2",title:"Variables et Types primitifs",icon:"",markdown:h.types_primitifs_variables},{id:"3-3",title:"Affichage Console",icon:"",markdown:h.affichage_console},{id:"3-4",title:"Conditions Booléennes",icon:"",markdown:h.conditions_booleennes},{id:"3-5",title:"Boucles de contrôles",icon:"",markdown:h.boucles_controle}]},{id:"4",title:"Programmation Orientée Objet",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850372498871681034/226777.png",chapters:[{id:"4-1",title:"Environnement de travail (Java)",icon:"",markdown:P.environnement_travail_java},{id:"4-2",title:"Classes et Attributs",icon:"",markdown:P.classes_attributs},{id:"4-3",title:"Méthodes",icon:"",markdown:P.methodes},{id:"4-4",title:"Programme principal",icon:"",markdown:P.programme_principal},{id:"4-5",title:"Enumérations",icon:"",markdown:P.enumerations},{id:"4-6",title:"Bibliothèques",icon:"",markdown:P.bibliotheques},{id:"4-7",title:"Collection et Iterable",icon:"",markdown:P.collection_iterable},{id:"4-8",title:"Interface Utilisateur",icon:"",markdown:P.interface_utilisateur},{id:"4-9",title:"Valeur Aléatoire",icon:"",markdown:P.valeurs_aleatoires},{id:"4-10",title:"Dictionnaires",icon:"",markdown:P.dictionnaires},{id:"4-11",title:"Mode Debug",icon:"",markdown:P.mode_debug},{id:"4-12",title:"Tests Unitaires",icon:"",markdown:P.tests_unitaires},{id:"4-13",title:"Gestion des Exceptions",icon:"",markdown:P.gestion_exceptions},{id:"4-14",title:"Abstraction et Héritage",icon:"",markdown:P.abstraction_heritage},{id:"4-15",title:"Polymorphisme",icon:"",markdown:P.polymorphisme},{id:"4-16",title:"Abstraction et Interface",icon:"",markdown:P.abstraction_interface}]},{id:"5",title:"Programmation Orientée Web",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850373060645093406/javascript.png",chapters:[{id:"5-1",title:"Bases de Javascript",icon:"",markdown:O.bases_javascript},{id:"5-2",title:"Javascript pour le Web",icon:"",markdown:O.bases_javascript_web}]}];n["a"]=M},bb95:function(e,n,t){"use strict";t("863e")}}]);