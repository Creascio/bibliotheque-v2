(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[1],{"641e":function(e,n,r){"use strict";var t=function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",{staticClass:"bg-grey-10 row justify-between items-center"},[r("q-btn",{staticClass:"q-mx-sm",attrs:{icon:"arrow_back_ios",size:"md",flat:""},on:{click:function(n){return e.goBack()}}}),r("div",{staticClass:"text-h6 q-py-sm text-center title"},[e._v(e._s(e.title.split("-").join(" ")))]),r("q-btn",{staticClass:"q-mx-sm",attrs:{size:"md",flat:""}})],1)},s=[],i=r("a6f4"),a=Object(i["b"])({props:{title:{type:String,required:!0}},methods:{goBack(){this.$router.back()}}}),o=a,u=(r("bb95"),r("2877")),l=r("9c40"),c=r("eebe"),d=r.n(c),p=Object(u["a"])(o,t,s,!1,null,"7a0804ef",null);n["a"]=p.exports;d()(p,"components",{QBtn:l["a"]})},"863e":function(e,n,r){},"8fcf":function(e,n,r){"use strict";var t=function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("q-list",{class:e.listClass,attrs:{padding:"",bordered:"",separator:""}},e._l(e.content,(function(n){return r("q-item",{key:n.id,class:e.itemClass,attrs:{to:e.redirection+n.title.toLowerCase().split(" ").join("-"),clickable:""}},[r("q-item-section",{attrs:{avatar:""}},[r("div",[r("q-img",{staticStyle:{border:"solid 3px white",height:"60px",width:"60px","border-radius":"5px"},attrs:{src:n.icon}})],1)]),r("q-item-section",[r("q-item-label",[e._v(e._s(n.title))])],1)],1)})),1)},s=[],i=r("a6f4"),a=Object(i["b"])({props:{listClass:{type:String,required:!0},itemClass:{type:String,required:!0},content:{type:Array,required:!0},redirection:{type:String,required:!0}},setup(){}}),o=a,u=r("2877"),l=r("1c1c"),c=r("66e5"),d=r("4074"),p=r("068f"),m=r("0170"),v=r("eebe"),b=r.n(v),h=Object(u["a"])(o,t,s,!1,null,null,null);n["a"]=h.exports;b()(h,"components",{QList:l["a"],QItem:c["a"],QItemSection:d["a"],QImg:p["a"],QItemLabel:m["a"]})},ab91:function(e,n,r){"use strict";var t="# Présentation de Creascio\r\n\r\n## Introduction\r\n\r\nBienvenue dans Creascio ! Le but de notre communauté est de vous faire découvrir des langages ou framework informatiques au travers de tutos, d'exercices et de projets à réaliser. Nous pouvons aussi offrir quel témoignages, astuces et conseils dans d'autre domaines partiquer par nos membres. Nous sommes également une communauté faite pour rencontrez de nouvelle personnes que ce soit pour faire des projets ou se faire des amis.\r\n\r\nPS : Bien sur, nous ne sommes pas des professionnels donc cette communauté est plus une aide à votre autoformation ou un complément aux études que vous faites.\r\n\r\n## Le site\r\n\r\nIci vous retrouverez tout les tutos, exercices, énoncés de projets ainsi que les astuces et conseils énoncés plus haut.\r\n\r\nChaque compétences (langage informatique, framework informatique, graphisme, conception de jeu vidéo) est divisé en notions parfois accompagnées d'exercices ou de projets en sprint.\r\n\r\nChaque notion suit ce plan :\r\n\r\n+ ``Prérequis`` : Notions à connaitre avant la lecture du cours (optionnel)\r\n+ ``Introduction`` : Présentation du contenu du cours\r\n+ ``Contenu`` : Toutes les connaissances liées au cours\r\n+ ``Exercices`` : Exercices / projets liés au cours (optionnel)\r\n+ ``Suivants`` : Cours suivant (optionnel)\r\n\r\nTout le contenu est accessible à tout moment mais si vous avez besoin d'etre guidé dans votre apprentissage nous avons mis en place un \"arbre de competences\".\r\n\r\n## Le Discord\r\n\r\nIl y a différents rôles sur le Discord Creascio :\r\n\r\n+ ``Helper`` : les membres créateurs de contenu pour Creascio\r\n+ ``Membre`` : les membres actifs de la communauté et qui reçoivent les news du serveur\r\n+ ``Externe`` : les membres présents mais qui ne reçoivent pas les news du serveur\r\n+ ``Visiteur`` : les nouveaux membres\r\n\r\nLe Discord Creascio est divisé en plusieurs catégories :\r\n\r\n+ ``Accueil`` : les salons dédiés aux **Visiteur** à leur arrivée.\r\n+ ``Infos`` : les salons dédiés aux informations accessibles à tous les **Membre** et également aux news des **Helper**\r\n+ ``Podium`` : les salons dédiées au partage de contenus divers avec la communauté (musique, art, etc.)\r\n+ ``General`` : les salons dédiées aux discussions en tout genre\r\n+ ``Jeux`` : les salons dédiées au partage de contenus liés aux jeux\r\n+ ``Aide`` : les salons dédiées à tout type de question et à l'aide aux études / projets\r\n\r\n## Les activités\r\n\r\nSur le Discord les **Helpers** peuvent organiser des cours oraux ou des soutiens d'exercices et projets en fonction des besoins des membres.\r\n\r\nNous organisons également des soirées jeux pour papoter en vocal afin de mieux vous connaitre.\r\n\r\nEnfin si vous souhaitez faire un projet en groupe avec des membres de Creascio, les **Helpers** sont à votre disposition pour vous aider dans la limite de nos compétences. Nous pouvons, si vous le voulez, créer un espace sur le discord dédié à votre projet.\r\n\r\n## Pour commencer\r\n\r\nEn tant que nouvel arrivant, nous t'invitons a remplir ce petit questionnaire : [cliquez ici !](https://forms.gle/4XMKZJbRgDmJ38rU7)\r\n\r\nIl est aussi primordial de compléter le cours **Git** avant de commencer votre apprentissage.\r\n\r\nBravo d'avoir tout lu, vous faites maintenant parti de Creascio !\r\n",s="# Devenir Helper\r\n\r\n## Introduction\r\n\r\nLes Helpers ont un rôle clé dans Creascio, ce sont les membres qui créer du contenu et qui souhaitent aider les autres membres.\r\nDans ce document nous allons détailler ce que l'on attend de vous si vous souhaitiez devenir un Helper pour Creascio.\r\n\r\n## Ce qu'il faut pour être Helper\r\n\r\nPour devenir Helper il faut déjà avoir une certaine expérience dans une notion, peu importe son sujet. Il n'est pas nécessaire qu'elle soit déjà abordée dans le cadre de Creascio bien au contraire.\r\n\r\nIl faut être capable au minimum de pouvoir aiguiller les membres sur cette notion en répondant à leurs questions, en faisant part de votre expérience ou bien encore en partageant des contenus utiles à leur formation (vidéos Youtube, sites internet, etc.). Il faut être capable de faire ceci au moins à l'écrit et éventuellement à l'oral sur le Discord.\r\n\r\nLes Helpers peuvent également être ammenés à rédiger des supports de cours ou bien des énoncés d'exercices et de projets. Pour les cours il est possible d'organiser des sessions de cours orale sur le Discord. Pour les exercices il faut se porter garant d'être disponible si un membre requiert une correction d'exercice. Il est également possible d'organiser des sessions de travail en vocal où les membres pourront poser des questions concernants le cours et / ou les exercices.\r\n\r\n## Fonctionnement\r\n\r\nN'importe quel membre de Creascio qui se retrouve dans la description du rôle faite au dessus peut proposer sa \"candidature\" aux Modérateurs. Il est très important de communiquer un maximum avec les autres helpers sur vos souhaits, vos idées, vos initiatives, nous sommes une équipe avant tout.\r\n\r\nBien évidemment le rôle de Helper n'attribut aucune autorité particulière sur le serveur Discord ou ailleurs, tous les membres de Creascio sont sur un pied d'égalité.\r\n",i={presentation_creascio:t,devenir_helper:s},a="# Environnement de travail\r\n\r\n## Prérequis\r\n\r\n+\r\n\r\n## Introduction\r\n\r\nGit est un outil de gestion de projet, il permet de travailler à plusieurs sur le même projet tout en évitant le problème de versionning (Le fait d'avoir plein de versions différentes d'un projet).\r\n\r\nC'est aussi un outil pratique pour travailler seul étant donné que les données sont hébergées sur un cloud.\r\n\r\nDans ce tutoriel, nous allons apprendre les bases de l'utilisation de Git.\r\n\r\nPour nous faciliter la vie, nous allons utiliser une application liée à Git qui se nomme **GitHub Desktop** mais sachez que ce n'est pas la seule manière d'utiliser Git. En effet, vous pouvez aussi intéragir avec le cloud depuis le site de github, un terminal de commande ou d'autres applications clientes comme Fork.\r\n\r\n## Setup\r\n\r\nLiens utiles :\r\n\r\n+ [GitHub.com](https://github.com/)\r\n+ [GitHub Desktop download](https://desktop.github.com/)\r\n\r\nVous avez maintenant votre compte Github !\r\n\r\nEntrer le login et mot de passe de votre compte GitHub. Cliquer ensuite sur **Continue**\r\npuis sur **Finish**. Après cela, vous devriez tomber l'écran ci-dessous.\r\n\r\nVous avez tout installé, bravo !\r\n\r\n## Paramètrage\r\n\r\nComme de nombreux outils, GitHub Desktop proposent différentes options de configuration que ce soit pour son interface ou pour la façon dont il intéragit avec la version net.\r\n\r\n### Apparence\r\n\r\nSi vous voulez mettre un thème sombre, aller dans **File** (en haut à gauche) puis cliquer sur **Options**.\r\nUne nouvelle fenêtre apparaitra, cliquer sur **Appearance** puis sur **Dark**.\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Bases de Github]()\r\n",o="# Base de GitHub\r\n\r\n## Prérequis\r\n\r\n+ [Environnement de travail]()\r\n\r\n## Introduction\r\n\r\nGitHub est un outil de gestion de projets git. C'est une plateforme en ligne qui permet à ses utilisateurs de stocker leur contenu sur le cloud pour facilier le versionning et la collaboration entre les membres d'une équipe. Il propose de nombreux autres outils qui facilitent la conception et la gestion de projet.\r\n\r\n*Remarque : il existe d'autres plateformes du même genre mais nous utiliserons GitHub dans le cadre de ce cours.*\r\n\r\n## Architecture\r\n\r\nLorsque vous créez un projet Git, vous créez un **repository**.\r\n\r\nUn **repository** est divisé en **branches** qui peuvent stocker des contenus différents. Attention, les branches ne sont pas des sous dossiers ! Ce sont plutôt des bouts de projets ou bien des versions différentes d'un même projet.\r\n\r\nAu départ, il n'existe qu'une seule branche, la branche **main**, qui est la branche principale. Vous pouvez créer autant de branches que vous voulez. Il faut juste faire attention au nommage. Deux branches ne peuvent pas avoir le même nom.\r\n\r\nLa branche **main** est la branche où sera votre projet final. En règle général, on créé une branche par collaborateur (donc même si vous êtes seul vous vous créez une branche). Cela permet, dès qu'une fonctionnalité marche, de la mettre sur la branche **main**. De plus, si vous faites des bétises sur votre branche, vous aurez une sauvegarde sur la branche **main**.\r\n\r\n## Créer un repository\r\n\r\nDepuis l'accueil de Github, cliquez sur le bouton **New** pour créer un repository.\r\nIl faudra lui donner un nom, une potentielle description et choisir sa visibilité.\r\n\r\nVous pouvez ajouter un **README**. C'est un document que l'on utilise lorsque\r\nl'on met en publique son code. Le but étant d'expliquer votre projet et comment le faire marcher. Cela peut être un .txt ou un .md.\r\n\r\nVous pouvez aussi ajouter un **.gitignore** si vous faites du node.js, du unity ou d'autres\r\ntechnologies avec de lourdes bibliothèques.Un **.gitignore** est un fichier qui comme son nom l'indique ignorera toutes les bibliothèques. Ainsi sur le cloud, il n'y aura que votre code.\r\n\r\nLorsque vous créez une repository sur Github, il sera totalement vide. (sauf si vous avez créé un README ou un .gitignore)\r\n\r\n## Interface repository\r\n\r\nLorsque vous cliquez sur l'un de vos repository ou lorsque vous en créez un, l'interface devrait\r\nressembler à ça. (si ce n'est pas le cas cliquer sur **<> Code** dans le menu)\r\n\r\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/825436230095077419/unknown.png\" align=\"center\"/>\r\n\r\nComme vous pouvez le voir vous tombez directement sur le code présent dans le main. Si vous avez un README, il est affiché en dessous de vos fichiers.\r\n\r\nDepuis cette endroit, vous pouvez ajouter, modifier et supprimer des fichiers ou simplement naviguer dans vos fichiers.\r\n\r\nVous pouvez aussi cloner votre repository afin de l'importer sur votre ordinateur en\r\ntéléchargent un .zip. Pour cela cliquer sur le bouton vert **Code** puis **Download ZIP**\r\n\r\n## Paramétrage\r\n\r\nIl existe de nombreuses options de personnalisation de votre repository que ce soit pour en filtrer l'accès ou bien le contenu.\r\n\r\n### Inviter des collaborateurs\r\n\r\nUn collaborateur est quelqu'un qui a accès en lecture ET en écriture à votre code.\r\n\r\nPour ajouter des personnes à votre projet, aller dans **Settings** puis dans **Manage access**\r\npuis cliquer sur **Invite a collaborator** enfin entrer le pseudo de la personne que vous souhaitez ajouter. Celui-ci recevra un mail qui l'invitera sur le repository avec un lien.\r\n\r\nVous pouvez à tout moment supprimer un collaborateur.\r\n\r\n### Changer la visibilité\r\n\r\nDans **Settings** si vous revenez dans **Options** et que vous scrollez tout en bas,\r\nvous pouvez changer la visibilité d'un repository.\r\n\r\nUn repository publique permet à n'importe qui de voir le code et de le copier sur son ordinateur mais il ne peutpas être modifier. Un repository privé est totalement caché, on ne peux pas le voir ni le changer à mois d'etre un collaborateur.\r\n\r\n### Archiver\r\n\r\nDans **Settings** si vous revenez dans **Options** et que vous scrollez tout en bas,\r\nvous pouvez archiver un repository.\r\n\r\nLorsqu'un repository est archiver vous et vos collaborateur ne pouvez plus le modifier mais\r\nvous avez toujours accès au code en lecture. Cette action est reversible.\r\n\r\n### Supprimer\r\n\r\nDans **Settings** si vous revenez dans **Options** et que vous scrollez tout en bas,\r\nvous pouvez supprimer un repository.\r\n\r\nCette action est irreversible donc attention !\r\n\r\n## Exercices\r\n\r\n``(Q1) Création de projet``\r\n\r\n```txt\r\nCréez un repository appelé \"Test\", mettez en description \"Je suis un repository test\", mettez le en privé et ajouter un README.\r\n```\r\n\r\nAprès avoir cliqué sur ``<> Code`` voici ce que vous devriez avoir comme résultat :\r\n\r\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/828643996434956328/unknown.png\" align=\"center\"/>\r\n\r\n``(Q2) Faire un commit``\r\n\r\n```txt\r\nModifier le contenu de votre README : \"Premier projet git, c'est beau !\" (N'oubliez pas de commit)\r\nVous verrez son aperçu changer en revenant à la racine de votre branche\r\n```\r\n\r\n``(Q3) Ajouter un collaborator``\r\n\r\n```txt\r\nInviter \"Shiropetite\" dans votre repository.\r\n```\r\n\r\n``(Q4) Supprimer votre repository``\r\n\r\n```txt\r\nCe repository n'est pas très utile avec juste un README. Nous allons donc supprimer ce repository.\r\n```\r\n\r\n## Suivants\r\n\r\n+ [Bases de Github Desktop]()\r\n",u="# Base de GitHub Desktop\r\n\r\n## Prérequis\r\n\r\n+ [Base de Github]()\r\n\r\n## Introduction\r\n\r\nGithub Desktop est un outil de bureau en lien avec Github et qui permet la gestion de repository git.\r\n\r\n## Interface\r\n\r\nVoici à quoi ressemble l'interface de **Github Desktop**.\r\n\r\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/825439994806140998/unknown.png\"/>\r\n\r\n## Gestion de repository\r\n\r\nA droite, cliquer sur **Current repository**. Cela vous ouvrira un menu qui contient tout vos repository. Dans ce menu, cliquer sur le bouton **Add**. (Si vous n'avez jamais fait de projet Git, on vous proposera tout de suite d'ajouter un repository).\r\n\r\nLorsque vous cliquez sur **Add** trois choix s'offrent à vous :\r\n\r\n+ ``Clone repository`` : Copier votre projet Git sur votre pc (ou un repository public). Lorsque vous cliquez, cela vous ouvrira une fenêtre qui vous proposera soit de choisir parmi les repository auquels vous avez accès, soit d'insérer l'url ou nom d'un repository. Dans tout les cas vous devez aussi insérer l'endroit où vous voulez sauvegarder ce repository.\r\n\r\n+ ``Create new repository`` : Créer un repository de 0. Lorsque vous cliquez, cela vous ouvrira une fenêtre qui vous demandera le nom, la potentielle description, le chemin où vous voulez stocker votre projet et si vous voulez ajouter un README. Vous aurez en plus le choix d'ajouter un .gitignore (choisissez simplement le langage que vous allez utiliser).\r\n\r\n+ ``Add existing repository`` : Ajoutez un repository git déjà présent localement sur votre pc (il doit avoir le fichier .git). Lorsque vous cliquez, cela vous ouvrira une fenêtre qui vous demandera le chemin du repository sur votre pc.\r\n\r\n## gitignore\r\n\r\nUn .gitignore est un fichier qui permet au repository d'ignorer certains types de fichiers comme de lourdes bibliothèques (par exemple node-modules).\r\n\r\n## Gestion de branches\r\n\r\nIl est important de créer des branches afin de stocker plusieurs versions d'un même projet.\r\n\r\nPour créer un branche depuis Github Desktop, cliquer sur **Current branch**. Cela vous ouvrira un menu où vous pourrez naviguer de branches en branches.\r\n\r\nDepuis ce menu, cliquez sur **New branch** pour créer un nouvelle branche. Cela vous ouvrira une fenêtre qui vous demandera le nom de votre nouvelle branche (celui-ci ne doit pas être le même qu'une autre branche). Il vous demandera aussi, si vous n'êtes pas sur la branche **main**, depuis quel branche vous voulez créer la nouvelle. Si vous sélectionner **main**, il prendra alors la version du projet de main et la mettra sur votre branche. Si vous sélectionner une autre branche, il prendra la version de la branche sélectionner.\r\n\r\nN'oubliez pas une fois la branche créée de cliquer sur **Publish Branch**, sinon cette branche ne sera créé que localement sur votre pc.\r\n\r\nSi vous faites clic droit sur une des branches depuis le menu de navigation de branches, vous pourrez renommer une branche ou en supprimer une. ATTENTION, si vous le faites, n'hésiter pas à recloner votre projet et à demander à vos collaborateurs de le faire aussi. Sinon vous risquez de vous retrouver avec des branches fantômes.\r\n\r\nPour recloner un projet, supprimer le dossier de votre projet local puis aller sur Github Desktop et cliquer sur **Clone Again**. N'oubliez pas de **Push** vos changements AVANT sinon ils seront perdus !\r\n\r\n## Commit\r\n\r\nLorsque vous allez effectuer des changements sur vos fichiers, Github Desktop\r\nrempliera la gauche de l'écran comme ci-dessous.\r\n\r\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/825442599301152818/unknown.png\" />\r\n\r\nDans le screen, nous pouvons voir que 7 fichiers ont été modifié. Le carré jaune signifie que le contenu du fichier à changer, le carré vert signifie que le fichier a été créé ou ajouté et le carré rouge signifie que le fichier a été supprimé.\r\n\r\nEn cliquant sur l'un des fichiers, vous pouvez voir les modifications en détails. Les lignes surlignées en vert sont les lignes ajoutées et les lignes surlignées en rouge sont les lignes supprimées du fichier.\r\n\r\nLorsque vous voulez sauvegarder votre travail, vous devrez alors donner un nom à votre **Commit** dans le champs **Sumarry (required)**. Ce nom doit normalement représenter les changements que vous avez fait comme \"Update ... file\", celui-ci est obligatoire pour commit. Vous pouvez aussi ajouter un description. Une fois que vous avez donner un nom à votre commit cliquer sur **Commit to [nom-de-la-branche-actuelle]**.\r\n\r\nUn commit est une sauvegarde uniquement locale à votre pc.\r\n\r\n## Push, Pull, Fetch\r\n\r\nLe bouton **Fetch origin** permet de comparer votre version et celle du cloud, il détecte donc quand vous devez **push** ou **pull**.\r\n\r\nLorsque vous effectuez un commit le bouton qui se nommait à l'origine **Fetch origin** se transformera en **Push**. Cet action permet\r\nde mettre à jour votre commit sur le cloud de Git afin que vos collaborateurs voient vos changements.\r\n\r\nLorsque vos amis **push** quelque chose, vous pourrez alors cliquer sur **Fetch origin**, une fois cela fait ce bouton se transformera en **Pull** ce qui permettra de mettre à jour votre version depuis le cloud.\r\n\r\nLorsque vous voulez **push** un commit, il faudra vérifier que votre version est bien à jour avec le cloud et donc sivous n'avez pas à **pull** avant. Dans notre cas, Github Desktop vous préviendra.\r\n\r\n## Exercices\r\n\r\n``(Q1) Créer un projet``\r\n\r\n```txt\r\nCréer un projet sur Github Desktop, appeler le \"First-Project\" vous pouvez mettre la description que vous voulez.\r\n```\r\n\r\n``(Q2) Créer une branche``\r\n\r\n```txt\r\nCréer une branche qui vous nommerez \"develop\"\r\n```\r\n\r\n``(Q3) Faire un commit``\r\n\r\n```txt\r\nDans la branche develop, créer un fichier texte avec n'importe quel texte dessus. Puis appeler votre commit \"Create a text file\" puis commiter !\r\n```\r\n\r\n``(Q4) Push le commit``\r\n\r\n```txt\r\nEnfin n'oubliez pas de push !\r\n```\r\n\r\n## Suivants\r\n\r\n+ [Merge Request]()\r\n",l="# Merge Request\r\n\r\n## Prérequis\r\n\r\n+ [Bases Github Desktop]()\r\n\r\n## Introduction\r\n\r\nLors d'un projet en équipe, la possibilité de merge différentes branches de travail est cruciale pour pouvoir **contrôler** que l'apport de **nouvelles fonctionnalités** dans la version principale du projet se fait correctement.\r\n\r\n## Merge\r\n\r\nL'action de merge se fait toujours d'une branche vers une autre, on dit qu'on merge la branche A dans la branche B. Ainsi le contenu de la branche A **va se retrouver dans la branche B** et la branche A peut être supprimé ensuite.\r\n\r\nLa bonne pratique veut que dans un projet en groupe ou chacun travaillerait sur une ou plusieurs tâches précises, une fois ces tâches accomplies on merge leurs branche vers la branche principale **main** (ou master).\r\n\r\nUn merge peut entraîner des **conflits sur la branche qui reçoit les modifications** si les deux branches contenaient un fichier avec une **signature identique** (même nom et extension) et que la branche entrante n'est pas à jour avec la branche recevante.\r\n\r\n## Conflits\r\n\r\nEn fonction du type de conflits, Github Desktop peut proposer de prendre en charge la gestion du conflit en proposant d'utiliser **Visual Studio Code** (un éditeur évolué de Microsoft). L'éditeur vous permet alors de choisir entre :\r\n\r\n+ garder uniquement les modifications actuelles, c'est à dire l'état du fichier **avant merge**\r\n+ garder uniquement les modifications entrantes, c'est à dire **remplacer le contenu** du fichier\r\n+ garder toutes les modifications, l'éditeur va tenter de **fusionner les deux états** du fichier.\r\n\r\n*Remarque* : les conflits restent très rare vous n'avez pas a trop vous inquietez mais il faut savoir quoi faire quand on tombe dessus.\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+\r\n",c="# Pull Request\r\n\r\n## Prérequis\r\n\r\n+ [Merge Request]()\r\n\r\n## Introduction\r\n\r\nLes Pull Requests sont une fonctionnalité permettant à un collaborateur d'un repository git de demander l'avis d'un autre collaborateur, que l'on appelle un **reviewer**, avant de **merge une branche dans une autre**.\r\n\r\nC'est un outil très pratique pour permettre de détecter les coquilles éventuelles dans un code et cela permet également de maintenir l'équipe informé du travail effectué s'ils sont reviewer.\r\n\r\n## Utilisation\r\n\r\nPour pouvoir effectuer des Pull Requests sur un repository il faut au moins qu'il contienne **deux branches**. La branche depuis laquelle la requête sera émise et la branche qui va recevoir les modifications.\r\n\r\nUne fois que du contenu a été **Push** sur la version net d'une branche, il est possible via GitHub ou bien GitHub Desktop d'émettre une Pull Request. Il faut alors désigner la branche entrante et recevante du merge a effectuer.\r\n\r\nAprès cela on peut choisir quel(s) reviewer(s) seront alertés par notre requête. Ces derniers reçoivent une alerte par mail.\r\n\r\n## Reviewing\r\n\r\nUne fois informé un reviewer peut voir le contenu de la branche entrante et notamment le **contenu du Push** concerné. Il peut alors déposer des **commentaires** dans les fichiers et finalement **accepté ou refusé la demande de merge**.\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+\r\n",d={environnement_travail_git:a,bases_github:o,bases_github_desktop:u,merge_request:l,pull_request:c},p="# Environnement de travail\r\n\r\n## Prérequis\r\n\r\n+\r\n\r\n## Introduction\r\n\r\nDans ce cours nous allons apprendre à manipuler un compilateur\r\n\r\n## Setup\r\n\r\nPour ce cours vous aurez besoin d'un moyen de compiler, c'est-à-dire éxécuter votre programme.\r\n\r\nPour ce faire, nous allons utiliser (https://www.tutorialspoint.com/compile_c_online.php)\r\n\r\nVous pourrez écrire votre code dans le champ de gauche puis **Execute** pour obtenir le résultat dans la console à droite\r\n\r\nIl sera possible de passer des informations en entrée de votre programme dans l'onglet STDIN\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Types primitifs et Variables]()\r\n",m="# Types primitifs et Variables\r\n\r\n## Prérequis\r\n\r\n+ [Environnement de travail]()\r\n\r\n## Introduction\r\n\r\nGénéralement un programme informatique a pour but de manipuler des **données**.\r\n\r\nCes données peuvent être très diverses et sont représentées de manière tout aussi diverses selon les langages de programmation.\r\n\r\nDans la plupart des langages, on utilise des **types**, qu'on pourrait décrire comme des **catégories**, pour caractériser les données.\r\n\r\n## Types\r\n\r\nIl existe une multitude de types différents en fonction des langages de programmation mais certains se démarquent par le fait qu'ils sont présent dans tous les langages typés.\r\n\r\nOn appelle ces types des **types primitifs**. Ce sont les types les plus basiques. Ils sont rangés en plusieurs familles :\r\n\r\n+ Les types entiers : permettent de stocker un **nombre entier**\r\n\r\nCette famille est composée de : **int**, **byte**, **short** et **long** (**int** est le plus courant).\r\n\r\n+ Les types flottants : permettent de stocker un **nombre à virgule**\r\n\r\nCette famille est composée de : **float** et **double** (**float** est le plus courant).\r\n\r\n+ Le type caractère **char** : permet de stocker un caractère de la table **ASCII**. Cette table contient toutes les lettres, les chiffres et les symboles occidentaux.\r\n\r\n+ Le type booléen **boolean** : permet de stocker une information booléene, c'est-à-dire, une information à **deux** valeurs possibles (Ex : oui ou non, vrai ou faux, 1 ou 0, etc.).\r\n\r\n## Variables\r\n\r\nLes variables sont les éléments de notre code qui vont nous permettre de stocker des informations. Une variable possède un type ainsi qu'un nom.\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Affichage Console]()\r\n",v="# Affichage Console\r\n\r\n## Prérequis\r\n\r\n+ [Types primitifs et Variables]()\r\n\r\n## Introduction\r\n\r\n// TODO: à compléter\r\n\r\n## Contenu\r\n\r\n// TODO: à compléter\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Conditions Booléennes]()\r\n",b="# Conditions Booléennes\r\n\r\n## Prérequis\r\n\r\n+ [Affichage Console]()\r\n\r\n## Introduction\r\n\r\n// TODO: à compléter\r\n\r\n## Contenu\r\n\r\n// TODO: à compléter\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Boucles de Contrôle]()\r\n",h="# Boucles de Contrôle\r\n\r\n## Prérequis\r\n\r\n+ [Condition Booléennes]()\r\n\r\n## Introduction\r\n\r\n// TODO: à compléter\r\n\r\n## Contenu\r\n\r\n// TODO: à compléter\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+\r\n",f={environnement_travail_c:p,types_primitifs_variables:m,affichage_console:v,conditions_booleennes:b,boucles_controle:h},g="# Environnement de travail\r\n\r\n## Prérequis\r\n\r\n+ [Boucles de contrôle]()\r\n\r\n## Introduction\r\n\r\nJava est un langage de programmation orienté objet. Le but de ce langage est de produire un code facilement maintenable et modulable.\r\nCe langage est généralement utilisé dans des contextes client-serveur. Ils existent de nombreux langages et outils qui dérivent du Java.\r\nDans ce cours nous allons configurer notre environnement de travail Java.\r\n\r\n***TODO : à compléter***\r\n\r\n## Setup\r\n\r\nPour le bien de ce cours nous aurons d'abord besoin d'installer :\r\n\r\n+ une version du **JDK** (Java Development Kit) : [https://www.oracle.com/java/technologies/javase-downloads.html](https://www.oracle.com/java/technologies/javase-downloads.html)\r\n+ un environnement de travail : [https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)\r\n\r\nLe JDK est l'ensemble des outils nécessaire à notre machine pour pouvoir lire et exécuter du code Java.\r\nNous avons choisi Eclipse comme IDE pour ce cours mais il en existe d'autres, notamment [IntelliJ](https://www.jetbrains.com/fr-fr/idea/download/#section=windows)\r\n\r\n## Architecture\r\n\r\nPour coder en Java, on créer des **projets** qui sont stockés en tant que **dossier** sur votre PC. Les projets peuvent être arrangés dans ce qu'on appelle une **workspace**.\r\n\r\nChaque projet contient un dossier **src** qui est le dossier source qui contiendra votre code.\r\n\r\nLe dossier src peut contenir des sous dossiers appelés **packages**.\r\n\r\nEnfin on retrouve les **classes** qui sont le modèle de définition de nos objets comportant des **attributs**, c'est-à-dire des caractéristiques, et des **méthodes** qui décrivent leur comportement.\r\n\r\n## Créer un projet\r\n\r\nPour créer un projet Java sous Eclipse il faut tout d'abord lancer Eclipse sur une workspace existante ou bien en créer une nouvelle. Une fois dans votre workspace vous pouvez créer un projet :\r\n\r\n+ via le menu : **File > New > Java Project**\r\n+ via l'interface : **Clic droit > New > Java Project**\r\n\r\nIl vous sera ensuite demander de nommer votre projet, les autres options ne nous intéresse pas pour le moment et vous pouvez ensuite appuyer sur **Finish**.\r\n\r\nLe projet et son architecture sont alors créés, il ne vous reste plus qu'a créer :\r\n\r\n+ vos packages : **src (clic droit) > New > Package**\r\n+ vos classes : **package (clic droit) > New > Class**\r\n\r\n***TODO : à compléter avec des images***\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Classes et Attributs]()\r\n",q="# Classes et Attributs\r\n\r\n## Prérequis\r\n\r\n+ [Environnement de travail]()\r\n\r\n## Introduction\r\n\r\nUne classe Java est une **structure** permettant de décrire l'implémentation d'un **objet** dans notre programme. C'est le code de cette classe qui va nous permettre de décrire à quoi va ressembler notre objet à sa création et les actions possibles sur celui-ci.\r\n\r\nDans ce cous nous allons voir comment se construit un bloc classe ainsi que les objets et leurs caractéristiques.\r\n\r\n## Composition\r\n\r\nUne classe est un bloc de code qui va contenir toutes les informations concernant nos objets.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Toto {\r\n    // code goes here\r\n}\r\n```\r\n\r\nIci la classe Toto va nous permettre de pouvoir manipuler des objets de type `Toto`.\r\n\r\nPour décrire un objet, la classe est composée d'**attributs** et de **méthodes**.\r\n\r\n### Les attributs\r\n\r\nLes attributs sont des **variables** qui décrivent l'état d'un objet. Comme toute variable ils possèdent un **nom** et un **type de donnée**. Ils possèdent également une **visibilité** et éventuellement des **propriétés**.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nprivate int age;\r\n```\r\n\r\nIci on représente l'**age** d'un individu par un **nombre entier**. La variable s'appelle age et n'a pas encore de valeur. L'attribut est en private.\r\n\r\n### Nommage\r\n\r\nPar convention on nomme les classes en respectant le `PascalCase` (majuscule à chaque mot, pas d'espace ou de tiret).\r\nOn nomme les attributs et les méthodes en respectant le `camelCase` (majuscule à partir du deuxième mot, pas d'espace ou de tiret).\r\n\r\n### Types\r\n\r\nIls existent en java comme dans les autres langages deux catégories de type de donnée. Les types **primitifs** et les types **complexes**.\r\nLes types primitifs sont les suivants :\r\n\r\n+ **int** : pour stocker des nombres entiers\r\n+ **float** : pour stocker des nombres à virgule\r\n+ **char** : pour stocker des caractères (lettres, chiffres, symboles, etc.)\r\n+ **boolean** : pour stocker une information booléenne c'est à dire qui ne peut prendre que deux valeurs (ex : vrai ou faux, 0 ou 1)\r\n\r\nLes types complexes sont des types composés eux même d'autres types comme par exemple `String` ou notre classe `Toto`.\r\n\r\n## Les Tableaux\r\n\r\nTout comme dans de nombreux autres langages il est possible de créer des tableaux d'objets en java. Ces tableaux peuvent stocker des objets d'un type donné dans des cases mémoires. Un tableau à une taille non dynamique, on peut effectuer des actions simples dessus comme la récupération, l'ajout ou le retrait d'éléments.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Toto {\r\n    private int age;\r\n    private int[] notes;\r\n}\r\n```\r\n\r\n## Visibilité\r\n\r\nIl existe plusieurs niveau de visibilité pour les classes, les attributs ou bien encore les méthodes :\r\n\r\n+ **public** : visible et accessible par **tout le reste du programme**\r\n+ **private** : visible et accessible uniquement dans la **classe**\r\n+ **protected** : visible et accessible uniquement dans le **package**\r\n\r\n## Propriétés\r\n\r\nIl existe plusieurs propriétés pour les attributs ou bien encore les méthodes :\r\n\r\n+ **static** (pour les attributs) : la valeur de l'attribut est commune à toutes les instances de la classe.\r\n+ **static** (pour les méthodes) : la méthode peut être appelée sans recourir a un objet.\r\n+ **final** (pour les attributs) : la valeur de l'attribut ne peut pas être modifier après la première instanciation.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Chien {\r\n    private static final boolean estMoinsBienQueLesChats = true;\r\n}\r\n```\r\n\r\nIci l'attribut indique que pour n'importe quel chien, son attribut `estMoinsBienQueLesChats` est **toujours vrai** et il **ne peut pas être modifié**. :P\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Méthodes]()\r\n",x="# Méthodes\r\n\r\n## Prérequis\r\n\r\n+ [Classes et Attributs]()\r\n\r\n## Introduction\r\n\r\nLes méthodes représentent l'ensemble des comportements d'un objet ou bien encore les actions qu'il peut accomplir ou bien les changements que l'on peut effectuer sur celui-ci. Les méthodes sont des fonctions qui font partie du bloc classe tout comme les attributs.\r\n\r\n## Composition\r\n\r\nLes méthodes sont des **blocs d'instructions composés** d'un **prototype** suivi d'une ou plusieurs lignes de code.\r\nLe prototype d'une méthode suit cette structure : `visibilité propriété valeur_de_retour nom (paramètres_entrées)`\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic static int addition(int premierNombre, int deuxiemeNombre){\r\n    return premierNombre + deuxiemeNombre;\r\n}\r\n```\r\n\r\nLa méthode est `public`, elle est donc visible par tout notre code, elle est également `static` donc elle peut être appelée sans l'aide d'un objet.\r\nElle s'appelle `addition` et prend en entrée deux nombres : `premierNombre`et `deuxiemeNombre`.\r\nElle renvoie la somme de ces deux nombres sous la forme d'une valeur entière d'où `int`.\r\n\r\n## Le constructeur\r\n\r\nLe constructeur est une méthode particulière qui permet **d'instancier des objets** c'est à dire de les **initialiser** pour pouvoir ensuite les manipuler. Généralement un constructeur permet de **donner des valeurs aux attributs** du futur objet mais on peut s'en servir pour faire bien d'autres choses. Il se déclare toujours avec le **nom de la classe** en question. Comme toutes autres méthodes il peut prendre des paramètres d'entrées.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Chien {\r\n    private int age;\r\n    private String nom;\r\n\r\n    public Chien(int age, String nom){\r\n        this.age = age;\r\n        this.nom = nom;\r\n    }\r\n}\r\n```\r\n\r\nIci le constructeur de `Chien` nous permet d'attribuer des valeurs à l'`age` et au `nom` du chien que l'on souhaite créer. Le `this`fait référence à l'objet courant.\r\n\r\n*Remarque* : une classe peut contenir plusieurs constructeurs tant que ceux ci ne créer pas des objets similaires, c'est à dire qu'ils ne prennent pas les mêmes paramètres d'entrées\r\n\r\n### Objet courant\r\n\r\nDans le contexte d'une méthode java, l'objet courant est **un objet de la classe dans laquelle on se situe**. L'objet courant fait référence à **l'objet qui a appelé la méthode** ce qui nous permet d'accéder aux attributs de cet objet ou bien encore aux méthodes de la classe de cet objet.\r\n\r\n*Remarque : dans le cadre du constructeur, `this` fait référence à l'objet qu'on est en train de créer*\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Chien {\r\n    private int age;\r\n    private String nom;\r\n    private String race;\r\n\r\n    // créer un chien qui possède un nom, un age mais pas de race\r\n    public Chien(int age, String nom){\r\n        this.age = age;\r\n        this.nom = nom;\r\n    }\r\n\r\n    // créer un chien complet\r\n    // appelle le constructeur prenant seulement un age et un nom\r\n    // en paramètre et procède à l'instanciation\r\n    public Chien(int age, String nom, String race){\r\n        this(age, nom);\r\n        this.race = race;\r\n    }\r\n}\r\n```\r\n\r\n*Remarque* : l'exemple ci dessus sert a montrer la capacité de this a accéder a des attributs tout comme des méthodes. Dans les faits faire deux constructeurs ici n'est pas très utile\r\n\r\n## Getter et Setter\r\n\r\nLes getters et les setters sont des méthodes standardes de **manipulation d'attributs**. Les getters permettent de **récupérer une valeur** et les setters permettent de **modifier une valeur**. Par convention on nomme les getters `get[nomAttribut]` et les setters `set[nomAttribut]`.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Chien {\r\n    private int age;\r\n    private String nom;\r\n\r\n    public int getAge(){\r\n        // on récupère l'age du chien qui appelle la méthode\r\n        return this.age;\r\n    }\r\n\r\n    public void setNom(String nom){\r\n        // on modifie le nom du chien qui appelle la méthode\r\n        this.nom = nom;\r\n    }\r\n}\r\n```\r\n\r\n## ToString\r\n\r\nLa méthode toString est par convention la méthode que l'on utilise pour **afficher les informations d'un objet**.\r\nElle se construit généralement de cette façon :\r\n\r\n```java\r\npublic String toString(){\r\n    String s = // le message que l'on souhaite produire\r\n    return s;\r\n}\r\n```\r\n\r\n*Remarque* : la méthode toString permet uniquement de générer un message, pas de l'afficher !\r\n\r\nUne fonctionnalité importante de la chaîne de caractère et donc de la génération de message est la **concaténation**.\r\n\r\n### La concaténation\r\n\r\nLa concaténation est une propriété de la chaîne de caractère à pouvoir convertir des données de types différents en chaîne de caractères.\r\nPour cela on utilise le symbole `+`.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nString s = \"Bonjour je m'appelle \" + this.getNom()\r\n  + \" et j'ai \" + 12 + \" ans !\";\r\n```\r\n\r\n*Output* : `Bonjour je m'appelle Toto et j'ai 12 ans !`\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Programme Principal]()\r\n",j="# Programme Principal\r\n\r\n## Prérequis\r\n\r\n+ [Méthodes]()\r\n\r\n## Introduction\r\n\r\nLe main en java est une **méthode** qui représente le **programme principal**, c'est le bloc de code qui sera executé au lancement du projet.\r\nLe main est généralement dans **une classe à part**. On peut le générer facilement dans tous les frameworks.\r\nC'est dans celui-ci qu'on **instancie nos objets** et qu'on **intéragit avec l'utilisateur** via la console par exemple.\r\n\r\n## Instancier des objets\r\n\r\nOn doit instancier nos objets java pour pouvoir les manipuler. Pour cela on leur attribut de l'espace mémoire grâce à l'outil `new`.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nChien chien = new Chien(4, \"Pluto\");\r\n```\r\n\r\nIci on instancie un objet de type `Chien`. Le nom de variable de l'objet est `chien`. Le chien a 4 ans et il s'appelle Pluto.\r\n\r\n`chien.age : 4`\r\n`chien.nom : Pluto`\r\n\r\n*Remarque* : on doit également instancier un tableau avant d'en faire usage.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nint tab[] = new int[10] // 10 indique la taille du tableau\r\n```\r\n\r\n## Affichage console\r\n\r\nOn peut afficher des **chaînes de caractères** dans la console via la commande `print()` ou `println()` (la deuxième est la plus courante et permet de sauter une ligne après avoir afficher le contenu).\r\n\r\n**Exemple** :\r\n\r\n```java\r\nSystem.out.println(\"Hello World !\");\r\n```\r\n\r\n*Output* : `Hello world !`\r\n\r\n## Exercices\r\n\r\n### Exercice 1 : Tel chien, tel maître\r\n\r\nOn souhaite représenter un chien et son maitre. Tous les deux possède un nom. Le maitre ne peut posséder qu'un seul chien.\r\nLe maître doit pouvoir produire le message suivant : `Je m'appelle [nom_du_maitre] et voici mon chien [nom_du_chien] !`\r\n\r\n1. Identifiez les **objets** à implémenter et créez en conséquence les **classes** nécessaires. Identifiez ensuite les **attributs** de ces objets et implémentez les dans vos classes. Vous créerez également les **constructeurs**, **getters**, **setters** et autres méthodes nécessaires à la manipulation de vos objets.\r\n\r\n2. Développez un **programme principal** permettant de produire ce résultat :\r\n\r\n`Je m'appelle Mario et voici mon chien Pito !`\r\n\r\n`Je m'appelle Luigi et voici mon chien Malo !`\r\n\r\n`Je m'appelle Mario et voici mon chien Malo !`\r\n\r\nIl n'y a pas d'**intervention utilisateur** dans le programme principal. Celui ci doit uniquement **instancier des objets** et **afficher le résultat** potentiel de méthodes dans la console. Il ne doit pas y avoir d'**algorithmie** dans le programme principal !\r\n\r\n### Exercice 2 : Compte bancaire\r\n\r\nOn souhaite représenter un utilisateur et son compte bancaire. Chaque utilisateur possède un nom et un solde de compte (en euros).\r\nL'utilisateur doit pouvoir produire le message suivant : `Je m'appelle [nom_utilisateur] et j'ai [solde_compte] euros !`\r\n\r\nOn doit pouvoir débiter et créditer le compte. Le débit ne peut se faire que si la somme souhaitée est présente sur le compte. L'action de débiter ou créditer doit produire des messages de réussite ou d'erreur comme suit :\r\n\r\n+ Pour le crédit : `Compte de [nom_utilisateur] crédité de [somme] euros !`\r\n+ Pour le débit (succès) : `Compte de [nom_utilisateur] débité de [somme] euros !`\r\n+ Pour le débit (échec) : `Erreur : Impossible de débiter le compte de [nom_utilisateur] de [somme] euros, solde insuffisant :(`\r\n\r\n1. Identifiez les **objets** à implémenter et créez en conséquence les **classes** nécessaires. Identifiez ensuite les **attributs** de ces objets et implémentez les dans vos classes. Vous créerez également les **constructeurs**, **getters**, **setters** et autres méthodes nécessaires à la manipulation de vos objets.\r\n\r\n2. Développez un **programme principal** permettant de produire ce résultat :\r\n\r\n`Je m'appelle Clubbo et j'ai 10 euros !`\r\n\r\n`Erreur : Impossible de débiter le compte de Clubbo de 20 euros, solde insuffisant :(`\r\n\r\n`Compte de Clubbo crédité de 35 euros !`\r\n\r\n`Compte de Clubbo débité de 20 euros !`\r\n\r\n`Je m'appelle Clubbo et j'ai 25 euros !`\r\n\r\nIl n'y a pas d'**intervention utilisateur** dans le programme principal. Celui ci doit uniquement **instancier des objets** et **afficher le résultat** potentiel de méthodes dans la console. Il ne doit pas y avoir d'**algorithmie** dans le programme principal !\r\n\r\n### Exercice 3 : Tableau de chasse\r\n\r\nLe but de cet exercice est de reprendre les structures de données de l'exercice 1 et d'automatiser le processus de production de message pour un **groupe de maître et de chien**. On doit pouvoir stocker en mémoire 5 maîtres et 5 chiens différents et **pour chacun** des maîtres produire leur message respectif.\r\n\r\nDéveloppez un **programme principal** permettant de produire ce résultat :\r\n\r\n`Je m'appelle Tata et voici mon chien Dada !`\r\n\r\n`Je m'appelle Tete et voici mon chien Dede !`\r\n\r\n`Je m'appelle Titi et voici mon chien Didi !`\r\n\r\n`Je m'appelle Toto et voici mon chien Dodo !`\r\n\r\n`Je m'appelle Tutu et voici mon chien Dudu !`\r\n\r\n**Attention !** Votre programme ne doit contenir qu'**un seul appel à la console** (un seul `System.out.print()`) !\r\n\r\n## Suivants\r\n\r\n+ [Enumérations]()\r\n",y="# Enumerations\r\n\r\n## Prérequis\r\n\r\n+ [Programme Principal]()\r\n\r\n## Introduction\r\n\r\nLes énumerations, ou enum, permettent de créer une **famille de valeurs possibles pour représenter un concept**. L'enum n'est pas une classe et ces valeurs ne sont pas des objets à part entière. Un enum est une liste de constantes.\r\n\r\n## Usage\r\n\r\nOn peut se servir d'un enum pour des attributs ou des variables. Les enums sont utiles lorsque l'on sait que l'on va avoir des valeurs qui ne vont jamais changer comme les mois, les jours de la semaine ou encore les couleurs.\r\n\r\n## Composition\r\n\r\nUn enum contient essentiellement des valeurs possibles :\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic enum Couleur {\r\n    rouge, vert, bleu, jaune;\r\n}\r\n```\r\n\r\n```java\r\npublic class Peinture {\r\n    private int prix;\r\n    private Couleur couleur;\r\n}\r\n```\r\n\r\n```java\r\nPeinture p = new Peinture();\r\np.couleur = Couleur.rouge;\r\n```\r\n\r\nOn voit ici un cas concret d'utilisation d'un enum et comment accéder à une valeur de cet enum.\r\nIci l'enum est très simple et ne stocke que des valeurs mais il peut être plus complexe :\r\n\r\n```java\r\npublic enum Couleur {\r\n    rouge('r'),\r\n    vert('v'),\r\n    bleu('b'),\r\n    jaune('j');\r\n\r\n    private char symbole;\r\n\r\n    private Couleur(char symbole){\r\n        this.symbole = symbole;\r\n    }\r\n\r\n    public char getSymbole(){\r\n        return this.symbole;\r\n    }\r\n}\r\n```\r\n\r\nUn enum peut avoir des attributs et alors chaque valeur de l'enum aura des valeur pour ses attributs.\r\nSi un enum est paramétré alors on créé un constructeur privé capable d'instancier toutes les valeurs et éventuellement des getters et des setters.\r\n\r\n*Remarque* : le constructeur n'est utile que pour ajouter de nouvelles valeurs (ici de nouvelles couleurs), on n'a pas besoin d'instancier les valeurs d'un enum car ce ne sont pas des objets mais des constantes !\r\n\r\nLes méthodes de la classe Enum sont les suivantes :\r\n\r\n+ `values()` : renvoie toutes les valeurs de l'enum sous forme de tableau\r\n+ `ordinal()` : renvoie l'index de la valeur appelante dans la liste de valeurs\r\n+ `valueOf(String)` : retourne la valeur correspondante à la chaine de caractère si la valeur existe\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Bibliotheques]()\r\n",L="# Bibliothèques\r\n\r\n## Prérequis\r\n\r\n+ [Enumérations]()\r\n\r\n## Introduction\r\n\r\nEn Java comme dans bon nombre d'autres langages de programmation, il est possible d'exploiter du **code externe** a votre programme afin d'eviter de recoder des\r\nfonctionnalitées qui existe deja. Cela se fait via l'**importation de bibliothèques** en plus de la bibliothèque java standard. Les bibliothèques contiennent des **classes** avec leurs attributs et leurs méthodes.\r\n\r\n## Importer des bibliothèques\r\n\r\nIl y a une syntaxe précise à respecter pour importer une bibliothèque dans un projet : `[nomDeLaBibliotheque].[nomDuPackage].[nomDeLaClasse];`\r\n\r\nLes imports se situe toujours au dessus du bloc classe qui souhaite les utiliser.\r\n\r\nAinsi, pour importer la classe `ArrayList` on écrit : `import java.util.ArrayList;`\r\n\r\nIci `java` fait référence à la bibliothèque java standard. On recherche la classe `ArrayList` se trouvant dans le package `util`.\r\n\r\nOn peut importer tout le contenu d'une bibliothèque ou d'un package en utilisant *.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nimport java.util.*;\r\n```\r\n\r\nCet import permet de récupérer toutes les classes contenu dans le package `util` de la bibliothèque `java`.\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n### Suivants\r\n\r\n+ [Collection et Iterable]()\r\n",C="# Collection et Iterable\r\n\r\n## Prérequis\r\n\r\n+ [Bibliotheques]()\r\n\r\n## Introduction\r\n\r\nIl existe de nombreuses façon d'organiser des données autrement qu'avec des tableaux en java. L'architecture des bibliothèques proposant des solutions est très vaste et nous allons la parcourir de manière succinte. Tout se base sur Collection et Iterable qui sont des interfaces (pas besoin de savoir ce qu'est une interface pour le moment) donnant leurs propriétés aux classes qui nous intéresse dans ce cours.\r\n\r\nIl existe trois grandes familles d'iterable c'est à dire de structure de données pouvant être parcouru : Les List, Les Queue et Les Set. Toutes ces classes sont ce qu'on appelle des Collections.\r\n\r\nAvant tout il faut savoir que les tableaux ainsi que les iterables peuvent être parcouru via une boucle particulière appelée le forEach\r\n\r\n## forEach\r\n\r\nLe forEach en java est une boucle très similaire au for et qui permet de parcourir des structures de données de manière plus intuitive.\r\n\r\nIl se construit de cette façon : `for(Object o : [structure])`\r\n\r\nLe paramètre de gauche indique le type d'objet que l'on souhaite chercher dans la structure. Il est important car une structure peut contenir différents types d'objets.\r\nLe paramètre de droite est la variable qui représente la structure à parcourir.\r\n`o` représente l'élement courant dans le parcours de la liste.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nPage[] livre = new Page[10];\r\nfor (Page page : livre){\r\n    page.ecrire(\"Je suis une super page !\");\r\n}\r\n```\r\n\r\nIci on parcourt le tableau de pages `livre`. Pour chaque page contenu dans `livre` on écrit dedans `Je suis une super page !`\r\n\r\n*Remarque* : le forEach permet de parcourir toutes les structures de données que nous allons voir dans ce cours.\r\n\r\n## List\r\n\r\nUne List est une séquence d'objets qui peut être organisée comme on le souhaite. On peut y ajouter et en retirer des éléments, les doublons sont autorisé ainsi que les objets vide. On peut récupérer un élément grâce à son index tout comme on le ferait dans un tableau.\r\nLa différence majeure entre une liste et un tableau est que la liste est **dynamique** c'est à dire qu'elle adapte **automatiquement** sa **taille** en fonction des actions faite sur celle-ci (ajout et retrait d'éléments notamment).\r\nLorsqu'on instancie une liste on doit préciser le type d'objet qu'elle va contenir de cette façon :\r\n\r\n```java\r\nList<Chien> chiens = new ArrayList<>();\r\n```\r\n\r\nLa liste `chiens` pourra donc stocker des objets de type `Chien`.\r\n\r\n`List` n'est pas un objet on doit donc utiliser des implémentations de List pour pouvoir la manipuler. L'implémentation la plus courante de la liste est l'ArrayList.\r\n\r\n*Remarque* : une liste ne peut stocker que des objets, si on souhaite stocker des variables de types primitifs on utilisera les classes correspondantes (ex : Integer pour int, Character pour char, etc.)\r\n\r\n### ArrayList\r\n\r\nL'ArrayList est l'une des implémentations de la liste la plus commune. En mémoire elle est équivalente à un **tableau dyamique**.\r\nCela implique qu'il est très **peu couteux d'accéder à un élément** dans la liste mais il est **plus compliqué d'ajouter ou de retirer des éléments** car ces deux actions ont des répercussions sur le tableau qui doit etre recrée afin d'avoir la bonne taille.\r\n\r\nVoici quelques méthodes de cette classe :\r\n\r\n+ `add(Object o)` : ajoute `o` à la liste si son type correspond\r\n+ `remove(Object o)` : enlève une occurence de `o` de la liste s'il s'y trouve\r\n+ `get(index i)` : récupère l'objet à l'index i (/!\\ plante si la liste n'est pas aussi grande /!\\)\r\n+ `size()` : retourne la taille de la liste (nombre d'éléments dans la liste)\r\n+ `contains(Object o)` : indique si une occurence de `o` se trouve dans la liste\r\n+ `isEmpty()` : indique si la liste est vide (si la taille de la liste est égale à 0)\r\n\r\n*Remarque* : il existe d'autres méthodes, celles-ci sont les plus communéments utilisées\r\n\r\n**Exemple** :\r\n\r\n```java\r\nPage sommaire = new Page(\"Ceci est un sommaire\");\r\nList<Page> livre = new ArrayList<>();\r\nif (livre.isEmpty()){\r\n    page.add(sommaire);\r\n}\r\n```\r\n\r\n### Instancier une liste\r\n\r\nInstancier le contenu d'une liste peut être un travail fastidieux et peu élégant au niveau des lignes de code. Voici quelques astuces pour ajouter rapidement du contenu à une liste fraichement créée :\r\n\r\n#### Usage d'un tableau\r\n\r\nLa classe `Arrays` contient de nombreuses méthodes de manipulation de tableau dont une qui nous est utile dans le cas de figure d'une instanciation de liste : `asList()`\r\n\r\n**Exemple** :\r\n\r\n```java\r\n// le tableau de nombre [1, 2, 3] est transformé en liste\r\n// pour instancier numbers\r\nArrayList<Integer> numbers = Arrays.asList(1, 2, 3);\r\n```\r\n\r\n*Remarque* : comme nous venons de parler de Arrays il peut etre bon de savoir qu'il existe d'autres méthodes dans cette classe notamment la méthode `sort()` qui, en fonction des éléments stockés dans le tableau, permet de le trier dans l'ordre croissant.\r\n\r\n#### Appel de méthodes discrètes\r\n\r\nOn peut appeler des méthodes lors de la création d'un objet ce qui permet de le modifier de manière plus élégante et plus rapide (en termes de lignes de code).\r\n\r\n**Exemple** :\r\n\r\n```java\r\nList<Integer> numbers = new ArrayList<>() {{\r\n    add(1);\r\n    add(2);\r\n    add(3);\r\n}}\r\n```\r\n\r\n*Remarque* : on ne rentrera pas dans le détail ici de comment fonctionne le bloc de code ci-dessus car cela implique des notions trop avancées pour le moment. Cependant maintenant vous savez que ceci est possible :^)\r\n\r\n### Manipuler une liste avec Collections\r\n\r\nLa classe `Collections` permet de manipuler des listes et autres stuctures de données similaires (donc des collections), voici une liste non exhaustive de ses fonctionnalités :\r\n\r\n+ `sort(list)` : tri le contenu de la liste par ordre croissant (ne fonctionne que si la comparaison est possible)\r\n+ `shuffle(list)` : mélange le contenu de la liste (change l'ordre des éléments de manière aléatoire)\r\n+ `max(collection)` : retourne la plus grande valeur de la collection (si la comparaison est possible)\r\n+ `min(collection)` : retourne la plus petite valeur de la collection (si la comparaison est possible)\r\n+ `addAll(collection, elements)` : permet d'ajouter `elements` à la collection, `elements` peut être un tableau ou bien les éléments listés un par un\r\n\r\n*Remarque* : il existe beaucoup d'autres méthodes plus situationnelles dans la classe Collections.\r\n\r\n*Remarque* : pour les méthodes ne marchant que si la comparaison est possible, il faut entendre qu'elles marchent automatiquement si on compare des types primitifs mais pas si on compare des types complexes auquel cas il faudra préciser un moyen de comparaison que nous verrons plus tard\r\n\r\n### LinkedList\r\n\r\nLa LinkedList est une autre implémentation de la liste une peu moins commune. Elle représente en mémoire une **chaîne** ou une **file** de données. Plus préciséement une liste doublement chaînée c'est à dire que chaque élément stocké dans la liste est **relié à son précédent et à son suivant** ainsi il est très **peu couteux d'ajouter ou de retirer des éléments** mais il est **plus compliqué d'accéder à un élément** de la liste car on doit la parcourir depuis le départ pour arriver à la destination.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nList<Personne> fileAttente = new LinkedList<>();\r\nfileAttente.addFirst(mario);\r\nfileAttente.removeLast();\r\n```\r\n\r\nOn verra ici les méthodes particulières à cette implémentation, la LinkedList possède les méthodes que l'on retrouve dans l'ArrayList en plus des siennes.\r\n\r\n+ `addFirst(Object o)` et `addLast(Object o)` : ajoute `o` au début ou à la fin de la liste respectivement (des équivalents pour `remove`existent)\r\n+ `getFirst()` et `getLast()` : retourne le premier ou le dernier élément de la liste respectivement\r\n+ `push(Object o)` et `pop()` : ajoute un élément au départ ou bien retire le premier élément respectivement\r\n\r\n*Remarque*  : `push` et `pop` sont des acquisitions des implémentations de listes LIFO (Last In First Out) en Java comme le Stack. Ainsi on préfère utiliser la LinkedList au Stack ou encore au Queue que nous allons voir à présent sauf dans des cas bien précis.\r\n\r\n*Remarque* : il existe d'autres implémentations de List mais nous ne les verrons pas ici\r\n\r\n## Queue\r\n\r\nLa Queue est une file de donnée, on l'utilise pour stocker des éléments de manière temporaire avant traitement. Elle n'offre aucune fonctionnalité particulière par rapport aux listes mais certaines de ces implémentations spécifiques peuvent être utile notamment la PriorityQueue\r\n\r\n### PriorityQueue\r\n\r\nLa PriorityQueue est une file de donnée dont l'ajout de donnée provoque un tri automatique. La PriorityQueue détecte un élément de comparaison entre les objets qui la composent et les trie. Autrement elle ne possède aucune fonctionnalité particulière\r\n\r\n*Remarque* : Il existe d'autres implémentations de Queue mais nous ne les verrons pas ici\r\n\r\n## Set\r\n\r\nLe Set est une structure de donnée similaire à la List mais il n'autorise pas de doublon. On ne peut pas récupérer un élément d'un Set, seulement ajouter, retirer et faire des vérifications. Un Set peut dont être utile dans les cas où l'on souhaite stocker des informations en interdisant les doublons.\r\n\r\n*Remarque* : les Set sont des structures particulières et rarement utile, à utiliser avec précaution.\r\n\r\n## Exercices\r\n\r\n### Exercice 1 : Le Grand Hotel\r\n\r\nOn souhaite représenter l'ensemble des chambres d'un hotel de luxe ainsi que sa clientèle. L'hotel n'a besoin que de connaitre le nom de ses clients.\r\nL'hotel possède une infinité d'étages, chaque étage possède au maximum 2 chambres. Une chambre possède un numéro de chambre unique.\r\nUne chambre peut accueillir jusqu'a 3 personnes, elle peut également être vide.\r\n\r\nOn doit pouvoir générer pour chaque chambre le message suivant : `Chambre n°[numero_chambre] - Etage n°[numero_etage] - Clients ([noms_clients])`\r\n`noms_clients` se construit de cette façon : `Toto Titi Tutu` si la chambre contient 3 clients se nommant ainsi. Si la chambre est vide `noms_clients` = `vide`\r\n\r\n1. Identifiez les **objets** à implémenter et créez en conséquence les **classes** nécessaires. Identifiez ensuite les **attributs** de ces objets et implémentez les dans vos classes. Vous créerez également les **constructeurs**, **getters**, **setters** et autres méthodes nécessaires à la manipulation de vos objets.\r\n\r\n2. Développez un **programme principal** ou l'appel de la méthode `toString()` de la classe `Hotel` permet de produire ce résultat :\r\n\r\n`Chambre n°1 - Etage n°1 - Clients (Toto)`\r\n\r\n`Chambre n°2 - Etage n°1 - Clients (vide)`\r\n\r\n`Chambre n°3 - Etage n°2 - Clients (Titi Tata Tutu)`\r\n\r\n## Suivants\r\n\r\n+ [Interface Utilisateur]()\r\n",E="# Interface Utilisateur\r\n\r\n## Prérequis\r\n\r\n+ [Collection et Iterable]()\r\n\r\n## Introduction\r\n\r\nUn scanner est un objet permettant de récupérer des informations provenant d'un flux. En java il existe différents types de flux :\r\n\r\n+ le flux de **sortie** : la console\r\n+ le flux d'**entrée** : la saisie clavier\r\n+ le flux d'**erreur** : réservé aux messages d'erreurs\r\n+ les fluxs **externes** : un fichier, une requête API ou HTTP, etc.\r\n\r\nOn peut positionner un scanner sur certains de ces flux pour en récupérer le contenu. Ici c'est uniquement le flux d'entrée qui va nous intéresser.\r\n\r\nUn objet de type Scanner s'instancie de cette manière :\r\n\r\n```java\r\nScanner sc = new Scanner(System.in);\r\n```\r\n\r\nIci on vient de créer un Scanner s'appelant `sc` sur le flux d'entrée `System.in`.\r\n\r\nOn peut ensuite récupérer des informations depuis le scanner. La récupération de la saisie possède des règles qui varie selon la méthode de récupération. De manière général un scanner possède un **separator** qui indique où **découper les informations**. De base le séparator est l'**espace** ou le white space.\r\n\r\nLorsqu'on appelle une méthode de Scanner, l'utilisateur est alors ammené à écrire dans la console. Le fait d'appuyer sur la touche `Enter` exécute la méthode de récupération. Ce fonctionnement diffère dans le cadre de la récupération d'information depuis une autre source qu'un utilisateur.\r\n\r\nVoici différentes méthodes pour récupérer des informations :\r\n\r\n+ `next()` : permet de récupérer une chaîne de caractères. Attention ! Il ne doit pas y avoir d'espace à l'intérieur de la chaîne\r\n+ `nextLine()` : permet de récupérer la saisie entière sans faire de distinction sur les types de données récupérés.\r\n+ `hasNext()` : retourne vrai ou faux en fonction de si le scanner a encore du contenu à lire dans sa source.\r\n+ `nextInt()` : permet de récupérer une valeur entière. Attention ! Plante si la saisie clavier ne contient pas de nombre.\r\n\r\n*Remarque* : Tout comme pour les int, il existe des méthodes pour récupérer tous les types primitifs.\r\n\r\n## Construire une interface utilisateur\r\n\r\nUne des règles d'or de la programmation est de ne jamais faire confiance à l'utilisateur. Il faut coder en partant du principe que l'utilisateur ne vas pas nous donner l'information que l'on recherche. Ainsi il existe de nombreuses astuces pour que notre programme soit parés à la majeure partie des éventualités. Le but est d'éviter à tout prix que le programme plante.\r\n\r\nLes deux notions importantes d'une interface utilisateur sont que :\r\n\r\n+ on **sait à l'avance** ce qu'on attend de l'utilisateur\r\n+ on souhaite recevoir la bonne information et ainsi on devra **retenter jusqu'a l'obtenir**\r\n\r\nEn sachant ça, deux boucles de contrôles nous seront très utiles et fonctionnent de pairs :\r\n\r\nLe **while** nous permet via l'utilisation d'une condition booléenne de \"bloquer\" l'utilisateur jusqu'a ce qu'il est indiqué l'information souhaitée.\r\n\r\nLe **switch** nous permet d'indiquer le **comportement de notre application** en fonction du résultat de la requête auprès de l'utilsateur. Il permet aussi de gérer facilement le cas ou **l'utilisateur s'est trompé**.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nScanner sc = new Scanner(System.in);\r\nBoolean isValid = false; // le choix de l'utilisateur est il bon ?\r\n\r\nwhile (!isValid){\r\n    // print au lieu de println pour que l'utilisateur écrive\r\n    // sur cette ligne\r\n    System.out.print(\"Tapez 1 pour les mails, Tapez 2 pour les SMS >\");\r\n    // on récupère une chaîne et pas un int car on veut éviter de\r\n    // faire planter le programme\r\n    String choix = sc.next();\r\n    switch(choix){\r\n        case \"1\" :\r\n            System.out.println(\"MAILS\");\r\n            // la saisie de l'utilisateur correspond à un cas valide\r\n            isValid = true;\r\n            break; // on ne veut rentrer que dans un seul case !\r\n        case \"2\" :\r\n            System.out.println(\"SMS\");\r\n            isValid = true;\r\n        default :\r\n            System.out.println(\"Saisie invalide\");\r\n            // isValid reste a false car la saisie n'est pas valide\r\n            // on repart au début du while\r\n            break;\r\n    }\r\n}\r\nSystem.out.println(\"Fin du programme\");\r\n```\r\n\r\n*Output* :\r\n\r\n`Tapez 1 pour les mails, Tapez 2 pour les SMS >`*salade*\r\n\r\n`Saisie invalide`\r\n\r\n`Tapez 1 pour les mails, Tapez 2 pour les SMS >`*2*\r\n\r\n`SMS`\r\n\r\n`Fin du programme`\r\n\r\n*Remarque* : le code au dessus est seulement un exemple qui peut et doit être adapté en fonction de la situation\r\n\r\n## Fichier externe\r\n\r\nDans cette partie nous allons voir comment utiliser le Scanner pour **lire** des données **textuelles** dans un fichier externe.\r\n\r\nTout d'abord il faut récupérer le fichier de texte grâce à un objet de type File.\r\n\r\nOn doit instancier un objet de type File avec en paramètre le chemin (relatif ou absolu) du fichier. Le plus simple est, si vous le pouvez, de placer le fichier à la racine du projet c'est à dire au même niveau que le dossier `src`. Le scanner doit ensuite être placé sur le fichier.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nFile file = new File(\"toto.txt\");\r\nScanner sc = new Scanner(file);\r\n// tant que le scanner n'est pas arrivé au bout du fichier\r\nwhile(sc.hasNext()){\r\n    // affiche le fichier ligne par ligne\r\n    System.out.println(sc.nextLine());\r\n}\r\n```\r\n\r\n*Remarque* : bien qu'on ne puisse pas écrire dans un fichier avec un Scanner il y a bien d'autres façons de traiter un fichier que dans cet exemple.\r\n\r\n## Exercices\r\n\r\n### Exercice 1 : Rézo zocial\r\n\r\nOn souhaite créer un réseau social miniature. Chaque utilisateur pourra soit :\r\n\r\n+ Entrer son nom pour pouvoir ensuite écrire un post\r\n+ Entrer le nom d'un autre utilisateur pour voir ses posts, à la condition que l'utilisateur existe\r\n\r\n*Remarque* : il n'est pas question ici de faire une sauvegarde des utilisateurs et de leurs posts entre plusieurs éxécutions du programme, tout sera géré en interne.\r\n\r\nLe but de cet exercice est de créer une interface utilisateur qui permettent au maximum de couvrir les erreurs de saisie.\r\n\r\n***TODO : à compléter***\r\n\r\n## Suivants\r\n\r\n+ [Valeurs Aléatoires]()\r\n",S="# Valeurs Aléatoires\r\n\r\n## Prérequis\r\n\r\n+ [Interface Utilisateur]()\r\n\r\n## Introduction\r\n\r\nDans un programme informatique, on peut très souvent être ammené à utiliser des valeurs aléatoires ou plutôt pseudo-aléatoire. Il y'a plusieurs façons de générer des valeurs aléatoires en Java. Nous allons en voir deux.\r\n\r\n## Random\r\n\r\nLa classe `Random` permet de générer des valeurs aléatoires dans différents types primitifs. On doit cependant indiqué la borne maximale dans le cas d'une génération de nombre.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nRandom rand = new Random();\r\nint i = rand.nextInt(100);\r\n```\r\n\r\nLa valeur de `i` est comprise entre 0 et 99.\r\n\r\n## Math.random\r\n\r\nLa méthode `random()` de la classe `Math` permet de générer une valeur aléatoire entre 0 et 1.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nfloat rand = Math.random();\r\n```\r\n\r\nOutput : `0.5568515217910215`\r\n\r\n```java\r\nint rand = (int) (Math.random() * 100) + 1;\r\n```\r\n\r\nDans l'exemple ci-dessus on voit apparaître une nouvelle notion : `(int)`. C'est ce qu'on appelle un cast.\r\n\r\n## Le cast\r\n\r\nLe cast est une fonctionnalité de l'orienté objet qui permet de transformer un objet d'un type en un autre si la conversion est possible, ce qui est loin d'être toujours le cas.\r\nC'est une fonctionnalité qu'on peut être ammené à utiliser lorsqu'on manipule des bibliothèques car nombre d'entres elles utilisent leur propre système d'objets et des conversions sont parfois nécessaire pour articuler un programme.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nint resultat = (int) 12.7 + 15.3669; // = 28.0669 -> 28\r\n```\r\n\r\nLe résultat de cette ligne est normalement un nombre à virgule. Ici le cast en int va tronquer le résultat pour qu'il puisse être stocké dans la variable `resultat`.\r\n\r\n## Exercices\r\n\r\n### Exercice 1 : Envoie 'AMOUR' au 8 12 12\r\n\r\nOn souhaite créer une ~~arnaque~~ fonctionnalité permettant à un utilisateur d'entrer son nom ainsi que celui de son grand amour pour que l'application lui indique son taux de compatibilité avec celui ou celle qu'il ou elle aime. L'application peut délivrer différents résultats en fonction du taux de compatibilité :\r\n\r\n+ Pour 0% : `[user1] et [user2] = bagarre`\r\n+ Entre 1% et 25% : `[user1] et [user2] = osef`\r\n+ Entre 26% et 50% : `[user1] et [user2] = potes à la compote`\r\n+ Entre 51% et 75% : `[user1] et [user2] = BFF`\r\n+ Entre 76% et 99% : `[user1] et [user2] = amour`\r\n+ Pour 100% : `[user1] et [user2] = muy caliente`\r\n\r\nDéveloppez une interface utilisateur permettant de récupérer le nom des deux utilisateurs et de produire un message aléatoire (l'amour c'est plus ce que c'était...)\r\n\r\n## Suivants\r\n\r\n+ [Dictionnaires]()\r\n",I="# Dictionnaires\r\n\r\n## Prérequis\r\n\r\n+ [Valeurs Aléatoires]()\r\n\r\n## Introduction\r\n\r\nLes dictionnaires ou Map sont des structures de données plus complexes qui permettent **d'associer une clé à une valeur**. Il ne peut pas y avoir plusieurs fois la même clé cependant. Cette structure fonctionne de manière quasi identique à un vrai dictionnaire pour faire une comparaison pratique.\r\nNous allons voir dans ce cours l'implémentation la plus courante de Map en java : `HashMap`.\r\n\r\n## HashMap\r\n\r\nUne HashMap est un dictionnaire qui hache les données qu'il contient c'est à dire qu'il **crypte les données** pour les rendre **plus courtes en mémoire** et accélerer la recherche dans le dictionnaire. L'**ordre de parution** des valeurs du dictionnaire n'est pas garanti lors d'un parcours. On peut parcourir la liste des clés d'un dictionnaire, ou bien la liste des valeurs ou bien encore une liste des associations clé-valeur.\r\n\r\n*Remarque* : un dictionnaire ne peut stocker que des objets que ce soit les clés ou les valeurs, ainsi si l'on souhaite stocker des valeurs de types primitifs on utilisera les classes correspondantes (ex : Integer pour int, Boolean pour boolean, Character pour char, etc.)\r\n\r\nVoici une liste de quelques méthodes utiles :\r\n\r\n+ `put(key, value)` : ajoute une association `key` - `value` dans le dictionnaire, si `key` existe déjà alors elle sera écrasée avec la nouvelle valeur\r\n+ `get(key)` : retourne la valeur associé à la clé `key`\r\n+ `remove(key)` : supprime la clé ainsi que sa valeur du dictionnaire\r\n+ `size()` : retourne le nombre d'association clé-valeur dans le dictionnaire (ou plus simplement le nombre de clés)\r\n+ `clear()` : supprime le contenu du dictionnaire\r\n\r\nPour parcourir le dictionnaire on utilise :\r\n\r\n+ `keySet()` : permet de parcourir la liste de clé du dictionnaire\r\n+ `values()` : permet de parcourir la liste de valeurs du dictionnaire\r\n\r\n**Exemple** :\r\n\r\n```java\r\n// on créé un dictionnaire qui associe un caractère a un mot\r\nMap<Character, String> dico = new HashMap<>();\r\n// on ajoute la clé 'a' associé au mot 'abricot' qui sera sa valeur\r\ndico.put('a', \"abricot\");\r\ndico.put('c', \"creascio\");\r\n\r\nfor (Character c : dico.keySet()){\r\n    // pour chaque clé dans le dico on affiche cette clé et\r\n    // la valeur associée\r\n    System.out.println(\"Key :\" + c + \" value : \" + dico.get(c));\r\n}\r\n```\r\n\r\n*Remarque* : comme les listes en java sont des objets, un dictionnaire peut avoir une liste en tant que clé ou bien en tant que valeur. Cela permettrait de mieux représenter notre dico de l'exemple précédent :\r\n\r\n```java\r\n// on créer une liste de mots\r\nList<String> motsEnC = new ArrayList<>() {{\r\n    // on ajoute directement quelques mots qui commencent\r\n    // par la lettre c\r\n    add(\"clubby\");\r\n    add(\"clubbo\");\r\n}};\r\nMap<Character, ArrayList<String>> dico = new HashMap<>();\r\n// on ajoute l'association entre la lettre c et notre liste\r\n// de mot qui commence par c dans le dictionnaire\r\ndico.put('c', motsEnC);\r\n```\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Mode Debug]()\r\n",w="# Mode Debug\r\n\r\n## Prérequis\r\n\r\n+ [Dictionnaires]()\r\n\r\n## Introduction\r\n\r\nLorsque notre programme plante ou ne produit pas le résultat attendu sans que l'on puisse facilement trouver la cause du problème, une bonne pratique est de lancer le programme en **mode débug**. Ce mode possède plusieurs fonctionnalités permettant de faire progresser le programme **pas à pas** c'est à dire commande par commande.\r\n\r\n## Setup\r\n\r\nAvant de lancer le programme on doit déterminer des potentiels **points d'arrêts** dans notre code où le compilateur va s'arrêter et laisser la main à l'utilisateur pour poursuivre comme il le souhaite. Généralement on place des points d'arrêts avant **les instructions qui pourraient poser problème**. Si vous n'avez aucune idée d'où provient le problème vous pouvez placer le point d'arrêt **en haut du main**.\r\n\r\n*Remarque* : il existe d'autres points que les Breakpoints (points d'arrêts) mais leur usage spécifique ne sera pas couvert dans ce cours.\r\n\r\nIl faut ensuite lancer le programme en mode debug ce qui lance une configuration particulière.\r\n\r\nSur Eclipse, pour lancer le programme en mode débug on peut faire ceci :\r\n\r\n+ **Clic droit > Debug As > Java Application**\r\n+ **Icone d'insecte dans la barre d'actions > Debug As > Java Application**\r\n\r\nUne fois le programme lancé de cette manière le compilateur ammène le programme jusqu'au premier point d'arrêt rencontré dans l'exécution.\r\n\r\n*Remarque* : si le programme nécessite des entrées utilisateurs avant ou apres un point d'arrêt il faudra les remplir comme normalement dans la console.\r\n\r\n## Mécaniques de debug\r\n\r\nL'utilisateur à ensuite à sa disposition différentes fonctionnalités :\r\n\r\n+ Step Into (F5) : redirige vers le code appelant (la méthode généralement)\r\n+ Step Over (F6) : passe à la ligne suivante sans rentrer dans le code\r\n+ Step Return (F7) : retourne dans le bloc de code précédent\r\n\r\n*Remarque* : La fonctionnalité la plus utile reste le Step Into pour faire un parcours en profondeur de l'execution de votre programme.\r\n\r\nEn fonction de votre IDE vous pouvez également avoir une vue debug qui permet de voir différentes informations comme l'état de la pile d'execution ou bien encore la valeur de chaque variable de votre programme au fil du temps.\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Tests Unitaires]()\r\n",A="# Tests Unitaires\r\n\r\n## Prérequis\r\n\r\n+ [Mode Debug]()\r\n\r\n## Introduction\r\n\r\nLa phase de test est une partie non négligeable de tout projet informatique. Les tests unitaires permettent de s'assurer du bon fonctionnement des méthodes de notre programme.\r\n\r\n## Setup\r\n\r\nPour mettre en place des tests unitaires en Java, on utilise la bibliothèque **JUnit**. On peut rédiger un test unitaire dans un fichier prévu à cet effet appelé un **JUnit Test Case**. La création d'un test case entraîne généralement l'ajout de la bibliothèque JUnit dans le projet java. Généralement on place les test case dans un package de test à part. On peut aussi les créer dans un dossier de test en dehors du dossier src.\r\n\r\nPour créer un test case (sous Eclipse) : **Clic droit > New > JUnit Test Case**\r\n\r\nPour chaque classe que l'on souhaite tester, on créer un test case qui va contenir les tests nécessaires à la **couverture** des méthodes de la classe. La **couverture** d'une classe représente tous les cas de figure possible lors de l'appel des méthodes de la classe.\r\n\r\nUn test case est alors une classe composée de tests qui sont des méthodes. Lors de l'exécution, chaque test indiquera s'il est validé ou non. S'il n'est pas validé une raison sera indiquée.\r\n\r\n*Remarque* : un test case peut donc avoir des attributs\r\n\r\nOn utilise les annotations java pour faire marcher les tests case. Les annotations sont des indications au compilateur sur la nature du bloc de code annoté.\r\n\r\n**Exemple** : on va ici créer une fausse classe à tester suivi du test case correspondant\r\n\r\n```java\r\n// une classe exemple\r\npublic class Toto {\r\n\r\n    private int note;\r\n\r\n    public Toto(){\r\n        this.note = 0;\r\n    }\r\n\r\n    public int addition(int nombre1, int nombre2){\r\n        return nombre1 + nombre2;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n// par convention on nomme la classe de test [nom_classe_a_tester]Test\r\npublic class TotoTest {\r\n\r\n    @Test // l'annotation indique que la méthode en dessous est un test\r\n    // ce test va permettre de couvrir la méthode addition\r\n    public void additionTest(){\r\n\r\n    }\r\n}\r\n```\r\n\r\n## Construction\r\n\r\nUn test unitaire est divisé en trois parties :\r\n\r\n+ l'initialisation ou l'arrangement est la section du test ou on instancie les objets donc on aura besoin (pas obligatoire)\r\n+ l'action est la section qui contient les appels de méthodes ou les modifications de valeurs éventuelles (pas obligatoire)\r\n+ l'assertion est la section qui contient la vérification que l'on souhaite faire pour valider le fonctionnement de la méthode\r\n\r\n## Les assertions\r\n\r\nLorsqu'on veut tester des méthodes, on utilise les assertions pour comparer le résultat d'un morceau de code au résultat attendu. Il existe de nombreuses assertions pour tester différents cas de figure. Toutes sont des méthodes qui nécessite le résultat attendu et/ ou la variable, l'objet, la méthode a tester\r\n\r\nVoici quelques exemples d'assertions :\r\n\r\n+ `assertEquals()` : validé si les deux valeurs sont égales\r\n+ `assertNotEquals()` : validé si les deux valeurs ne sont pas égales\r\n+ `assertTrue()` : validé si la condition booléenne testée est vraie\r\n+ `assertFalse()` : validé si la condition booléenne testée est fausse\r\n\r\n*Remarque* : ces assertions sont les plus simples et les plus communes, il en existe bien d'autres\r\n\r\n**Exemple** :\r\n\r\nUn exemple d'usage des assertions\r\n\r\n```java\r\npublic class TotoTest {\r\n\r\n    @Test\r\n    public void totoTest(){\r\n        Toto toto = new Toto();\r\n        // la note de toto a été initialisée à 0 dans le constructeur,\r\n        // le test est validé\r\n        // Premier paramètre = resultat attendu\r\n        // Deuxième paramètre = élément a tester\r\n        assertEquals(0 , toto.note)\r\n        // une autre façon de tester la même égalité\r\n        assertTrue(toto.note == 0)\r\n    }\r\n}\r\n```\r\n\r\nUn exemple plus complet\r\n\r\n```java\r\npublic class TotoTest {\r\n\r\n    @Test\r\n    public void createTotoTest(){\r\n        // Arrange\r\n        Toto toto = new Toto();\r\n\r\n        // Act\r\n        toto.setNote(12);\r\n\r\n        // Assert\r\n        assertNotEquals(0, toto.getNote());\r\n    }\r\n\r\n    @Test\r\n    public void additionTest(){\r\n        // Assert\r\n        assertEquals(13, addition(6, 7));\r\n    }\r\n}\r\n```\r\n\r\n## Les annotations\r\n\r\nIl existe d'autres annotations qui peuvent être utiles lors de l'implémentation de tests unitaires. Certains bloc de code peuvent être éxecuté à des moments précis durant l'éxecution du test case.\r\n\r\nVoici une liste d'annotations utiles et courantes :\r\n\r\n+ `@BeforeAll` : le bloc de code est exécuté **une fois** au début de l'exécution avant tous les autres tests\r\n+ `@BeforeEach` : le bloc de code est exécuté **avant chaque** test\r\n+ `@AfterAll` : le bloc de code est exécuté à la toute fin après tout les tests.\r\n+ `@AfterEach` : le bloc de code est exécuté **après chaque** test\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class TotoTest(){\r\n\r\n    private Toto toto;\r\n\r\n    @BeforeAll\r\n    public static void init(){\r\n        // instancie l'objet toto avant qu'il soit utilisé ailleurs\r\n        toto = new Toto();\r\n    }\r\n\r\n    @BeforeEach\r\n    public void reset(){\r\n        // remet la note de toto à 0 comme lors de sa création\r\n        // pour éviter les confusions entre plusieurs tests\r\n        toto.setNote(0);\r\n    }\r\n\r\n    @Test\r\n    public void test1(){\r\n        assertEquals(0, toto.getNote());\r\n        // // avant de finir le test on modifie la note de toto\r\n        toto.setNote(12);\r\n    }\r\n\r\n    public void test2(){\r\n        // le test valide, même si on a changé la note de Toto à 12\r\n        // dans le test précédent, la méthode reset a été appelée\r\n        // avant test2 et ainsi la note de toto a été remise à 0\r\n        assertEquals(0, toto.getNote());\r\n\r\n        // juste pour montrer que pourquoi pas\r\n        toto.setNote(addition(1, 5));\r\n        assertFalse(0, toto.getNote()); // le test valide\r\n    }\r\n}\r\n```\r\n\r\n## Test paramétré\r\n\r\nGrâce aux annotations, il est possible de créer des tests paramétrés qui pourront vérifier la même assertion pour plusieurs valeurs entrantes de manière plus élégante.\r\nPour cela on utilise l'annotation `@ParameterizedTest` à la place de `@Test`.\r\n\r\nIl faut ensuite pouvoir donner la liste source des valeurs à tester.\r\n\r\n+ Si le test ne prend qu'un seul paramètre d'entrée on utilise `@ValueSource`\r\n+ Si le test prend plusieurs paramètres d'entrée on utilise `@CsvSource`\r\n\r\n**Exemple** :\r\n\r\nOn part du principe qu'on a coder une méthode `multiplication(int, int)` qui permet de multiplier deux nombres entiers passés en entrée.\r\n\r\n```java\r\npublic class CalculTest {\r\n\r\n    @ParameterizedTest\r\n    @ValueSource(ints = { 1, 2, 3, 4 })\r\n    public void multiplicationTest1(int arg){\r\n        // on multiplie un par un les valeur s de ints par 0\r\n        // et on stocke le tout dans resultat\r\n        int result = multiplication(0, arg);\r\n        // on s'assure que multiplier par 0 rend toujours bien 0\r\n        assertEquals(0, result);\r\n    }\r\n\r\n    @ParameterizedTest\r\n    // un couple de valeur \"x,y,z\" tel que x * y = z\r\n    @CsvSource({ \"1,1,1\", \"2,2,4\", \"3,4,12\"})\r\n    public void multiplicationTest2(int firstNumber, int secondNumber,\r\n       int expectedResult){\r\n        int result = multiplication(firstNumber, secondNumber);\r\n        // on s'assure qu'on obtient le résultat attendu\r\n        assertEquals(expectedResult, result);\r\n    }\r\n}\r\n```\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n### Suivants\r\n\r\n+ [Gestion des Exceptions]()\r\n",P="# Gestion des Exceptions\r\n\r\n## Prérequis\r\n\r\n+ [Tests unitaires]()\r\n\r\n## Introduction\r\n\r\nLes exceptions font partie intégrante du développement d'un programme. Elle indique le type et la provenance d'une erreur durant l'exécution du programme. Heuresement on peut se prévenir de ces erreurs et les gérer correctement pour ne pas que le programme plante.\r\n\r\n## Les exceptions\r\n\r\nLes exceptions sont des classes très simples qui stocke un **message** ou bien une **trace** qui sera inscrite dans le flux d'erreur de la console lorsque l'exception sera levée (lorsqu'elle sera provoquée). Elle stocke aussi la ou les **causes** potentielles qui pourraient se faire lever l'erreur. Si une exception est levée, un objet de sa classe sera créé puis traiter par le compilateur.\r\nPour gérer les exceptions dans notre programme on doit pouvoir les **lever nous même** si besoin, les **propager** puis les **capturer**.\r\n\r\nToutes exceptions possèdent les méthodes suivantes :\r\n\r\n+ `getMessage()` : retourne le message correspondant à l'erreur\r\n+ `printStackTrace()` : affiche l'exception ainsi que l'état de la pile d'exécution au moment de son appel\r\n\r\n### Lever une exception : throw\r\n\r\nOn peut lever une exception dans le bloc de code d'une méthode en utilisant le mot clé `throw`.\r\nLorsque le contenu du code d'une méthode risque de lever une exception, on doit l'indiquer dans son prototype grâce au mot clé `throws`.\r\nOn construit donc la méthode de cette façon :\r\n\r\n**Exemple** :\r\n\r\n```java\r\n// on indique quelles exceptions peuvent être levées\r\npublic float division(int diviseur, int dividende) throws ArithmeticException {\r\n    // le cas d'utilisation de la méthode qui va poser problème\r\n    if (diviseur == 0){\r\n        // on créer un objet de type ArithmeticException qui va levé une\r\n        // exception avec le message passé en paramètre\r\n        throw new ArithmeticException(\"On ne peut pas diviser par 0 !\");\r\n    }\r\n    return dividende / diviseur; // fonctionnement normal de la méthode\r\n}\r\n```\r\n\r\nAinsi on peut prévenir les risques de notre programme et provoquer des erreurs qui pourront être gérées plus tard. On peut également être ammené à créer nos propres erreurs. Par convention l'objet créer doit contenir \"Exception\" dans son nom.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class ErreurSaisieException extends Exception {\r\n\r\n    public ErreurSaisieException(){\r\n        super();\r\n    }\r\n\r\n    public ErreurSaisieException(String message){\r\n        super(message);\r\n    }\r\n}\r\n```\r\n\r\nC'est de cette façon qu'on peut créer une exception customisée. Nous n'expliquerons pas dans ce cours comment cela fonctionne concrétement car cela implique des notions que nous verrons plus tard. Il faut savoir que l'on peut lever des exceptions existantes avec des messages customisés (comme dans l'exemple division) donc l'usage d'exception customisée est très spécifique et peu recommandé pour les débutants.\r\n\r\n### Capturer les exceptions : try catch finally\r\n\r\nUne fois que notre programme est capable de levé des exceptions, on doit pouvoir les capturer si besoin ou alors faire en sorte que le code s'exécute correctement si tou va bien. Pour tout cela on utilise le bloc de code `try catch finally`.\r\n\r\nLe bloc `try` contient les appels de méthodes **suceptibles de lever des exceptions**\r\nLa clause `catch` contient le code à executer **si une exception à préciser est levée**\r\nLe bloc `finally` contient le code qui sera executé **peu importe si une exception a été levée ou non** (facultatif)\r\n\r\n**Exemple** :\r\n\r\n```java\r\ntry {\r\n    uneMethodeRisquée();\r\n}\r\ncatch(ErreurSaisieException e){\r\n    System.err.println(e.getMessage());\r\n}\r\ncatch (IllegalArgumentException e){\r\n    e.printStackTrace();\r\n}\r\nfinally {\r\n    resetApplication();\r\n}\r\n```\r\n\r\nSi les méthodes invoquées dans le bloc `try` peuvent lever plusieurs méthodes on pourra soit traiter toutes les exceptions de la même façon dans un **multicatch** ou bien comme ici avec plusieurs catchs. Les clauses catch **ne devrait pas contenir d'algorithmie** et seulement des appels de méthodes liés aux exceptions.\r\n\r\n**Exemple** : pour un multicatch\r\n\r\n```java\r\ntry {\r\n    uneMethodeRisquée();\r\n}\r\ncatch (IllegalArgumentException | NumberFormatException | ArithmeticException\r\n  | IOException | FileNotFoundException | IndexOutOfBoundsException e) {\r\n    e.printStackTrace();\r\n}\r\n```\r\n\r\n*Remarque* : même si cela peut paraître lourd, il ne faut pas hésitez à utiliser un bloc try catch même pour un seul appel de méthode lorsque cela est nécessaire.\r\n\r\n### Exercices\r\n\r\n+\r\n\r\n### Suivants\r\n\r\n+ [Abstration et Héritage]()\r\n",k="# Abstraction et Héritage\r\n\r\n## Prérequis\r\n\r\n+ [Gestion des Exceptions]()\r\n\r\n## Introduction\r\n\r\nLe but principal du java est de pouvoir produire du code **le plus généraliste possible** pour pouvoir **faciliter la maintenance** et les **modifications ultérieures**. Ainsi on essaye toujours de coder en partant du **cas le plus général** vers **les spécialisations éventuelles** de ce cas en gardant toujours en tête que le but est de supprimer la **redondance de code**. Cette façon de coder entraîne une notion de **hiérarchie entre les classes** d'où la notion d'héritage.\r\n\r\n## Principe\r\n\r\nL'héritage repose sur une relation **\"mère-fille\"** entre les classes cette relation est representée par le mot clé `extends` dans la signature d'une classe.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Chien extends Animal {\r\n    // code goes here\r\n}\r\n```\r\n\r\nCe qu'il faut comprendre ici c'est que la classe `Chien` hérite de la classe `Animal`. Un chien **EST UN** animal. En java une classe ne peut hériter au maximum que d'**une seule autre classe**. Ce n'est pas le cas en C++ par exemple où l'on peut créer des liens d'héritages multiples entre les classes. Cependant les relations sont **infinies en profondeur**, c'est à dire qu'une classe peut hérité d'une classe qui elle même hérite d'une autre classe et ainsi de suite sans limite.\r\n\r\nUn lien d'héritage implique que la classe fille **possède les attributs de la classe mère** sans pour autant avoir besoin de les respécifier. La classe fille peut également **faire appel aux méthodes de la classe mère**. Pour faire appel à des éléments de la classe mère on utilise le mot clé `super`. `super` représente l'**objet père** la où `this` représente l'objet courant.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Animal {\r\n    private String nom;\r\n    private int age;\r\n\r\n    public Animal(String nom, int age){\r\n        this.nom = nom;\r\n        this.age = age;\r\n    }\r\n\r\n    public void manger(){\r\n        System.out.println(\"MIAM MIAM\")\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class Chien {\r\n    private String race;\r\n\r\n    // le chien a implicitement un nom et un age car c'est un animal\r\n    public Chien(String nom, int age, String race){\r\n        super(nom, age); // fait appel au constructeur de la classe mère\r\n        this.race = race;\r\n    }\r\n\r\n    public void manger(){\r\n        super.manger(); // fait appel à la méthode manger de la classe mère\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic static void main(String[] args){\r\n    Chien doggo = new Chien(\"paf\", 4, \"Labrador\");\r\n    doggo.manger();\r\n}\r\n```\r\n\r\n*Output* :\r\n\r\n`MIAM MIAM`\r\n\r\n## Abstraction\r\n\r\nLorsqu'on développe nos classes représentant le cas général et ses spécifications, la norme veut que le cas général serve de **point de concentration des éléments en commun des spécifications** (attributs et méthodes) mais il n'a pas pour but d'être instancier lui même. Si on reprend l'exemple du dessus, dans la nature il y a des chiens, des chats, des oiseaus mais pas des animaux. Aucun animal dans la nature n'est de l'espèce Animal.\r\n\r\nDans ce cas on utilise l'abstraction pour **forcer à créer une relation d'héritage** entre les classes. Ainsi une classe peut être abstraite mais aussi ces méthodes. Pour cela on utilise le mot clé `abstract`.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic abstract class Animal {\r\n    private String nom;\r\n    private int age;\r\n\r\n    // une classe abstract peut quand même avoir des constructeurs qui\r\n    // seront utilisés via super dans les classes filles\r\n    public Animal(String nom, int age){\r\n        this.nom = nom;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getNom(){\r\n        return nom;\r\n    }\r\n\r\n    public abstract void crier(); // a spécifier dans les classes filles\r\n}\r\n```\r\n\r\nIci la classe `Animal` est abstract ce qui veut dire qu'**on ne peut pas directement créer des objets** de type `Animal`, on est contraint à créer une spécification de la classe `Animal`. Pour ce qui est des méthodes, `getNom()` est un getter sur un attribut de la classe ainsi peu importe quel objet l'appelera elle fera toujours la même chose que ce soit pour un `Animal` ou pour un objet d'une classe fille. Pour ce qui est de la méthode `crier()` comme un objet de type `Animal` ne peut pas exister, cet objet n'a pas de cri et ainsi la classe `Animal` n'a pas de raison de spécifier cette méthode. Ainsi la méthode est `abstract` et ne possède pas de **corps de méthode**. La spécification sera à la charge des classes filles car chaque espèce d'animal a son propre cri.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Chien extends Animal {\r\n    private String race;\r\n\r\n    public Chien(String nom, int age, String race){\r\n        super(nom, age);\r\n        this.race = race;\r\n    }\r\n\r\n    public void crier(){\r\n        System.out.println(\"OUAF !\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic static void main (String[] args){\r\n    // on créé un animal de type Chien\r\n    Animal toto = new Chien(\"Polux\", 7, \"Skye Terrier\");\r\n}\r\n```\r\n\r\nIci on voit la puissance de l'héritage qui permet d'éviter la redondance de code pour les attributs et les méthodes.\r\n\r\n## Réduire les relations\r\n\r\nEn structurant notre code avec l'usage des classes mères plutot que leurs spécification on peut **réduire les dépendances entre les classes** de notre code et le rendre plus durable.\r\n\r\n**Exemple** :\r\n\r\nOn veut représenter une animalerie qui peut contenir tous types d'animaux, la mauvaise façon de faire serait la suivante :\r\n\r\n```java\r\npublic class Animalerie {\r\n    private List<Chien> chiens;\r\n    private List<Chat> chats;\r\n    private List<Oiseau> oiseaux;\r\n}\r\n```\r\n\r\nSi on est ammené un jour à rajouter de nouveaux types d'animaux ou en supprimer certains. Il va falloir **modifier le code de toutes les classes qui utilises ces types d'animaux** (ici il n'y a que `Animalerie` mais le nombre peut très vite grimper). Ainsi pour réduire les dépendances on préfère utiliser les types les plus généraux si possible, comme ceci :\r\n\r\n```java\r\npublic class Animalerie {\r\n    private List<Animal> animaux;\r\n}\r\n```\r\n\r\nIci, en partant du principe que les classes `Chien`, `Chat` et `Oiseau` héritent de la classe `Animal`, la liste `animaux` peut contenir des objets de tous ces types. Si à l'avenir on rajoute ou bien on enlève des spécifications de la classe `Animal`, le code des classes utilisant des animaux n'aura pas besoin d'être modifié pour continuer de fonctionner... c'est magique !!\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Polymorphisme]()\r\n",z="# Polymorphisme\r\n\r\n## Prérequis\r\n\r\n+ [Abstraction et Héritage]()\r\n\r\n## Introduction\r\n\r\nLorsqu'un programme contient des liens d'héritages, cela implique un lien entre les **implémentations des méthodes de la classe mère dans les classes filles**. Le polymorphisme est une mécanique de l'orientée objet qui permet d'encore plus réduire la **redondance** et la **dépendance entre les classes**.\r\n\r\n## Principe\r\n\r\nPour utiliser le polymorphisme entre les méthodes d'une classe mère et d'une classe fille, il faut que les méthodes possèdent **le même prototype** c'est à dire le même nom, les mêmes paramètres d'entrée **dans le même ordre** et la même valeur de retour (la première ligne doit être identique).\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Animal {\r\n    public void cri(){\r\n        System.out.println(\"owo\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class Chien extends Animal {\r\n    @Override\r\n    public void cri(){\r\n        System.out.println(\"ouaf\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class Chat extends Animal {\r\n    @Override\r\n    public void cri(){\r\n        System.out.println(\"miaou\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class Cochon extends Animal {\r\n\r\n}\r\n```\r\n\r\n```java\r\npublic static void main(String[] args){\r\n    Animal clubbo = new Animal();\r\n    Animal pito = new Chien();\r\n    Animal malo = new Chat();\r\n    Animal porky = new Cochon();\r\n\r\n    clubbo.cri();\r\n    pito.cri();\r\n    malo.cri();\r\n    porky.cri();\r\n}\r\n```\r\n\r\n*Output* :\r\n\r\n`owo`\r\n\r\n`ouaf`\r\n\r\n`miaou`\r\n\r\n`owo`\r\n\r\nL'annotation `@Override` indique au compilateur de préférer la version de la méthode appelée plutot qu'une autre. Lorsqu'une classe ne contient pas de spécification de la méthode appelée, comme par exemple la classe `Cochon`, la version de la méthode la plus proche dans la hierachie sera utilisée, ici la version de la classe mère `Animal`.\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Abstraction et Interface]()\r\n",T="# Abstraction et Interface\r\n\r\n## Prérequis\r\n\r\n+ [Polymorphisme]()\r\n\r\n## Introduction\r\n\r\nIl existe d'autres moyens que les liens d'héritage pour rendre durable du code java. On peut établir des **contrats** avec les classes pour qu'elles implémente des **comportements**. Cela se fait au travers des **interfaces**.\r\n\r\n## Principe\r\n\r\nUne interface n'est pas une classe, elle contient uniquement les **prototypes des méthodes** qui devront être implémenté par la classe qui signe le contrat. On représente ce contrat par le mot clé `implements`.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic interface Machine {\r\n    public void démarrer();\r\n    public void veille();\r\n    public void arrêter();\r\n}\r\n```\r\n\r\n```java\r\npublic class Ordinateur implements Machine {\r\n    private int id;\r\n\r\n    public Ordinateur(int id){\r\n        this.id = id;\r\n    }\r\n\r\n    @Override\r\n    public void démarrer(){\r\n        System.out.println(\"Démarrage en cours...\");\r\n    }\r\n\r\n    @Override\r\n    public void veille(){\r\n        System.out.println(\"Mise en veille...\");\r\n    }\r\n\r\n    @Override\r\n    public void arrêter(){\r\n        System.out.println(\"Arrêt en cours...\");\r\n    }\r\n}\r\n```\r\n\r\nDans cet exemple, la classe `Ordinateur` est contrainte à spécifier les méthodes de l'interface `Machine`.\r\n\r\nUne interface ne peut pas contenir d'attributs, **on ne peut pas instancier des objets du type de l'interface**. Une classe peut implémenter **plusieurs interfaces à la fois**. Une classe peut `extends` une classe et en même temps `implements` une interface. Une interface peut permettre de réduire les dépendances également :\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Usine {\r\n    // cette liste peut contenir des objets de n'importe\r\n    // quel type qui implémente l'interface machine (ex: ordinateur, etc.)\r\n    private List<Machine> machines;\r\n}\r\n```\r\n\r\n```java\r\npublic static void main(String[] args){\r\n    // on ne peut pas instancier d'objet de type Machine mais on peut\r\n    // s'en servir pour instancier des implémentations\r\n    Machine machine = new Ordinateur(42);\r\n}\r\n```\r\n\r\n## Héritage ou Interface ?\r\n\r\nL'héritage et l'interface sont des mécanismes qui **ne sont pas incompatibles**, ils ne répondent juste pas aux mêmes problématiques. On choisira l'héritage lorsqu'on a besoin de **représenter un cas général** donc les propriétés pourront être spécifiées dans des classes filles. On choisira l'interface pour décrire **les comportements abstraits** d'une catégorie d'objets.\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+\r\n",O={environnement_travail_java:g,classes_attributs:q,methodes:x,programme_principal:j,enumerations:y,bibliotheques:L,collection_iterable:C,interface_utilisateur:E,valeurs_aleatoires:S,dictionnaires:I,mode_debug:w,tests_unitaires:A,gestion_exceptions:P,abstraction_heritage:k,polymorphisme:z,abstraction_interface:T},D="# Bases de Javascript\r\n\r\n## Introduction\r\n\r\nLe Javascript est un langage de programmation permettant de construire des applications logicielles ou web. C'est un langage proche du script extrêmement polyvalent qui est utilisé dans de nombreux domaines. Il est également la base de nombreux frameworks et autres outils spécialisés. Le but de ce cours est de vous présenter le fonctionnement de ce langage pour pouvoir ensuite l'exploiter dans un contexte d'application web.\r\n\r\n## Structure\r\n\r\n### Types\r\n\r\nLe Javascript est un langage faiblement typé. Ils ne sont pas requis pour la manipulation de donnée mais il existe quand même des types de base :\r\n\r\n+ ``number`` : nombre entier, relatif, etc.\r\n+ ``string`` : chaîne de caractères\r\n+ ``boolean`` : information booléenne\r\n+ ``null, undefined`` : variable vide\r\n+ ``symbol``\r\n\r\n### Variables\r\n\r\nLes variables fonctionnent comme dans n'importe quel autre langage de programmation, elles permettent de stocker une information, une valeur, pour pouvoir être traiter. Il y a plusieurs façon d'instancier une variable :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nvar prenom = 'titi' // string\r\nlet nom = 'toto' // string\r\nlet age = 2 // number\r\nvar sexe = true // boolean\r\nconst vérité = 'Les chats sont mieux que les chiens'\r\n```\r\n\r\nIl existe de subtiles différences entre les mots clés `var` et `let`, les deux permettent d'instancier des variables et il est préférables d'utiliser `let` la majeure partie du temps. Le but de cet exemple était de présenter les possibilités mais nous n'allons pas nous attarder sur une vraie comparaison.\r\n\r\nLe mot clé `const` permet d'instancier une constante, c'est à dire qu'une fois que cette variable se verra attribuer une première fois une valeur, cette valeur ne pourra plus être changée par la suite. Il est très fréquent d'utiliser des constantes en Javascript car on manipule souvent des références mais nous y reviendrons.\r\n\r\n*Remarque : les fins d'instructions n'ont pas besoin d'être représentées en Javascript, le `;` n'est pas obligatoire*\r\n\r\n*Remarque : les opérandes entre les données de type number (+, -, /, etc) restent inchangées.*\r\n\r\n*Remarque : Il est possible de définir des strings avec les simples `''` ou les doubles cotes `\"\"`. Le contexte web utilise les doubles cotes dans certains contextes et il est donc possibles d'utiliser des simples cotes à l'intérieur de doubles cotes (Ex : machin()=\"'phrase'\")*\r\n\r\n### Tableaux\r\n\r\nEn Javascript les tableaux sont eux aussi non typés et peuvent contenir tous types de valeurs.\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet membres = ['titi', 'toto', 'tutu']\r\n\r\nlet premierMembre = membres[0] // 'titi'\r\n```\r\n\r\nLes tableaux possèdent leur propre logique :\r\n\r\n+ `length` : un attribut qui indique la taille du tableau c'est à dire le nombre d'éléments qu'il contient\r\n+ `push(element)` : ajoute un élément à la fin du tableau\r\n+ `unshift(element)` : ajoute un element au début du tableau\r\n+ `pop()` : retire le dernier élément du tableau\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet membres = []\r\nmembres.push('titi') // membres = ['titi']\r\nmembres.unshift('toto') // membres = ['toto', 'titi']\r\nlet taille = membres.length // 2\r\nmembres.pop() // membres = ['toto']\r\n```\r\n\r\n### Objets\r\n\r\nLes objets Javascript permettent de réunir plusieurs informations ou caractéristiques derrière une seule variable par association clé-valeur. Ils sont décrits par le biais de blocs qui contiennent leurs attributs :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet chat = {\r\n  nom: 'pito',\r\n  age : 2\r\n}\r\n\r\nlet nomDuChat = chat.nom // 'pito'\r\nlet ageDuChat = chat['age'] // 2\r\n```\r\n\r\n*Remarque : il est possible d'utiliser la syntaxe par pointeur ou par crochet pour accéder à la valeur d'un attribut d'un objet. Tout dépend des informations disponibles sur l'objet en fonction du contexte mais la syntaxe par pointeur reste la plus courante.*\r\n\r\nLes éléments d'un tableau ainsi que les attributs d'un objet sont accédés par référence, c'est à dire que modifier ces éléments ne modifie pas le tableau ou l'objet en lui même. De ce fait les tableaux et les objets sont généralement déclarés comme des constantes :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nconst membre = {\r\n  nom : 'toto',\r\n  age: 21\r\n}\r\n\r\nconst membres = [membre] // un tableau contenant l'objet membre\r\n\r\nmembre.age = 22 // on modifie l'objet\r\n\r\nconsole.log(membres) // Output : { nom: 'toto', age: 22 }\r\n```\r\n\r\n## Algoritmie\r\n\r\n### Conditions\r\n\r\nLes instructions `if / else / switch`, les opérateurs `<, >, <=, >=, !=` et `&&, ||` fonctionnent de manières similaires aux autres langages.\r\n\r\n*Remarque : La comparaison `==` vérifie uniquement la valeur des deux variables, `===` permet de vérifier la valeur et le type des deux variables*\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet titi = 6\r\nlet toto = '6'\r\n\r\nconsole.log(titi == toto) // true\r\nconsole.log(titi === toto) // false\r\n```\r\n\r\n### Boucles de contrôle\r\n\r\nLa boucle `while` est présente en Javascript mais pas la boucle `do while`. Il existe plusieurs types de boucles `for` :\r\n\r\n+ le for \"classique\"\r\n+ le for...in\r\n+ le for...of\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet membres = ['titi', 'toto', 'tutu']\r\n\r\nfor (let i = 0; i < membres.length; i++) {\r\n  console.log('Tu es un membre !')\r\n}\r\n\r\nfor (let i in members) {\r\n  console.log(members[i] + ' est un SUPER membre !)\r\n}\r\n\r\nfor (let member of members) {\r\n  console.log(member + 'est un INCROYABLE membre)\r\n}\r\n```\r\n\r\n*Remarque : le for...in n'est quasiment jamais utilisé au profit du for...of.*\r\n\r\n### Fonctions\r\n\r\nLes fonctions en Javascript fonctionnent légerement différement du au contexte sous typé. De plus elles possèdent des propriétés différentes que dans les autres langages mais nous n'aborderons ces propriétés qu'a partir des cours en contexte web.\r\n\r\n**Exemple** :\r\n\r\n```js\r\nfunction afficherDesValeurs(valeur1, valeur2) {\r\n  console.log('Première valeur : ' + valeur1)\r\n  console.log('Deuxième valeur : ' + valeur2)\r\n}\r\n\r\nfunction additionner(nombre1, nombre2) {\r\n  return nombre1 + nombre2\r\n}\r\n\r\nafficherDesValeurs(6, 'toto') // Output : Première valeur : 6 Deuxième valeur : toto\r\nconsole.log(additionner(2, 7)) // Output : 9\r\n```\r\n\r\n*Remarque : la recursivité est possible en Javascript.*\r\n\r\n### Exceptions\r\n\r\nLe bloc `try catch` est présent en Javascript et se construit de cette manière :\r\n\r\n```js\r\ntry {\r\n\r\n// code susceptible à l'erreur ici\r\n\r\n} catch (error) {\r\n\r\n// réaction aux erreurs ici\r\n\r\n}\r\n```\r\n\r\n## Classes et méthodes\r\n\r\nLes classes sont des blocs qui permettent de réunir à la fois un modèle de données pour un objet mais aussi des fonctions qui lui sont propres grâce aux méthodes d'instances. Les types de données ainsi créés fonctionnent commes les autres types du Javascript à l'exception de l'instanciation.\r\n\r\n**Exemple** :\r\n\r\n```js\r\nclass Chat {\r\n\r\n  constructor(nom, age) {\r\n    this.nom = nom\r\n    this.age = age\r\n  }\r\n\r\n  miauler() {\r\n    console.log('miaou !')\r\n  }\r\n\r\n  static verite(nombre) {\r\n    return 'Les chats sont ' + nombre + ' fois meilleurs que les chiens :)'\r\n  }\r\n\r\n}\r\n\r\nlet chat = new Chat('malo', 3)\r\nchat.miauler() // 'miaou !'\r\nconst laVerite = Chat.verite(10) // 'Les chats sont 10 fois meilleurs que les chiens :)'\r\n```\r\n\r\n## Tests unitaires\r\n\r\n// TODO: tests unitaires\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+ [Bases de Javascript pour le Web]()\r\n",_="# Bases de Javascript pour le Web\r\n\r\n## Prérequis\r\n\r\n+ [Bases de Javascript]()\r\n\r\n## Introduction\r\n\r\nLe Javascript est une pièce maitresse du développement Web, c'est le langage de compilation de tous les navigateurs existants, c'est à dire que c'est ce langage qui permet au navigateur de produire des pages web sous la forme à laquelle nous sommes habitués. Le Javascript permet également de rendre le contenu d'une page web dynamique, d'y injecter de l'algorithmie et du traitement de donnée, d'intéragir avec des API, bref, la liste est longue.\r\n\r\nHistoriquement le Javascript était reservé à la construction de la partie front-end d'une application Web, c'est à dire le contenu visible et les interactions avec l'utilisateur. Ce n'est aujourd'hui plus le cas et de plus de nombreux outils modernes, des frameworks, permettent de créer des applications web très puissantes de A à Z et bien plus facilement qu'auparavant.\r\n\r\nDans ce cours nous allons découvrir le fonctionnement de base du Javascript et de son interaction avec le contenu d'une page Web. Chaque interaction sera accompagnées d'exemples mais il est impossible et inutile de couvrir tous les cas possibles dans ce cours, ainsi il est fortement conseillé de consulter la documentation en ligne sur [Developper Mozilla](https://developer.mozilla.org/fr/)\r\n\r\n## Compilation\r\n\r\nLorsqu'on déploie une application Web composé notamment d'éléments HTML (ou de balises) accompagnées de style CSS et éventuellement de script JS, tout ce contenu est d'abord réuni en un seul fichier pour faciliter la compilation auprès du navigateur. Tout est mis en oeuvre pour que cette compilation soit la plus rapide possible car tout le monde sait qu'une page web qui ralentit fait fuir les utilisateurs et peut entraîner des bugs.\r\n\r\nIl existe de nombreux outils, couplés aux fonctionnalités du Javascript, qui permettent d'optimiser au maximum la compilation. Le fichier produit ensuite est bien sur absolument illisible pour un être humain mais bien pratique pour le navigateur de votre choix.\r\n\r\n## Le DOM\r\n\r\nLe Document Object Model, ou DOM, pose les fondations de l'architecture d'une application Web, c'est ce modèle qui explique les interactions entre les balises HTML et c'est auprès de celui-ci que les scripts JS se réfère pour accéder à des éléments dans la page web.\r\n\r\n*Remarque : On réfère au DOM dans le Javascript via le mot clé `document`.*\r\n\r\n## Interactions\r\n\r\nLes interactions de bases possibles entre un script JS et une page web sont les suivantes :\r\n\r\n+ récupérer un élément HTML et son contenu\r\n+ modifier un élément HTML\r\n+ modifier le style d'un élément\r\n+ écouter des évènements sur un élément\r\n\r\n*Remarque : un évènement est une action qui s'effectue sur la page, un évènement peut être un changement d'état d'un élément de la page (ex: chargement de l'élément terminé) ou bien une intervention de l'utilisateur (ex: clic sur un bouton, un Link).*\r\n\r\n### Recuperer un élément HTML\r\n\r\nLes balises HTML sont caractérisées par differentes propriétés qui permettent de facilement récupérer ce que l'on souhaite dans une page. Toute balise possède un type et eventuellement une classe, ces deux caractéristiques permettent d'isoler des groupes de balise dans la page. Une balise peut également posséder un id qui va alors permettre d'identifier une balise de manière unique.\r\n\r\nLe Javascript permet d'exploiter ces caractéristiques avec différents sélécteurs :\r\n\r\n+ `getElementsByTagName('tag')` : retourne un tableau contenant les éléments de type `tag` (nom de la balise)\r\n+ `getElementsByClassName('class')` : retourne un tableau contenant les éléments possèdant la classe `class`\r\n+ `getElementById('id')` : retourne l'élément identifié par `id`\r\n\r\n**Exemple** :\r\n\r\n```js\r\nconst monTableau = document.getElementById('tableau')\r\nconst cellules = monTableau.getElementsByTagName('td')\r\n```\r\n\r\nIl est possible d'effectuer une recherche plus pointue avec le querySelector qui permet de combiner différents outils de recherche :\r\n\r\n**Exemple** :\r\n\r\n```html\r\n<div id=\"myId\">\r\n    <p>\r\n        <span><a href=\"#\">Link 1</a></span>\r\n        <a href=\"#\">Link 2</a>\r\n        <span><a href=\"#\">Link 3</a></span>\r\n    </p>\r\n    <p class=\"toto\">\r\n        <span><a href=\"#\">Link 4</a></span>\r\n        <span><a href=\"#\">Link 5</a></span>\r\n        <a href=\"#\">Link 6</a>\r\n    </p>\r\n    <p>\r\n        <a href=\"#\">Link 7</a>\r\n        <span><a href=\"#\">Link 8</a></span>\r\n        <span><a href=\"#\">Link 9</a></span>\r\n    </p>\r\n</div>\r\n```\r\n\r\n```js\r\nconst preciseElement = document.querySelector(\"#myId p.toto > a\")\r\n```\r\n\r\nOn recherche dans un élément ayant pour id 'myId' les éléments de type `<p>` ayant pour classe `toto` afin de récupérer l'enfant direct de type Link `<a>`. `preciseElement` contient donc le Link 6.\r\n\r\nOn peut également récupérer des éléments liés hierarchiquement avec d'autres :\r\n\r\n+ `element.children` : retourne un tableau contenant tous les éléments enfants de `element`\r\n+ `element.parentElement` : retourne l'élément parent de `element`\r\n+ `element.nextElementSibling / element.previousElementSibling` : retourne l'élément suivant ou précédent `element` au même niveau hierarchique.\r\n\r\n**Exemple** :\r\n\r\n```html\r\n<div id=\"parent\">\r\n    <div id=\"toto\">Previous</div>\r\n    <div id=\"main\">\r\n        <p>Text 1</p>\r\n        <p>Text 2</p>\r\n    </div>\r\n    <div id=\"titi\">Next</div>\r\n</div>\r\n```\r\n\r\n```js\r\nconst elt = document.getElementById('main')\r\n```\r\n\r\n+ `elt.children` renvoient les éléments `<p>` enfants de la div ayant pour id `main`\r\n+ `elt.parentElement` renvoie la div ayant pour id `parent`\r\n+ `elt.nextElementSibling` renvoie la div ayant pour id `titi`\r\n\r\n*Remarque : Toutes ces méthodes de recherche renvoie un élément `null` si la recherche ne porte pas ses fruits, le programme ne plante pas nécessairement.*\r\n\r\n### Modifier un élément\r\n\r\nUne fois que l'on a récupéré un élément du DOM on peut modifier ses propriétés. La modification la plus courante est celle du contenu HTML lui même de cet élément. Plusieurs méthodes existent :\r\n\r\n+ `innerHTML` : remplace le contenu actuel de l'élément par un nouveau contenu HTML\r\n+ `textContent` : remplace le contenu actuel de l'élément par un nouveua contenu textuel\r\n\r\n*Remarque : Il existe d'autres façons, celles-ci sont les plus courantes. `textContent` ne peut pas interpréter la syntaxe html et est donc beaucoup moins utile.*\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet elt = document.getElementById('toto')\r\nelt.innerHTML = \"<ul><li>Ligne 1</li><li>Ligne 2</li></ul>\"\r\n```\r\n\r\nRésultat :\r\n\r\n```html\r\n<div id=\"toto\">\r\n    <ul>\r\n        <li>Ligne 1</li>\r\n        <li>Ligne 2</li>\r\n    </ul>\r\n</div>\r\n```\r\n\r\nUne autre modification possible est le changement de classe d'un élément grâce à la propriété `classList` :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nelt.classList.add(\"nouvelleClasse\")           // Ajoute la classe nouvelleClasse à l'élément\r\nelt.classList.remove(\"nouvelleClasse\")        // Supprime la classe nouvelleClasse que l'on venait d'ajouter\r\nelt.classList.contains(\"nouvelleClasse\")      // Retournera false car on vient de la supprimer\r\nelt.classList.replace(\"oldClass\", \"newClass\") // Remplacera oldClass par newClass si oldClass était présente sur l'élément\r\n```\r\n\r\n*Remarque : il est possible d'ajouter et de retirer plusieurs classes à la fois.*\r\n\r\nOn peut modifier le style d'un élément sans passer par une feuille de style CSS grâce à la propriété `style` :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nelt.style.color = \"#fff\";           // Change la couleur du texte de l'élément à blanche\r\nelt.style.backgroundColor = \"#000\"; // Change la couleur de fond de l'élément en noir\r\nelt.style.fontWeight = \"bold\";      // Met le texte de l'élément en gras\r\n```\r\n\r\nSi un élément peut posséder des attributs, on peut les modifier :\r\n\r\n**Exemple** :\r\n\r\nPour un élément de type input qui est un type possédant des attributs\r\n\r\n```js\r\nelt.setAttribute(\"type\", \"password\");    // Change le type de l'input en un type password\r\nelt.setAttribute(\"name\", \"my-password\"); // Change le nom de l'input en my-password\r\nelt.getAttribute(\"name\");                // Retourne my-password\r\n```\r\n\r\n### Créer un élément\r\n\r\nIl est possible de créer de nouveaux éléments depuis un script JS cependant pour que ces éléments soient visibles sur la page il faut impérativement les rattacher à des éléments déjà existants dans le DOM.\r\n\r\nPour créer un élément on utilise `createElement` puis `appendChild` pour le rattacher à la page via un autre élément :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nconst newElt = document.createElement(\"div\");\r\nlet parent = document.getElementById(\"toto\");\r\n\r\nparent.appendChild(newElt);\r\n```\r\n\r\nComme il est possible de créer, il est également possible de supprimer un élément si celui-ci est enfant d'un élément du DOM, pour cela on utilise `removeChild` ou bien `replaceChild` :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nconst newElt = document.createElement(\"div\");\r\nlet elt = document.getElementById(\"main\");\r\nelt.appendChild(newElt);\r\n\r\nelt.removeChild(newElt);                                     // Supprime l'élément newElt de l'élément elt\r\nelt.replaceChild(document.createElement(\"article\"), newElt); // Remplace l'élément newElt par un nouvel élément de type article\r\n```\r\n\r\n## Exercices\r\n\r\n+\r\n\r\n## Suivants\r\n\r\n+\r\n",M={bases_javascript:D,bases_javascript_web:_};const R=[{id:"1",title:"Creascio",icon:"https://cdn.discordapp.com/attachments/822839106001829908/822839194099384360/discord_pdp.png",chapters:[{id:"1-1",title:"Présentation de Creascio",icon:"",markdown:i.presentation_creascio},{id:"1-2",title:"Devenir Helper",icon:"",markdown:i.devenir_helper}]},{id:"2",title:"Git",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850371933118791690/AdKzmNKdPeteAAAAABJRU5ErkJggg.png",chapters:[{id:"2-1",title:"Environnement de travail",icon:"",markdown:d.environnement_travail_git},{id:"2-2",title:"GitHub",icon:"",markdown:d.bases_github},{id:"2-3",title:"GitHub Desktop",icon:"",markdown:d.bases_github_desktop},{id:"2-4",title:"Merge Request",icon:"",markdown:d.merge_request},{id:"2-5",title:"Pull Request",icon:"",markdown:d.pull_request}]},{id:"3",title:"Bases de la Programmation",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850372098277900318/c-programming.png",chapters:[{id:"3-1",title:"Environnement de travail",icon:"",markdown:f.environnement_travail_c},{id:"3-2",title:"Types primitifs et Variables",icon:"",markdown:f.types_primitifs_variables},{id:"3-3",title:"Affichage Console",icon:"",markdown:f.affichage_console},{id:"3-4",title:"Conditions Booléennes",icon:"",markdown:f.conditions_booleennes},{id:"3-5",title:"Boucles de contrôles",icon:"",markdown:f.boucles_controle}]},{id:"4",title:"Programmation Orientée Objet",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850372498871681034/226777.png",chapters:[{id:"4-1",title:"Environnement de travail",icon:"",markdown:O.environnement_travail_java},{id:"4-2",title:"Classes et Attributs",icon:"",markdown:O.classes_attributs},{id:"4-3",title:"Méthodes",icon:"",markdown:O.methodes},{id:"4-4",title:"Programme principal",icon:"",markdown:O.programme_principal},{id:"4-5",title:"Enumérations",icon:"",markdown:O.enumerations},{id:"4-6",title:"Bibliothèques",icon:"",markdown:O.bibliotheques},{id:"4-7",title:"Collection et Iterable",icon:"",markdown:O.collection_iterable},{id:"4-8",title:"Interface Utilisateur",icon:"",markdown:O.interface_utilisateur},{id:"4-9",title:"Valeur Aléatoire",icon:"",markdown:O.valeurs_aleatoires},{id:"4-10",title:"Dictionnaires",icon:"",markdown:O.dictionnaires},{id:"4-11",title:"Mode Debug",icon:"",markdown:O.mode_debug},{id:"4-12",title:"Tests Unitaires",icon:"",markdown:O.tests_unitaires},{id:"4-13",title:"Gestion des Exceptions",icon:"",markdown:O.gestion_exceptions},{id:"4-14",title:"Abstraction et Héritage",icon:"",markdown:O.abstraction_heritage},{id:"4-15",title:"Polymorphisme",icon:"",markdown:O.polymorphisme},{id:"4-16",title:"Abstraction et Interface",icon:"",markdown:O.abstraction_interface}]},{id:"5",title:"Programmation Orientée Web",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850373060645093406/javascript.png",chapters:[{id:"5-1",title:"Bases de Javascript",icon:"",markdown:M.bases_javascript},{id:"5-2",title:"Javascript pour le Web",icon:"",markdown:M.bases_javascript_web}]}];n["a"]=R},bb95:function(e,n,r){"use strict";r("863e")}}]);