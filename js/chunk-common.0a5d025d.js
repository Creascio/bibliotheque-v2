(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[1],{"641e":function(e,n,r){"use strict";var t=function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",{staticClass:"bg-grey-10 row justify-between items-center"},[r("q-btn",{staticClass:"q-mx-sm",attrs:{icon:"arrow_back_ios",size:"md",flat:""},on:{click:function(n){return e.goBack()}}}),r("div",{staticClass:"text-h6 q-py-sm text-center title"},[e._v(e._s(e.title.split("-").join(" ")))]),r("q-btn",{staticClass:"q-mx-sm",attrs:{size:"md",flat:""}})],1)},s=[],i=r("a6f4"),a=Object(i["b"])({props:{title:{type:String,required:!0}},methods:{goBack(){this.$router.back()}}}),o=a,u=(r("bb95"),r("2877")),l=r("9c40"),c=r("eebe"),d=r.n(c),p=Object(u["a"])(o,t,s,!1,null,"7a0804ef",null);n["a"]=p.exports;d()(p,"components",{QBtn:l["a"]})},"863e":function(e,n,r){},"8fcf":function(e,n,r){"use strict";var t=function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("q-list",{class:e.listClass,attrs:{padding:"",bordered:"",separator:""}},e._l(e.content,(function(n){return r("q-item",{key:n.id,class:e.itemClass,attrs:{to:e.redirection+n.title.toLowerCase().split(" ").join("-"),clickable:""}},[r("q-item-section",{attrs:{avatar:""}},[r("div",[r("q-img",{staticStyle:{border:"solid 3px white",height:"60px",width:"60px","border-radius":"5px"},attrs:{src:n.icon}})],1)]),r("q-item-section",[r("q-item-label",[e._v(e._s(n.title))])],1)],1)})),1)},s=[],i=r("a6f4"),a=Object(i["b"])({props:{listClass:{type:String,required:!0},itemClass:{type:String,required:!0},content:{type:Array,required:!0},redirection:{type:String,required:!0}},setup(){}}),o=a,u=r("2877"),l=r("1c1c"),c=r("66e5"),d=r("4074"),p=r("068f"),m=r("0170"),v=r("eebe"),b=r.n(v),h=Object(u["a"])(o,t,s,!1,null,null,null);n["a"]=h.exports;b()(h,"components",{QList:l["a"],QItem:c["a"],QItemSection:d["a"],QImg:p["a"],QItemLabel:m["a"]})},ab91:function(e,n,r){"use strict";var t="# Présentation de Creascio\r\n\r\n## Introduction\r\n\r\nBienvenue dans Creascio ! Le but de notre communauté est de vous faire **découvrir des langages ou framework informatiques** au travers de **tutos, d'exercices et de projets** à réaliser.\r\n\r\nNous pouvons aussi vous offrir nos **témoignages, astuces et conseils** dans d'autres domaines pratiqués par nos membres.\r\n\r\nNous sommes également une communauté faite pour **rencontrer de nouvelle personnes** que ce soit pour faire des projets ou se faire des amis.\r\n\r\n_PS : Bien sur, nous ne sommes pas des professionnels donc cette communauté est plus une aide à votre autoformation ou un complément aux études que vous faites._\r\n\r\nLa communauté Creascio possède à ce jour deux outils : un [serveur Discord](https://discord.gg/TSjV4jH3Dq) ainsi qu'un [site Bibliothèque](https://creascio.github.io/bibliotheque-v2/#/). (sur lequel vous êtes :D)\r\n\r\n## Le Discord\r\n\r\nLe serveur Discord permet à la communauté d'échanger sur de nombreux domaines, de partager leurs connaissances ou tout simplement de papoter ensemble.\r\n\r\nIl y a différents rôles sur le Discord Creascio :\r\n\r\n- **Helper** : les membres créateurs de contenu pour Creascio\r\n- **Membre** : les membres actifs de la communauté et qui reçoivent les news du serveur\r\n- **Externe** : les membres présents mais qui ne reçoivent pas les news du serveur\r\n- **Visiteur** : les nouveaux membres\r\n\r\nLe Discord Creascio est divisé en plusieurs catégories :\r\n\r\n- **Accueil** : les salons dédiés aux **Visiteur** à leur arrivée.\r\n- **Infos** : les salons dédiés aux informations accessibles à tous les **Membre** et également aux news des **Helper**\r\n- **Podium** : les salons dédiées au partage de contenus divers avec la communauté (musique, art, etc.)\r\n- **General** : les salons dédiées aux discussions en tout genre\r\n- **Jeux** : les salons dédiées au partage de contenus liés aux jeux\r\n- **Aide** : les salons dédiées à tout type de question et à l'aide aux études / projets\r\n\r\n## Les activités\r\n\r\nSur le Discord les **Helpers** peuvent organiser des cours oraux ou des soutiens d'exercices et projets en fonction des besoins des membres.\r\n\r\nNous organisons également des soirées jeux pour papoter en vocal afin de mieux vous connaitre.\r\n\r\nEnfin si vous souhaitez faire un projet en groupe avec des membres de Creascio, les **Helpers** sont à votre disposition pour vous aider dans la limite de nos compétences. Nous pouvons, si vous le voulez, créer un espace sur le discord dédié à votre projet.\r\n\r\n## Le site\r\n\r\nLe site **Bibliothèque de Creascio** regroupe tout le contenu produit par les **Helper** pour les membres de la communauté. La bibliothèque contient tous nos cours sur des sujets divers.\r\n\r\nLes cours sont généralement divisés en plusieurs notions pour faciliter l'apprentissage. Nous nous efforçons d'accompagner les notions du plus d'exemples possibles ainsi que d'exercices pour pratiquer.\r\n\r\n## Pour commencer\r\n\r\nEn tant que nouvel arrivant, nous t'invitons a remplir ce petit questionnaire : [cliquez ici !](https://forms.gle/4XMKZJbRgDmJ38rU7)\r\n\r\n_Remarque : Il est aussi primordial de compléter le cours [Git](https://creascio.github.io/bibliotheque-v2/#/git) avant de commencer votre apprentissage !_\r\n\r\nBravo d'avoir tout lu, vous faites maintenant parti de Creascio !\r\n",s="# Devenir Helper\r\n\r\n## Introduction\r\n\r\nLes Helpers ont un rôle clé dans Creascio, ce sont les membres qui **créer du contenu** et qui souhaitent **aider les autres membres**.\r\n\r\nDans ce document nous allons détailler ce que l'on attend de vous si vous souhaitiez devenir un Helper pour Creascio.\r\n\r\n## Ce qu'il faut pour être Helper\r\n\r\nPour devenir Helper il faut déjà avoir une **certaine expérience dans une notion**, peu importe son sujet. Il n'est pas nécessaire qu'elle soit déjà abordée dans le cadre de Creascio bien au contraire.\r\n\r\nIl faut être capable au minimum de pouvoir **aiguiller les membres** sur cette notion en **répondant à leurs questions**, en faisant part de votre expérience ou bien encore en partageant des contenus utiles à leur formation (vidéos Youtube, sites internet, etc.).\r\n\r\nIl faut être capable de faire ceci **au moins à l'écrit** et éventuellement à l'oral sur le Discord.\r\n\r\nLes Helpers peuvent également être ammenés à **rédiger des supports de cours** ou bien des **énoncés d'exercices et de projets**.\r\n\r\nPour les cours il est possible d'organiser des **sessions de cours orale sur le Discord**.\r\n\r\nPour les exercices il faut se porter garant d'être **disponible** si un membre requiert une correction d'exercice.\r\n\r\nIl est également possible d'organiser des **sessions de travail en vocal** où les membres pourront poser des questions concernants le cours et/ou les exercices.\r\n\r\n## Fonctionnement\r\n\r\nN'importe quel membre de Creascio qui se retrouve dans la description du rôle faite au dessus peut proposer sa \"candidature\" aux **Modérateurs**.\r\n\r\nIl est très important de **communiquer un maximum** avec les autres Helpers sur vos souhaits, vos idées, vos initiatives, nous sommes une **équipe avant tout**.\r\n\r\nBien évidemment le rôle de Helper n'attribut **aucune autorité particulière sur le serveur Discord ou ailleurs**, tous les membres de Creascio sont sur un pied d'égalité.\r\n\r\nEn esperant que tout cela vous inspire !\r\n",i={presentation_creascio:t,devenir_helper:s},a="# Environnement de travail\r\n\r\n## Introduction\r\n\r\nGit est un outil de **gestion de projet**, il permet de travailler à **plusieurs sur le même projet** tout en évitant le problème de versionning (Le fait d'avoir plusieurs versions différentes d'un même projet).\r\n\r\nC'est aussi un outil pratique pour travailler seul étant donné que les données sont hébergées sur un **Cloud**.\r\n\r\nDans ce tutoriel, nous allons apprendre les bases de l'utilisation de Git.\r\n\r\nPour nous faciliter la vie, nous allons utiliser une application liée à Git qui se nomme **GitHub Desktop** mais sachez que ce n'est pas la seule manière d'utiliser Git.\r\n\r\nEn effet, vous pouvez aussi intéragir avec le cloud depuis le site de github, un terminal de commande ou d'autres applications clientes comme [Fork](https://git-fork.com/).\r\n\r\n## Setup\r\n\r\nPour ce cours nous aurons besoin de :\r\n\r\n+ créer un compte [GitHub](https://github.com/)\r\n+ télécharger l'outil bureau [GitHub Desktop](https://desktop.github.com/)\r\n\r\nGitHub est la plateforme centrale qui nous permet de **visualiser le contenu** que l'on héberge sur le Cloud git. Elle permet également de **paramétrer un projet**, d'inviter des **collaborateurs**.\r\n\r\nElle propose également de nombreux outils utiles à la **conception** et à la **planification** d'un projet.\r\n\r\nGitHub Desktop est un outil complémentaire à GitHub qui permet **manipuler le contenu** de projet git notamment.\r\n",o="# Base de GitHub\r\n\r\n## Introduction\r\n\r\nGitHub est un outil de **gestion de projets** git. C'est une plateforme en ligne qui permet à ses utilisateurs de **stocker leur contenu sur le cloud** pour facilier le versionning et la **collaboration entre les membres** d'une équipe.\r\n\r\nIl propose de nombreux autres outils qui facilitent la **conception** et la **gestion de projet**.\r\n\r\n*Remarque : il existe d'autres plateformes du même genre mais nous utiliserons GitHub dans le cadre de ce cours.*\r\n\r\n## Architecture\r\n\r\nLorsque vous créez un projet Git, vous créez un **repository**.\r\n\r\nUn **repository** est divisé en **branches** qui peuvent stocker des contenus différents. Attention, les branches ne sont pas des sous dossiers ! Ce sont plutôt des bouts de projets ou bien des versions différentes d'un même projet.\r\n\r\nAu départ, il n'existe qu'une seule branche, la branche **main**, qui est la branche principale. Vous pouvez créer autant de branches que vous voulez. Il faut juste faire attention au nommage. Deux branches ne peuvent pas avoir le même nom.\r\n\r\nLa branche **main** est la branche où sera votre projet final. En règle général, on créé une branche par collaborateur (donc même si vous êtes seul vous vous créez une branche). Cela permet, dès qu'une fonctionnalité marche, de la mettre sur la branche **main**. De plus, si vous faites des bétises sur votre branche, vous aurez une sauvegarde sur la branche **main**.\r\n\r\n## Créer un repository\r\n\r\nDepuis l'accueil de Github, cliquez sur le bouton **New** pour créer un repository.\r\nIl faudra lui donner un nom, une potentielle description et choisir sa visibilité.\r\n\r\nVous pouvez ajouter un **README**. C'est un document que l'on utilise lorsque\r\nl'on met en publique son code. Le but étant d'expliquer votre projet et comment le faire marcher. Cela peut être un .txt ou un .md.\r\n\r\nVous pouvez aussi ajouter un **.gitignore** si vous faites du node.js, du unity ou d'autres\r\ntechnologies avec de lourdes bibliothèques.Un **.gitignore** est un fichier qui comme son nom l'indique ignorera toutes les bibliothèques. Ainsi sur le cloud, il n'y aura que votre code.\r\n\r\nLorsque vous créez une repository sur Github, il sera totalement vide. (sauf si vous avez créé un README ou un .gitignore)\r\n\r\n## Interface repository\r\n\r\nLorsque vous cliquez sur l'un de vos repository ou lorsque vous en créez un, l'interface devrait\r\nressembler à ça. (si ce n'est pas le cas cliquer sur **<> Code** dans le menu)\r\n\r\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/825436230095077419/unknown.png\" align=\"center\"/>\r\n\r\nComme vous pouvez le voir vous tombez directement sur le code présent dans le main. Si vous avez un README, il est affiché en dessous de vos fichiers.\r\n\r\nDepuis cette endroit, vous pouvez ajouter, modifier et supprimer des fichiers ou simplement naviguer dans vos fichiers.\r\n\r\nVous pouvez aussi cloner votre repository afin de l'importer sur votre ordinateur en\r\ntéléchargent un .zip. Pour cela cliquer sur le bouton vert **Code** puis **Download ZIP**\r\n\r\n## Paramétrage\r\n\r\nIl existe de nombreuses options de personnalisation de votre repository que ce soit pour en filtrer l'accès ou bien le contenu.\r\n\r\n### Inviter des collaborateurs\r\n\r\nUn collaborateur est quelqu'un qui a accès en lecture ET en écriture à votre code.\r\n\r\nPour ajouter des personnes à votre projet, aller dans **Settings** puis dans **Manage access**\r\npuis cliquer sur **Invite a collaborator** enfin entrer le pseudo de la personne que vous souhaitez ajouter. Celui-ci recevra un mail qui l'invitera sur le repository avec un lien.\r\n\r\nVous pouvez à tout moment supprimer un collaborateur.\r\n\r\n### Changer la visibilité\r\n\r\nDans **Settings** si vous revenez dans **Options** et que vous scrollez tout en bas,\r\nvous pouvez changer la visibilité d'un repository.\r\n\r\nUn repository publique permet à n'importe qui de voir le code et de le copier sur son ordinateur mais il ne peutpas être modifier. Un repository privé est totalement caché, on ne peux pas le voir ni le changer à mois d'etre un collaborateur.\r\n\r\n### Archiver\r\n\r\nDans **Settings** si vous revenez dans **Options** et que vous scrollez tout en bas,\r\nvous pouvez archiver un repository.\r\n\r\nLorsqu'un repository est archiver vous et vos collaborateur ne pouvez plus le modifier mais\r\nvous avez toujours accès au code en lecture. Cette action est reversible.\r\n\r\n### Supprimer\r\n\r\nDans **Settings** si vous revenez dans **Options** et que vous scrollez tout en bas,\r\nvous pouvez supprimer un repository.\r\n\r\nCette action est irreversible donc attention !\r\n\r\n## Exercices\r\n\r\n### Question 1 : Création de projet\r\n\r\nCréez un repository appelé \"Test\", mettez en description \"Je suis un repository test\", mettez le en privé et ajouter un README.\r\n\r\nAprès avoir cliqué sur ``<> Code`` voici ce que vous devriez avoir comme résultat :\r\n\r\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/828643996434956328/unknown.png\" align=\"center\"/>\r\n\r\n### Question 2 :  Faire un commit\r\n\r\nModifiez le contenu de votre README : \"Premier projet git, c'est beau !\" (N'oubliez pas de commit !)*\r\nVous verrez son aperçu changer en revenant à la racine de votre branche.\r\n\r\n### Question 3 : Ajouter un collaborator\r\n\r\nInvitez `Shiropetite` dans votre repository.\r\n\r\n### Question 4 : Supprimer votre repository\r\n\r\nCe repository n'est pas très utile avec juste un README. Nous allons donc le supprimer.\r\n",u="# Base de GitHub Desktop\r\n\r\n## Introduction\r\n\r\nGithub Desktop est un outil de bureau en lien avec Github et qui permet la **gestion du contenu** de repository git.\r\n\r\nC'est une interface qui rend ce processus plus **graphique et intuitif** mais elle n'est en aucun cas nécessaire pour manipuler des projets git, une invite de commande suffit pour cela.\r\n\r\n## Interface\r\n\r\nVoici à quoi ressemble l'interface de **Github Desktop**.\r\n\r\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/825439994806140998/unknown.png\"/>\r\n\r\n## Gestion de repository\r\n\r\nA droite, cliquez sur `Current repository`. Cela vous ouvrira un menu qui contient **tout vos repository**. Dans ce menu, cliquez sur le bouton `Add`. (Si vous n'avez jamais fait de projet Git, on vous proposera tout de suite d'ajouter un repository).\r\n\r\nLorsque vous cliquez sur `Add` trois choix s'offrent à vous :\r\n\r\n+ `Clone repository` : **Copiez votre projet Git sur votre pc** (ou un repository public). Lorsque vous cliquez, cela vous ouvrira une fenêtre qui vous proposera soit de choisir parmi les repository auquels vous avez accès, soit d'insérer l'url ou nom d'un repository. Dans tout les cas vous devrez aussi insérer **l'endroit où vous voulez sauvegarder** ce repository.\r\n\r\n+ `Create new repository` : **Créez un repository de 0**. Lorsque vous cliquez, cela vous ouvrira une fenêtre qui vous demandera le nom, la potentielle description, le chemin où vous voulez stocker votre projet et enfin si vous voulez ajouter un README. Vous aurez en plus le choix d'ajouter un .gitignore (choisissez simplement le langage que vous allez utiliser).\r\n\r\n+ `Add existing repository` : **Ajoutez un repository git déjà présent localement sur votre pc** (il doit avoir le fichier .git). Lorsque vous cliquez, cela vous ouvrira une fenêtre qui vous demandera **le chemin du repository sur votre pc**.\r\n\r\n## gitignore\r\n\r\nUn .gitignore est un fichier qui permet au repository **d'ignorer certains types de fichiers** comme de lourdes bibliothèques (par exemple `node-modules`).\r\n\r\n## Gestion de branches\r\n\r\nIl est important de créer des branches afin de stocker plusieurs versions d'un même projet.\r\n\r\nPour créer un branche depuis Github Desktop, cliquer sur `Current branch`. Cela vous ouvrira un menu où vous pourrez **naviguer de branches en branches**.\r\n\r\nDepuis ce menu, cliquez sur `New branch` pour créer un nouvelle branche. Cela vous ouvrira une fenêtre qui vous demandera **le nom de votre nouvelle branche**.\r\n\r\n*Remarque : celui-ci ne doit pas être le même qu'une autre branche !*\r\n\r\nIl vous demandera aussi, si vous n'êtes pas sur la branche `main`, **depuis quel branche vous voulez créer la nouvelle**.\r\n\r\nSi vous sélectionner `main`, il prendra alors la version du projet de main et la mettra sur votre branche. Si vous sélectionner une autre branche, il prendra la version de la branche sélectionnée.\r\n\r\nN'oubliez pas une fois la branche créée de cliquez sur `Publish Branch`, sinon cette branche ne sera créé que **localement sur votre pc**.\r\n\r\nSi vous faites un clic droit sur une des branches depuis le menu de navigation de branches, vous pourrez renommer une branche ou en supprimer une.\r\n\r\n*Remarque : si vous le faites, n'hésiter pas à recloner votre projet et à demander à vos collaborateurs de le faire aussi. Sinon vous risquez de vous retrouver avec des branches fantômes.*\r\n\r\nPour recloner un projet, supprimer le dossier de votre projet local puis aller sur Github Desktop et cliquer sur `Clone Again`.\r\n\r\nN'oubliez pas de `Push` vos changements **AVANT** sinon ils seront perdus !\r\n\r\n## Commit\r\n\r\nLorsque vous allez effectuer des changements sur vos fichiers, Github Desktop affichera ceci sur la gauche de l'écran :\r\n\r\n<img src=\"https://cdn.discordapp.com/attachments/822839106001829908/825442599301152818/unknown.png\" />\r\n\r\nDans le screen, nous pouvons voir que 7 fichiers ont été modifié. Le carré jaune signifie que **le contenu du fichier a changé**, le carré vert signifie que le fichier **a été créé ou ajouté** et le carré rouge signifie que **le fichier a été supprimé**.\r\n\r\nEn cliquant sur l'un des fichiers, vous pouvez voir **les modifications en détails**. Les lignes surlignées en **vert** sont les lignes **ajoutées** et les lignes surlignées en **rouge** sont les lignes **supprimées** du fichier.\r\n\r\nLorsque vous voudrez sauvegarder votre travail, vous devrez alors donner un nom à votre **commit** dans le champs `Sumarry (required)`.\r\n\r\nCe nom doit normalement représenter **les changements que vous avez fait** comme \"Update ... file\", celui-ci est **obligatoire** pour commit.\r\n\r\nVous pouvez aussi ajouter un description. Une fois que vous avez donner un nom à votre commit cliquer sur `Commit to [nom-de-la-branche-actuelle]`.\r\n\r\nUn commit est une sauvegarde **uniquement locale à votre pc**.\r\n\r\n## Push, Pull, Fetch\r\n\r\nLe bouton `Fetch origin` permet de **comparer votre version et celle du cloud**, il détecte donc quand vous devez **push** ou **pull**.\r\n\r\nLorsque vous effectuez un commit le bouton qui se nommait à l'origine `Fetch origin` se transformera en `Push`. Cet action permet\r\nde **mettre à jour votre commit sur le cloud de Git** afin que vos collaborateurs voient vos changements.\r\n\r\nLorsque vos amis **push** quelque chose, vous pourrez alors cliquer sur `Fetch origin`, une fois cela fait ce bouton se transformera en `Pull` ce qui permettra de **mettre à jour votre version depuis le cloud**.\r\n\r\nLorsque vous voulez **push** un commit, il faudra vérifier que votre version est bien à jour avec le cloud et donc si vous n'avez pas à **pull** avant. Dans notre cas, Github Desktop vous préviendra.\r\n\r\n## Exercices\r\n\r\n### Question 1 : Créer un projet\r\n\r\nCréer un projet sur Github Desktop, appeler le \"First-Project\" vous pouvez mettre la description que vous voulez.\r\n\r\n### Question 2 : Créer une branche\r\n\r\nCréer une branche qui vous nommerez \"develop\"\r\n\r\n### Question 3 :  Faire un commit\r\n\r\nDans la branche develop, créer un fichier texte avec n'importe quel texte dessus. Puis appeler votre commit \"Create a text file\" puis commiter !\r\n\r\n### Question 4 : Push le commit\r\n\r\nEnfin n'oubliez pas de push !\r\n",l="# Merge Request\r\n\r\n## Introduction\r\n\r\nLors d'un projet en équipe, la possibilité de merge différentes branches de travail est cruciale pour pouvoir **contrôler** que l'apport de **nouvelles fonctionnalités** dans la version principale du projet se fait correctement.\r\n\r\n## Merge\r\n\r\nL'action de merge se fait toujours d'une branche vers une autre, on dit qu'on merge la branche A dans la branche B. Ainsi le contenu de la branche A **va se retrouver dans la branche B** et la branche A peut être supprimé ensuite.\r\n\r\nLa bonne pratique veut que dans un projet en groupe ou chacun travaillerait sur une ou plusieurs tâches précises, une fois ces tâches accomplies on merge leurs branche vers la branche principale `main` (ou `master`).\r\n\r\nUn merge peut entraîner des **conflits sur la branche qui reçoit les modifications** si les deux branches contenaient un fichier avec une **signature identique** (même nom et extension) et que la branche entrante n'est pas à jour avec la branche recevante.\r\n\r\n## Conflits\r\n\r\nEn fonction du type de conflits, Github Desktop peut proposer de prendre en charge la gestion du conflit en proposant d'utiliser **Visual Studio Code** (un éditeur évolué de Microsoft). L'éditeur vous permet alors de choisir entre :\r\n\r\n+ garder uniquement les modifications actuelles, c'est à dire l'état du fichier **avant merge**\r\n+ garder uniquement les modifications entrantes, c'est à dire **remplacer le contenu** du fichier\r\n+ garder toutes les modifications, l'éditeur va tenter de **fusionner les deux états** du fichier.\r\n\r\n*Remarque : les conflits restent très rare vous n'avez pas a trop vous inquietez mais il faut savoir quoi faire quand on tombe dessus.*\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",c="# Pull Request\r\n\r\n## Introduction\r\n\r\nLes Pull Requests sont une fonctionnalité permettant à un collaborateur d'un repository git de demander l'avis d'un autre collaborateur, que l'on appelle un **reviewer**, avant de **merge une branche dans une autre**.\r\n\r\nC'est un outil très pratique pour permettre de **détecter les coquilles éventuelles** dans un code et cela permet également de **maintenir l'équipe informée** du travail effectué s'ils sont reviewer.\r\n\r\n## Utilisation\r\n\r\nPour pouvoir effectuer des Pull Requests sur un repository il faut au moins qu'il contienne **deux branches**. La branche depuis laquelle la requête sera émise et la branche qui va recevoir les modifications.\r\n\r\nUne fois que du contenu a été **push** sur la version Cloud d'une branche, il est possible via GitHub ou bien GitHub Desktop d'émettre une Pull Request. Il faut alors désigner **les branches entrante et recevante** du merge a effectuer.\r\n\r\nAprès cela on peut choisir quel(s) reviewer(s) seront alertés par notre requête. Ces derniers reçoivent une alerte par mail.\r\n\r\n## Reviewing\r\n\r\nUne fois informé un reviewer peut voir le contenu de la branche entrante et notamment le **contenu du push** concerné. Il peut alors déposer des **commentaires** dans les fichiers et finalement **accepté ou refusé la demande de merge**.\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",d={environnement_travail_git:a,bases_github:o,bases_github_desktop:u,merge_request:l,pull_request:c},p="# Environnement de travail\r\n\r\n## Introduction\r\n\r\nDans ce cours nous allons apprendre à manipuler un compilateur\r\n\r\n## Setup\r\n\r\nPour ce cours vous aurez besoin d'un moyen de compiler, c'est-à-dire éxécuter votre programme.\r\n\r\nPour ce faire, nous allons utiliser (https://www.tutorialspoint.com/compile_c_online.php)\r\n\r\nVous pourrez écrire votre code dans le champ de gauche puis **Execute** pour obtenir le résultat dans la console à droite\r\n\r\nIl sera possible de passer des informations en entrée de votre programme dans l'onglet STDIN.\r\n",m="# Variables et Types primitifs\r\n\r\n## Introduction\r\n\r\nUn programme informatique a généralement pour but de manipuler des **données**.\r\n\r\nCes données peuvent être très diverses et sont représentées de manière tout aussi diverses selon les langages de programmation.\r\n\r\nDans la plupart des langages, on utilise des **types**, qu'on pourrait décrire comme des **catégories**, pour caractériser les données.\r\n\r\n## Variables\r\n\r\nLes variables sont les éléments de notre code qui vont nous permettre de stocker des informations de manière durables. Une variable possède une donnée ainsi qu'un nom.\r\n\r\nLe nom permet d'identifier la variable donc il faut être assez clair lors du nommage pour que l'on comprenne la donnée qu'elle stocke.\r\n\r\nVoici quelques exemples:\r\n\r\n```\r\n  quantite_de_farine = 100\r\n  mot = patate\r\n  je_suis_un_robot = vrai\r\n```\r\n\r\nCe n'est pas du vrai code juste un exemple pour vous donnez une idée.\r\n\r\n## Types\r\n\r\nLes variables possède un type même si c'est parfois implicites.\r\n\r\nIl existe une multitude de types différents en fonction des langages de programmation mais certains se démarquent par le fait qu'ils sont présent dans tous les langages typés.\r\n\r\nOn appelle ces types des **types primitifs**. Ce sont les types les plus basiques. Ils sont rangés en plusieurs familles :\r\n\r\n- Les nombres (**number**) : permettent de stocker des **nombres**.\r\n  Ils sont parfois divisés en deux sous catégories :\r\n\r\n- Les types entiers : permettent de stocker un **nombre entier**.\r\n  Cette famille est composée de : **int**, **byte**, **short** et **long** (**int** est le plus courant).\r\n\r\n  ```\r\n    int quantiteDeFarine = 100\r\n  ```\r\n\r\n- Les types flottants : permettent de stocker un **nombre à virgule**.\r\n  Cette famille est composée de : **float** et **double** (**float** est le plus courant).\r\n\r\n  ```\r\n    float poidDuLivre = 0.5\r\n  ```\r\n\r\n- Le type caractère **char** permet de stocker un seul caractère de la table **ASCII**. Cette table contient toutes les lettres, les chiffres et les symboles occidentaux.\r\n\r\n  ```\r\n    char lettre = 'a'\r\n  ```\r\n\r\n- Le type booléen **boolean** permet de stocker une information booléene, c'est-à-dire, une information à **deux** valeurs possibles (Ex : oui ou non, vrai ou faux, 1 ou 0, etc.).\r\n\r\n  ```\r\n    boolean jeSuisUnRobot = true\r\n  ```\r\n\r\nEnfin, dans tout les langages il existe des tableaux. Un tableau est généralement représenter par des crochets comme ceci [ ]. Un tableau ne peut contenir qu'un seul type de donnée soit des **char**, soit des **nombres**,...\r\n\r\n```\r\n  char mot[7] = { 'b','o','n','j','o','u','r'};\r\n```\r\n\r\nIci le tableau a une taille de 7 cela veut dire qu'il stocke 7 éléments ni plus ni moins !\r\n\r\nUn tableau comme son nom l'indique est une suite d'emplacements. Pour naviguer dans un tableau, on utilise un index qui représente la position d'un élement dans un tableau. Attention ! En programmation, on compte à partir de 0 et pas de 1 donc le premier élément est à l'index 0 et non pas 1.\r\n\r\n```\r\n  mot[0] // affiche b\r\n  mot[1] // affiche o\r\n  mot[6] // affiche r\r\n```\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",v="# Affichage Console\r\n\r\n## Introduction\r\n\r\n*Coming soon...*\r\n\r\n## Contenu\r\n\r\n*Coming soon...*\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",b="# Conditions Booléennes\r\n\r\n## Introduction\r\n\r\n*Coming soon...*\r\n\r\n## Contenu\r\n\r\n*Coming soon...*\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",h="# Boucles de Contrôle\r\n\r\n## Introduction\r\n\r\n*Coming soon...*\r\n\r\n## Contenu\r\n\r\n*Coming soon...*\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",g={environnement_travail_c:p,types_primitifs_variables:m,affichage_console:v,conditions_booleennes:b,boucles_controle:h},f="# Environnement de travail\r\n\r\n## Introduction\r\n\r\nJava est un langage de programmation **orienté objet**. Le but de ce langage est de produire un code **facilement maintenable et modulable**.\r\n\r\nCe langage est généralement utilisé dans des contextes **client-serveur**. Ils existent de nombreux langages et outils qui dérivent du Java comme [Spring](https://spring.io/).\r\n\r\nDans ce cours nous allons configurer notre environnement de travail Java.\r\n\r\n## Setup\r\n\r\nPour le bien de ce cours nous aurons d'abord besoin d'installer :\r\n\r\n+ une version du [Java Development Kit](https://www.oracle.com/java/technologies/javase-downloads.html)\r\n+ l'environnement de travail [Eclipse](https://www.eclipse.org/downloads/)\r\n\r\nLe JDK est l'ensemble des outils nécessaire à notre machine pour pouvoir **lire et exécuter** du code Java.\r\n\r\nNous avons choisi Eclipse comme IDE (integrated development environment) pour ce cours mais il en existe d'autres, notamment [IntelliJ](https://www.jetbrains.com/fr-fr/idea/)\r\n\r\n## Architecture\r\n\r\nPour coder en Java, on créer des **projets** qui sont stockés en tant que **dossier** sur votre PC. Les projets peuvent être arrangés dans ce qu'on appelle une **workspace**.\r\n\r\n*Remarque : le concept de workspace ou d'espace de travail est présent et nécessaire sur Eclipse mais ce n'est pas le cas sur d'autres IDE notamment les plus récents.*\r\n\r\nChaque projet contient un dossier `src` qui est le dossier source qui contiendra votre code.\r\n\r\n*Remarque : le dossier de projet contient également un dossier `dist` ou `build` qui contient le code compilé du projet mais on ne modifie jamais soit même le contenu de ce dossier.*\r\n\r\nLe dossier src peut contenir des sous dossiers appelés **packages**. Les packages permettent d'organiser le code par \"famille\". Nous verrons plus tard sa vraie utilité lorsque nous aborderons le sujet des dépendances.\r\n\r\nEnfin on retrouve les **classes** qui sont le modèle de définition de nos objets comportant des **attributs**, c'est-à-dire des **caractéristiques**, et des **méthodes** qui décrivent le **comportement** des objets.\r\n\r\n## Créer un projet\r\n\r\nPour créer un projet Java sous Eclipse il faut tout d'abord lancer Eclipse sur une workspace existante ou bien en créer une nouvelle.\r\n\r\nUne fois dans votre workspace vous pouvez créer un projet :\r\n\r\n+ via le menu : `File > New > Java Project`\r\n+ via l'interface : `Clic droit > New > Java Project`\r\n\r\nIl vous sera ensuite demander de nommer votre projet, les autres options ne nous intéresse pas pour le moment et vous pouvez ensuite appuyer sur `Finish`.\r\n\r\nLe projet et son architecture sont alors créés, il ne vous reste plus qu'a créer :\r\n\r\n+ vos packages : `src (clic droit) > New > Package`\r\n+ vos classes : `package (clic droit) > New > Class`\r\n\r\n*Remarque : Eclipse créé un package de base lors de la création de la première classe de votre projet si vous n'aviez pas créer de package auparavant.*\r\n",q="# Classes et Attributs\r\n\r\n## Introduction\r\n\r\nUne classe Java est une **structure** permettant de décrire l'implémentation d'un **objet** dans notre programme. C'est le code de cette classe qui va nous permettre de décrire **à quoi va ressembler** notre objet à sa création et les **actions possibles** sur celui-ci.\r\n\r\nDans ce cous nous allons voir comment se construit un bloc classe ainsi que les objets et leurs caractéristiques.\r\n\r\n## Composition\r\n\r\nUne classe est un bloc de code qui va contenir toutes les informations concernant nos objets :\r\n\r\n```\r\npublic class Toto {\r\n  // code goes here\r\n}\r\n```\r\n\r\nIci la classe `Toto` va nous permettre de pouvoir manipuler des objets de type `Toto`.\r\n\r\nPour décrire un objet, la classe est composée d'**attributs** et de **méthodes**.\r\n\r\n### Les attributs\r\n\r\nLes attributs sont des **variables** qui décrivent l'état d'un objet. Comme toute variable, ils possèdent un **nom** et un **type de donnée**. Ils possèdent également une **visibilité** et éventuellement des **propriétés**.\r\n\r\nVoici un exemple tout simple :\r\n\r\n```\r\nint age;\r\n```\r\n\r\nIci on représente l'**age** d'un individu par un **nombre entier**. La variable s'appelle `age` et n'a pas encore de valeur.\r\n\r\n### Nommage\r\n\r\nPar convention on nomme **les classes** en respectant le **PascalCase** (majuscule à chaque mot, pas d'espace ou de tiret).\r\nOn nomme **les attributs et les méthodes** en respectant le **camelCase** (majuscule à partir du deuxième mot, pas d'espace ou de tiret).\r\n\r\n### Types\r\n\r\nIls existent en Java comme dans les autres langages deux catégories de type de donnée. Les types **primitifs** et les types **complexes**.\r\n\r\nLes types primitifs sont les suivants :\r\n\r\n+ `int, byte, short, long` : pour stocker des **nombres entiers**\r\n+ `float, double` : pour stocker des **nombres à virgule**\r\n+ `char` : pour stocker des **caractères** (lettres, chiffres, symboles, etc.)\r\n+ `boolean` : pour stocker une information booléenne c'est à dire qui ne peut prendre que **deux valeurs** (ex : vrai ou faux, 0 ou 1)\r\n\r\n*Remarque : les différents types permettants de stocker des nombres entier ou à virgule ne varie que par la taille de l'emplacement mémoire qui leur est attribué. Cela change la valeur maximale ou minimale que la variable peut prendre.*\r\n\r\n*Remarque : pour les nombres entier le `int` est le type le plus courant, pour les nombres à virgule c'est le `float`*\r\n\r\nLes types complexes sont des types composés eux même d'autres types comme par exemple `String` ou notre propre type `Toto`.\r\n\r\nOn peut créer des objets de types complexes mais **pas de types primitifs**.\r\n\r\nQuelques cas concrets :\r\n\r\n```\r\nint age = 20;\r\nfloat moyenne = 13.65;\r\nchar note = 'A'\r\nboolean estGenial = true;\r\n```\r\n\r\n## Les Tableaux\r\n\r\nTout comme dans de nombreux autres langages il est possible de créer des tableaux d'objets ou de valeurs en Java.\r\n\r\nCes tableaux peuvent stocker des objets d'un type donné dans des **cases mémoires**.\r\n\r\nUn tableau à une taille **non dynamique**, on peut effectuer des actions simples dessus comme **la récupération, l'ajout ou le retrait** d'éléments.\r\n\r\n*Remarque : il existe de nombreuses autres actions plus complexes sur les tableaux mais nous en parlerons plus tard.*\r\n\r\n**Exemple** :\r\n\r\n```\r\npublic class Toto {\r\n  int age;\r\n  int[] notes;\r\n}\r\n```\r\n\r\n## Visibilité\r\n\r\nIl existe plusieurs niveau de visibilité pour les classes, les attributs ou bien encore les méthodes :\r\n\r\n+ `public` : visible et accessible par **tout le reste du programme**.\r\n+ `private` : visible et accessible uniquement dans la **classe**.\r\n+ `protected` : visible et accessible uniquement dans le **package**.\r\n\r\nUne bonne utilisation de la visibilité serait la suivante :\r\n\r\n```\r\npublic class Toto {\r\n  private String nom;\r\n  private int age;\r\n  public boolean estUnIdiot = true;\r\n}\r\n```\r\n\r\nDans le bloc de code ci-dessus, la classe `Toto` est en `public` car on souhaite pouvoir accéder aux informations décrivant un objet de type `Toto` dans le reste du code pour pouvoir par exemple **créer et manipuler** des objets de ce type.\r\n\r\nLes attributs `nom` et `age` sont en `private` car la valeur de ces attributs ne doit être modifiable que par l'objet qui les stocke.\r\n\r\nL'attribut `estUnIdiot` est en public, la valeur de ce booléen peut être modifié n'importe où dans le code également.\r\n\r\n*Remarque : dans la grande majorité du temps les attributs d'objets sont en `private` pour maintenir la sécurité du code, on appelle ça l'encapsulation de donnée.*\r\n\r\n*Remarque : bien que la visibilité `protected` existe, on ne l'utilise quasiment jamais car il est rare de créer une situation où elle serait utile.*\r\n\r\n## Propriétés\r\n\r\nIl existe plusieurs propriétés pour les attributs :\r\n\r\n+ **static** : la valeur de l'attribut est **commune à toutes les instances de la classe**.\r\n+ **final** : la valeur de l'attribut **ne peut pas être modifié après la première instanciation**.\r\n\r\nPour reprendre l'exemple au dessus :\r\n\r\n```\r\npublic class Toto {\r\n  private final String nom;\r\n  private int age;\r\n  public static boolean estUnIdiot = true;\r\n}\r\n```\r\n\r\nL'attribut `nom` est en `final` car on ne change pas de nom une fois qu'on en a un généralement. C'est une **constante**.\r\nL'attribut `age` n'est en `final` car sa valeur va être amenée à **changer plusieurs fois**. (en tout cas on l'espère pour Toto).\r\nL'attribut `estUnIdiot` est en `static` ce qui indique que la valeur de cette attribut est **commune à tous les objets de type** `Toto`. Elle peut cependant être modifié ce qui effectuera la modification pour tous les `Toto`\r\n\r\nVoici un exemple plus spécifique :\r\n\r\n```\r\npublic class Chien {\r\n  private static final boolean estMoinsBienQueLesChats = true;\r\n}\r\n```\r\n\r\nIci l'attribut indique que **pour n'importe quel chien**, son attribut `estMoinsBienQueLesChats` est **toujours vrai** et il **ne peut pas être modifié**.\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",x="# Méthodes\r\n\r\n## Introduction\r\n\r\nLes méthodes représentent **l'ensemble des comportements d'un objet** ou bien encore **les actions qu'il peut accomplir** ou bien **les changements que l'on peut effectuer sur celui-ci**.\r\n\r\nLes méthodes sont des fonctions qui font partie du bloc classe tout comme les attributs.\r\n\r\n## Composition\r\n\r\nLes méthodes sont des **blocs d'instructions composés** d'un **prototype** suivi d'une ou plusieurs lignes de code.\r\n\r\nLe prototype d'une méthode suit cette structure : `visibilité propriété valeur_de_retour nom (paramètres_entrées)` comme ci-dessous :\r\n\r\n```\r\npublic static int addition(int premierNombre, int deuxiemeNombre){\r\n  return premierNombre + deuxiemeNombre;\r\n}\r\n```\r\n\r\nLa méthode est `public`, elle est donc **visible par tout notre code**, elle est également `static` donc elle peut être appelée **sans l'aide d'un objet**.\r\n\r\n*Remarque : nous reviendrons sur la façon d'appeler une méthode un peu plus tard.*\r\n\r\nElle s'appelle `addition` et prend en paramètre d'entrée deux nombres de type `int` : `premierNombre` et `deuxiemeNombre`.\r\n\r\nElle **renvoie la somme** de ces deux nombres sous la forme d'une valeur entière d'où `int`.\r\n\r\n## Le constructeur\r\n\r\nLe constructeur est une méthode particulière qui permet **d'instancier des objets** c'est à dire de les **initialiser** pour pouvoir ensuite les manipuler.\r\n\r\nGénéralement un constructeur permet de **donner des valeurs aux attributs** du futur objet à créer mais on peut s'en servir pour faire bien d'autres choses.\r\n\r\nIl se déclare toujours par le **nom de la classe** en question. Comme toutes autres méthodes il peut prendre des paramètres d'entrées.\r\n\r\nVoici un exemple :\r\n\r\n```\r\npublic class Chien {\r\n  private int age;\r\n  private final String nom;\r\n\r\n  public Chien(int age, String nom){\r\n    this.age = age;\r\n    this.nom = nom;\r\n  }\r\n}\r\n```\r\n\r\nIci le constructeur de `Chien` nous permet d'attribuer des valeurs à l'`age` et au `nom` du chien que l'on souhaite créer.\r\n\r\nLe `this` fait référence à **l'objet courant**.\r\n\r\n*Remarque : une classe peut contenir plusieurs constructeurs tant que ceux ci ne créé pas des objets similaires, c'est à dire qu'ils ne prennent pas les mêmes paramètres d'entrées. Cela permet une plus versatilité des objets.*\r\n\r\n### Objet courant\r\n\r\nDans le contexte d'une méthode Java, l'objet courant est **un objet du type de la classe dans laquelle on se situe**.\r\n\r\nL'objet courant fait référence à **l'objet qui a appelé la méthode** ce qui nous permet d'accéder aux attributs de cet objet ou bien encore aux méthodes de la classe de cet objet.\r\n\r\n*Remarque : dans le cadre du constructeur, `this` fait référence à l'objet qu'on est en train de créer*\r\n\r\nC'est une notion assez abstraite alors voici un exemple :\r\n\r\n```\r\npublic class Chien {\r\n  private int age;\r\n  private String nom;\r\n  private String race;\r\n\r\n  // créer un chien qui possède un nom, un age mais pas de race\r\n  public Chien(int age, String nom) {\r\n    // l'age du chien créé aura pour valeur celle passée en entrée\r\n    this.age = age;\r\n    // de même pour le nom\r\n    this.nom = nom;\r\n  }\r\n\r\n  // créer un chien complet\r\n  public Chien(int age, String nom, String race) {\r\n    // on appelle le premier constructeur pour s'occuper de l'age et du nom de la même façon\r\n    this(age, nom);\r\n    // on associe la valeur pour la race du chien\r\n    this.race = race;\r\n  }\r\n}\r\n```\r\n\r\n*Remarque : l'exemple ci dessus sert a montrer la capacité de `this` à accéder a des attributs tout comme des méthodes. Dans les faits faire deux constructeurs ici n'est pas très utile.*\r\n\r\n## Getter et Setter\r\n\r\nLes getters et les setters sont des méthodes standardes de **manipulation d'attributs**.\r\n\r\nLes getters permettent de **récupérer une valeur** et les setters permettent de **modifier une valeur**.\r\n\r\nPar convention on nomme les getters `get[nomAttribut]` et les setters `set[nomAttribut]`.\r\n\r\nEn reprenant notre classe précédente :\r\n\r\n```\r\npublic class Chien {\r\n  private int age;\r\n  private String nom;\r\n\r\n  public int getAge(){\r\n    // on récupère l'age du chien qui appelle la méthode\r\n    return this.age;\r\n  }\r\n\r\n  public void setNom(String nom){\r\n    // on modifie le nom du chien qui appelle la méthode\r\n    this.nom = nom;\r\n  }\r\n}\r\n```\r\n\r\n*Remarque : Il est possible de générer automatiquement le constructeur, les getters et les setters sur la plupart des IDE modernes.*\r\n\r\n## ToString\r\n\r\nLa méthode `toString` est par convention la méthode que l'on utilise pour **afficher les informations d'un objet**.\r\n\r\n*Remarque : par convention la méthode `toString` ne permet pas d'afficher directement le message, seulement de le créer*\r\n\r\nElle se construit généralement de cette façon :\r\n\r\n```\r\npublic String toString() {\r\n  String s = // le message que l'on souhaite produire\r\n  return s; // renvoie le message pour un affichage possible plus tard\r\n}\r\n```\r\n\r\nUne fonctionnalité importante de la chaîne de caractère et donc de la génération de message est la **concaténation**.\r\n\r\n### La concaténation\r\n\r\nLa concaténation est une propriété de la chaîne de caractère à pouvoir convertir des données de types différents en chaîne de caractères.\r\n\r\nPour cela on utilise le symbole `+`.\r\n\r\n*Remarque : le symbole `+` ici n'a pas le même sens que le `+` de l'addition. C'est le cas d'autres symboles en Java ou dans d'autres langages. Leur sens dépend du contexte.*\r\n\r\nVoici un exemple :\r\n\r\n```\r\nString s = \"Bonjour je m'appelle \" + this.getNom() + \" et j'ai \" + 12 + \" ans !\";\r\n```\r\n\r\nOn obtient par exemple : `Bonjour je m'appelle Toto et j'ai 12 ans !`\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",j="# Programme Principal\r\n\r\n## Introduction\r\n\r\nLe main en Java est une **méthode** qui représente le **programme principal**, c'est le bloc de code qui sera executé au lancement de l'**éxécution** du projet.\r\n\r\nLe main est généralement dans **une classe à part**. On peut le générer facilement dans tous les frameworks.\r\n\r\nC'est dans celui-ci qu'on **instancie et manipule nos objets** et que l'on **intéragit avec l'utilisateur** via la console par exemple.\r\n\r\n## Instancier des objets\r\n\r\nOn doit instancier nos objets Java pour pouvoir les manipuler. Pour cela on leur attribut de l'espace mémoire grâce à l'outil `new`.\r\n\r\nUn exemple d'instanciation :\r\n\r\n```\r\nChien chien = new Chien(4, \"Pluto\");\r\n```\r\n\r\nIci on instancie un objet de type `Chien`. Le nom de variable de l'objet est `chien`. Le chien a 4 ans et il s'appelle Pluto.\r\n\r\nOn a donc :\r\n\r\n```\r\nchien.age = 4\r\nchien.nom = Pluto\r\n```\r\n\r\nLes tableaux suivent le même comporter et doivent être instancier avant utilisation tout comme les objets :\r\n\r\n```\r\n// 10 indique la taille du tableau qui peut alors stocker 10 éléments\r\nint tab[] = new int[10]\r\n```\r\n\r\n## Affichage console\r\n\r\nOn peut afficher des **chaînes de caractères** dans la console via la commande `print()` ou `println()`\r\n\r\n*Remarque : la deuxième est la plus courante et permet de sauter une ligne dans l'affichage après avoir afficher le contenu.*\r\n\r\nVoici un exemple :\r\n\r\n```\r\nSystem.out.println(\"Hello World !\");\r\n```\r\n\r\nOn obtient alors dans la console : `Hello world !`\r\n\r\n## Exercices\r\n\r\n### Exercice 1 : Tel chien, tel maître\r\n\r\nOn souhaite représenter un chien et son maitre. Tous les deux possède un nom. Le maitre ne peut posséder qu'un seul chien.\r\nLe maître doit pouvoir produire le message suivant : `Je m'appelle [nom_du_maitre] et voici mon chien [nom_du_chien] !`\r\n\r\n1. Identifiez les **objets** à implémenter et créez en conséquence les **classes** nécessaires. Identifiez ensuite les **attributs** de ces objets et implémentez les dans vos classes. Vous créerez également les **constructeurs**, **getters**, **setters** et autres méthodes nécessaires à la manipulation de vos objets.\r\n\r\n2. Développez un **programme principal** permettant de produire ce résultat :\r\n\r\n`Je m'appelle Mario et voici mon chien Pito !`\r\n\r\n`Je m'appelle Luigi et voici mon chien Malo !`\r\n\r\n`Je m'appelle Mario et voici mon chien Malo !`\r\n\r\nIl n'y a pas d'**intervention utilisateur** dans le programme principal. Celui ci doit uniquement **instancier des objets** et **afficher le résultat** potentiel de méthodes dans la console. Il ne doit pas y avoir d'**algorithmie** dans le programme principal !\r\n\r\n### Exercice 2 : Compte bancaire\r\n\r\nOn souhaite représenter un utilisateur et son compte bancaire. Chaque utilisateur possède un nom et un solde de compte (en euros).\r\nL'utilisateur doit pouvoir produire le message suivant : `Je m'appelle [nom_utilisateur] et j'ai [solde_compte] euros !`\r\n\r\nOn doit pouvoir débiter et créditer le compte. Le débit ne peut se faire que si la somme souhaitée est présente sur le compte. L'action de débiter ou créditer doit produire des messages de réussite ou d'erreur comme suit :\r\n\r\n+ Pour le crédit : `Compte de [nom_utilisateur] crédité de [somme] euros !`\r\n+ Pour le débit (succès) : `Compte de [nom_utilisateur] débité de [somme] euros !`\r\n+ Pour le débit (échec) : `Erreur : Impossible de débiter le compte de [nom_utilisateur] de [somme] euros, solde insuffisant :(`\r\n\r\n1. Identifiez les **objets** à implémenter et créez en conséquence les **classes** nécessaires. Identifiez ensuite les **attributs** de ces objets et implémentez les dans vos classes. Vous créerez également les **constructeurs**, **getters**, **setters** et autres méthodes nécessaires à la manipulation de vos objets.\r\n\r\n2. Développez un **programme principal** permettant de produire ce résultat :\r\n\r\n`Je m'appelle Clubbo et j'ai 10 euros !`\r\n\r\n`Erreur : Impossible de débiter le compte de Clubbo de 20 euros, solde insuffisant :(`\r\n\r\n`Compte de Clubbo crédité de 35 euros !`\r\n\r\n`Compte de Clubbo débité de 20 euros !`\r\n\r\n`Je m'appelle Clubbo et j'ai 25 euros !`\r\n\r\nIl n'y a pas d'**intervention utilisateur** dans le programme principal. Celui ci doit uniquement **instancier des objets** et **afficher le résultat** potentiel de méthodes dans la console. Il ne doit pas y avoir d'**algorithmie** dans le programme principal !\r\n\r\n### Exercice 3 : Tableau de chasse\r\n\r\nLe but de cet exercice est de reprendre les structures de données de l'exercice 1 et d'automatiser le processus de production de message pour un **groupe de maître et de chien**. On doit pouvoir stocker en mémoire 5 maîtres et 5 chiens différents et **pour chacun** des maîtres produire leur message respectif.\r\n\r\nDéveloppez un **programme principal** permettant de produire ce résultat :\r\n\r\n`Je m'appelle Tata et voici mon chien Dada !`\r\n\r\n`Je m'appelle Tete et voici mon chien Dede !`\r\n\r\n`Je m'appelle Titi et voici mon chien Didi !`\r\n\r\n`Je m'appelle Toto et voici mon chien Dodo !`\r\n\r\n`Je m'appelle Tutu et voici mon chien Dudu !`\r\n\r\n**Attention !** Votre programme ne doit contenir qu'**un seul appel à la console** (un seul `System.out.print()`) !\r\n",y="# Enumerations\r\n\r\n## Introduction\r\n\r\nLes énumerations, ou Enum, permettent de créer une **famille de valeurs possibles pour représenter un concept**.\r\n\r\nL'Enum n'est pas une classe et ces valeurs ne sont pas des objets à part entière. Un Enum est **une liste de constantes**.\r\n\r\n## Usage\r\n\r\nOn peut se servir des valeurs d'un Enum pour attribuer une valeur à **des attributs ou des variables**.\r\n\r\nLes Enums sont utiles lorsque **l'on sait que l'on va avoir des valeurs qui ne vont jamais changer** comme les mois, les jours de la semaine ou encore les couleurs.\r\n\r\n## Composition et Utilisation\r\n\r\nUn Enum contient essentiellement des valeurs possibles :\r\n\r\n```\r\npublic Enum Couleur {\r\n  rouge, vert, bleu, jaune;\r\n}\r\n```\r\n\r\nVoici un cas d'utilisation dans une classe :\r\n\r\n```\r\npublic class Peinture {\r\n  private int prix;\r\n  private Couleur couleur;\r\n}\r\n```\r\n\r\nEt un exemple d'instanciation :\r\n\r\n```\r\nPeinture p = new Peinture();\r\np.couleur = Couleur.rouge;\r\n```\r\n\r\nOn voit ici un cas concret d'utilisation d'un Enum et comment accéder à une valeur de cet Enum.\r\n\r\nIci l'Enum est très simple et ne stocke que des valeurs mais il peut être plus complexe.\r\n\r\n## Paramétrage\r\n\r\nUn Enum peut avoir des **attributs**. **Chacune de ses constantes** possède une valeur pour ses attributs. On dit que l'Enum est **paramétré**.\r\n\r\nVoici un exemple :\r\n\r\n```\r\npublic Enum Couleur {\r\n  rouge('r'),\r\n  vert('v'),\r\n  bleu('b'),\r\n  jaune('j');\r\n\r\n  private char symbole;\r\n\r\n  private Couleur(char symbole){\r\n    this.symbole = symbole;\r\n  }\r\n\r\n  public char getSymbole(){\r\n    return this.symbole;\r\n  }\r\n}\r\n```\r\n\r\nDans l'exemple du dessus, on associe à chaque couleur un `symbole` représenté par un caractère.\r\n\r\nSi un Enum est paramétré alors on créé un **constructeur privé** capable d'instancier toutes ses constantes et éventuellement des **getters et des setters**.\r\n\r\n*Remarque : le constructeur n'est utile que pour paramétrer les constantes existantes ou pour ajouter de nouvelles constantes durant le programme (ici de nouvelles couleurs), on n'a pas besoin d'instancier les constantes d'un Enum avant emploi car ce ne sont pas des objets !*\r\n\r\n## Méthodes\r\n\r\nLes méthodes de la classe `Enum` sont les suivantes :\r\n\r\n+ `values()` : renvoie toutes les constantes de l'Enum sous forme de tableau\r\n+ `ordinal()` : renvoie l'index de la constante appelante dans la liste de constantes\r\n+ `valueOf(String)` : retourne la constante correspondante à la chaine de caractère si la constante du même nom existe dans l'Enum\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",L="# Bibliothèques\r\n\r\n## Introduction\r\n\r\nEn Java comme dans bon nombre d'autres langages de programmation, il est possible d'exploiter du **code externe** a votre programme afin d'éviter de **recoder des fonctionnalitées qui existe déjà**.\r\n\r\nCela se fait via l'**importation de bibliothèques** qui contiennent des **classes** avec leurs attributs et leurs méthodes.\r\n\r\n## Importer des bibliothèques\r\n\r\nIl y a une syntaxe précise à respecter pour importer une bibliothèque dans un projet :\r\n\r\n`[nomDeLaBibliotheque].[nomDuPackage].[nomDeLaClasse];`\r\n\r\nLes imports se situe toujours au dessus du bloc classe qui souhaite les utiliser.\r\n\r\nAinsi, pour importer la classe `ArrayList` on écrit : `import java.util.ArrayList;`\r\n\r\nIci `java` fait référence à la bibliothèque Java standard. On recherche la classe `ArrayList` se trouvant dans le package `util`.\r\n\r\nGrâce à cet import on peut dorénavant, dans le cadre de la classe qui fait l'import, créer et manipuler des objets de type `Arraylist`. On peut également utiliser ses attributs et méthodes.\r\n\r\nVoici un exemple :\r\n\r\n```\r\n// on import la classe que l'on souhaite utiliser\r\nimport java.util.ArrayList;\r\n\r\npublic class Toto {\r\n  // un attribut de type ArrayList\r\n  // qui représente une liste de notes\r\n  private ArrayList<Note> notes;\r\n\r\n  public Toto() {\r\n    // une ArrayList est un objet\r\n    // donc on l'instancie avant emploi\r\n    // à la création de l'objet Toto\r\n    this.notes = new ArrayList<Note>();\r\n\r\n    // un exemple d'utilisation\r\n    // d'une méthode de la classe\r\n    // ArrayList, ici removeAll\r\n    this.notes.removeAll()\r\n  }\r\n}\r\n```\r\n\r\n*Remarque : on ne détaille pas le fonctionnement de la classe `ArrayList` ici. Cet exemple à pour but de montrer ce qu'il est possible grâce à un import*\r\n\r\nOn peut importer tout le contenu d'une bibliothèque ou d'un package en utilisant `*` :\r\n\r\n```\r\nimport java.util.*;\r\n```\r\n\r\nCet import permet de récupérer le contenu de toutes les classes contenu dans le package `util` de la bibliothèque `java`.\r\n\r\nVous pouvez également importer vos propres classes vers d'autres parties de votre programme si elle en ont besoin. Par exemple on import la classe à tester dans la feuille de tests unitaires.\r\n\r\n*Remarque : la plupart des IDE permettent l'importation automatique des bibliothèques nécessaires au fonctionnement de votre code. Vous aurez donc rarement besoin de vous en soucier.*\r\n\r\n*Remarque : Il existe d'autres outils permettant l'exploitation de code externe autre que l'import en brut dans le code mais nous n'en parlerons pas dans ce cours.*\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",C="# Collection et Iterable\r\n\r\n## Introduction\r\n\r\nIl existe de nombreuses façon d'**organiser des données** autrement qu'avec des tableaux en Java.\r\n\r\nL'architecture des bibliothèques proposant des solutions est **très vaste** et nous allons la parcourir de manière succinte.\r\n\r\nToutes se basent sur `Collection` et `Iterable` qui sont des interfaces (pas besoin de savoir ce qu'est une interface pour le moment) donnant leurs propriétés aux classes qui nous intéresse dans ce cours.\r\n\r\nIl existe trois grandes familles d'iterable c'est à dire de **structure de données pouvant être parcourue** : Les `List`, Les `Queue` et Les `Set`.\r\n\r\nToutes ces classes sont ce qu'on appelle des `Collection` car elles regroupent un ensemble de données accessible en un point.\r\n\r\nAvant tout il faut savoir que les tableaux ainsi que les iterables peuvent être **parcouru via une boucle particulière** appelée le `forEach`.\r\n\r\n## forEach\r\n\r\nLe `forEach` en Java est une boucle très similaire au `for` et qui permet de **parcourir des structures de données de manière plus intuitive**.\r\n\r\nIl se construit de cette façon : `for([type_objet] [nom_objet] : [structure à parcourir])`\r\n\r\nLe paramètre de gauche représente un objet dans la structure à parcourir. C'est **l'objet courant dans la boucle**. Le nom de l'objet importe peu tout comme l'index dans un `for` classique.\r\n\r\nLe paramètre de droite est la variable qui représente la structure à parcourir. L'interêt majeur du `forEach` est que l'on a pas besoin de se soucier de la taille de structure à parcourir contrairement à un `for` classique.\r\n\r\nVoici un exemple d'utilisation :\r\n\r\n```\r\n// une variable représentation un livre\r\n// sous la forme d'un tableau d'objet\r\n// de type Page\r\nPage[] livre = new Page[10];\r\n\r\n// la boucle forEach parcourt\r\n// chaque page du livre\r\nfor (Page page : livre) {\r\n  // on écrit sur chaque page\r\n  // du livre\r\n  page.ecrire(\"Je suis une super page !\");\r\n}\r\n```\r\n\r\n*Remarque : on part du principe que la classe `Page` contient une méthode s'appelant `ecrire`. Son fonctionnement n'est pas le propos de l'exemple.*\r\n\r\nIci on parcourt le tableau de pages `livre`. Pour chaque page contenu dans `livre` on écrit dedans `Je suis une super page !`\r\n\r\n*Remarque : la boucle forEach permet de parcourir toutes les structures de données que nous allons voir dans ce cours.*\r\n\r\n## List\r\n\r\nUne `List` est une séquence d'objets qui peut être **organisée comme on le souhaite**.\r\n\r\nOn peut y **ajouter** et en **retirer** des éléments, **les doublons sont autorisé** ainsi que les **objets vide**.\r\n\r\nOn peut **récupérer** un élément grâce à son **index** tout comme on le ferait dans un tableau.\r\n\r\nLa différence majeure entre une liste et un tableau est que la liste est **dynamique** c'est à dire qu'elle adapte **automatiquement** sa **taille** en fonction des actions faite sur celle-ci (ajout et retrait d'éléments notamment).\r\n\r\nLorsqu'on instancie une liste on doit préciser le type d'objet qu'elle va contenir de cette façon :\r\n\r\n```\r\nList<Chien> chiens = new ArrayList<>();\r\n```\r\n\r\nLa liste `chiens` pourra donc stocker des objets de type `Chien`. On indique le type d'objet attendu dans la liste entre chevrons `<>`.\r\n\r\n`List` n'est pas un objet mais une interface on doit donc utiliser une implémentations de `List` pour pouvoir la manipuler.\r\n\r\nL'implémentation la plus courante de `List` est `ArrayList`.\r\n\r\nUne liste ne peut stocker que des objets, si on souhaite stocker des variables de types primitifs on utilisera les classes correspondantes (ex : `Integer` pour `int`, `Character` pour `char`, etc.).\r\n\r\nVoici un exemple :\r\n\r\n```\r\n// un tableau peut stocker\r\n// des variables de\r\n// types primitifs\r\nint[] notes;\r\n\r\n// son équivalent\r\n// sous forme de liste\r\nArrayList<Integer> notes;\r\n```\r\n\r\n*Remarque : ces objets fonctionnent de manière similaire aux types primitifs mais, tout comme les autres classes, possèdent des méthodes permettant des manipulations plus avancées (se referer à la documentation). Il ne faut cependant pas en abuser et remplacer tout vos types primitifs par des objets si ce n'est pas nécessaire !*\r\n\r\n### ArrayList\r\n\r\nL'ArrayList est l'une des implémentations de la liste la plus commune. En mémoire elle est équivalente à un **tableau dyamique**.\r\n\r\nCela implique qu'il est très **peu couteux d'accéder à un élément** dans la liste mais il est **plus compliqué d'ajouter ou de retirer des éléments** car ces deux actions ont des répercussions sur le tableau qui doit etre recréér afin d'avoir la bonne taille.\r\n\r\nVoici quelques méthodes de cette classe :\r\n\r\n+ `add(Object o)` : ajoute l'objet `o` à la liste si son type correspond\r\n+ `remove(Object o)` : enlève une occurence de l'objet `o` de la liste s'il s'y trouve au moins 1 fois\r\n+ `get(index i)` : récupère l'objet de la liste à l'index `i`\r\n+ `size()` : retourne la taille de la liste (nombre d'éléments dans la liste)\r\n+ `contains(Object o)` : indique si une occurence de l'objet `o` se trouve dans la liste ou non\r\n+ `isEmpty()` : indique si la liste est vide (si la taille de la liste est égale à 0)\r\n\r\n*Remarque : la méthode `get` ne marche pas si la liste contient un objet à l'index donné. Sinon la méthode fait planter le programme donc faite attention !*\r\n\r\n*Remarque : il existe d'autres méthodes dans la classe `ArrayList`, celles-ci sont les plus communéments utilisées.*\r\n\r\nVoici un petit exemple de manipulation d'une `ArrayList` :\r\n\r\n```\r\nPage sommaire = new Page(\"Ceci est un sommaire\");\r\nList<Page> livre = new ArrayList<>();\r\n\r\n// si le livre est vide\r\n// donc qu'il 0 page\r\nif (livre.isEmpty()) {\r\n  // on ajoute la page sommaire\r\n  // dans le livre\r\n  livre.add(sommaire);\r\n}\r\n```\r\n\r\n### Manipuler une liste avec Collections\r\n\r\nLa classe `Collections` permet de manipuler des listes et autres stuctures de données similaires (donc des collections), voici une liste non exhaustive de ses fonctionnalités :\r\n\r\n+ `sort(list)` : tri le contenu de la liste par **ordre croissant**\r\n+ `shuffle(list)` : mélange le contenu de la liste (change l'ordre des éléments de manière aléatoire)\r\n+ `max(collection)` : retourne la plus grande valeur de la collection\r\n+ `min(collection)` : retourne la plus petite valeur de la collection\r\n+ `addAll(collection, elements)` : permet d'ajouter `elements` à la collection, `elements` peut être un tableau ou bien les éléments listés un par un\r\n\r\n*Remarque : il existe beaucoup d'autres méthodes plus situationnelles dans la classe `Collections`.*\r\n\r\n*Remarque : la plupart des méthodes de `Collections` se basent sur la comparaison des objets contenus pour fonctionner. Cette comparaison marche très bien et automatiquement pour des variables de type primitif mais pas pour des types complexes.*\r\n\r\n### LinkedList\r\n\r\nLa `LinkedList` est une autre implémentation de la liste une peu moins commune. Elle représente en mémoire une **chaîne** ou une **file** de données. Chaque élément à un ordre dans la liste.\r\n\r\nPlus précisément, la `LinkedList` est une liste **doublement chaînée** c'est à dire que chaque élément stocké dans la liste est **relié à son précédent et à son suivant** ainsi il est très **peu couteux d'ajouter ou de retirer des éléments** mais il est **plus compliqué d'accéder à un élément** de la liste car on doit la parcourir depuis le départ pour arriver à la destination.\r\n\r\nVoici un exemple :\r\n\r\n```\r\nList<Personne> fileAttente = new LinkedList<>();\r\n```\r\n\r\nEn plus des méthodes que l'on retrouve dans les autres implémentations de `List` comme `ArrayList`, la `LinkedList` propose les fonctionnalitées suivantes :\r\n\r\n+ `addFirst(Object o)` : ajoute l'objet `o` au **début** de la liste\r\n+ `addLast(Object o)` : ajoute l'objet `o` à la **fin** de la liste\r\n+ `removeFirst()` : retire le **premier** élément de la liste\r\n+ `removeLast()` : retite le **dernier** élément de la liste\r\n+ `getFirst()` : retourne le **premier** élément de la liste\r\n+ `getLast()` : retourne le **dernier** élément de la liste\r\n\r\n*Remarque : il existe d'autres implémentations de List mais nous ne les verrons pas ici.*\r\n\r\n## Queue\r\n\r\nLa `Queue` est une **file de donnée**, on l'utilise pour stocker des éléments de **manière temporaire avant traitement**.\r\n\r\nElle n'offre aucune fonctionnalité particulière par rapport aux listes mais certaines de ces implémentations spécifiques peuvent être utile notamment la `PriorityQueue`.\r\n\r\nSes méthodes d'usages sont les suivantes :\r\n\r\n+ `push(Objet o)` : ajoute l'objet `o` au début de la file\r\n+ `pop()` : retire le premier élément de la file\r\n\r\nVoici un exemple :\r\n\r\n```\r\n// quelques personnes\r\n// pour notre exemple\r\nPersonne toto = new Personne();\r\nPersonne titi = new Personne();\r\n\r\n// une file d'attente\r\n// contenant des personnes\r\nQueue<Personne> fileAttente = new Queue<>();\r\n\r\n// on insère toto dans\r\n// la file d'attente\r\nfileAttente.push(toto);\r\n// puis on insère titi\r\nfileAttente.push(titi);\r\n// on retite la première\r\n// personne dans la file\r\n// à savoir toto\r\nfileAttente.pop();\r\n// à partir de cette ligne\r\n// il ne reste que titi\r\n// dans la file d'attente\r\n```\r\n\r\n### PriorityQueue\r\n\r\nLa `PriorityQueue` est une file de donnée dont l'ajout de donnée provoque un tri automatique. La PriorityQueue détecte un élément de comparaison entre les objets qui la composent et les trie. Autrement elle ne possède aucune fonctionnalité particulière supplémentaire.\r\n\r\n*Remarque : Il existe d'autres implémentations de Queue mais nous ne les verrons pas ici.*\r\n\r\n## Set\r\n\r\nLe `Set` est une structure de donnée similaire à la `List` mais il **n'autorise pas de doublon**.\r\n\r\nOn ne peut pas récupérer un élément précis dans un `Set`, seulement **ajouter**, **retirer** et **faire des vérifications**.\r\n\r\nUn `Set` peut dont être utile dans les cas où l'on souhaite stocker des informations en interdisant les doublons.\r\n\r\n*Remarque : les Set sont des structures particulières et rarement utile, à utiliser avec précaution.*\r\n\r\n## Exercices\r\n\r\n### Exercice 1 : Le Grand Hotel\r\n\r\nOn souhaite représenter l'ensemble des chambres d'un hotel de luxe ainsi que sa clientèle. L'hotel n'a besoin que de connaitre le nom de ses clients.\r\nL'hotel possède une infinité d'étages, chaque étage possède au maximum 2 chambres. Une chambre possède un numéro de chambre unique.\r\nUne chambre peut accueillir jusqu'a 3 personnes, elle peut également être vide.\r\n\r\nOn doit pouvoir générer pour chaque chambre le message suivant : `Chambre n°[numero_chambre] - Etage n°[numero_etage] - Clients ([noms_clients])`\r\n`noms_clients` se construit de cette façon : `Toto Titi Tutu` si la chambre contient 3 clients se nommant ainsi. Si la chambre est vide `noms_clients` = `vide`\r\n\r\n1. Identifiez les **objets** à implémenter et créez en conséquence les **classes** nécessaires. Identifiez ensuite les **attributs** de ces objets et implémentez les dans vos classes. Vous créerez également les **constructeurs**, **getters**, **setters** et autres méthodes nécessaires à la manipulation de vos objets.\r\n\r\n2. Développez un **programme principal** ou l'appel de la méthode `toString()` de la classe `Hotel` permet de produire ce résultat :\r\n\r\n`Chambre n°1 - Etage n°1 - Clients (Toto)`\r\n\r\n`Chambre n°2 - Etage n°1 - Clients (vide)`\r\n\r\n`Chambre n°3 - Etage n°2 - Clients (Titi Tata Tutu)`\r\n",E="# Interface Utilisateur\r\n\r\n## Introduction\r\n\r\nUn scanner est un objet permettant de récupérer des informations provenant d'un flux. En java il existe différents types de flux :\r\n\r\n+ le flux de **sortie** : la console\r\n+ le flux d'**entrée** : la saisie clavier\r\n+ le flux d'**erreur** : réservé aux messages d'erreurs\r\n+ les fluxs **externes** : un fichier, une requête API ou HTTP, etc.\r\n\r\nOn peut positionner un scanner sur certains de ces flux pour en récupérer le contenu. Ici c'est uniquement le flux d'entrée qui va nous intéresser.\r\n\r\nUn objet de type Scanner s'instancie de cette manière :\r\n\r\n```\r\nScanner sc = new Scanner(System.in);\r\n```\r\n\r\nIci on vient de créer un Scanner s'appelant `sc` sur le flux d'entrée `System.in`.\r\n\r\nOn peut ensuite récupérer des informations depuis le scanner. La récupération de la saisie possède des règles qui varie selon la méthode de récupération. De manière général un scanner possède un **separator** qui indique où **découper les informations**. De base le séparator est l'**espace** ou le white space.\r\n\r\nLorsqu'on appelle une méthode de Scanner, l'utilisateur est alors ammené à écrire dans la console. Le fait d'appuyer sur la touche `Enter` exécute la méthode de récupération. Ce fonctionnement diffère dans le cadre de la récupération d'information depuis une autre source qu'un utilisateur.\r\n\r\nVoici différentes méthodes pour récupérer des informations :\r\n\r\n+ `next()` : permet de récupérer une chaîne de caractères. Attention ! Il ne doit pas y avoir d'espace à l'intérieur de la chaîne\r\n+ `nextLine()` : permet de récupérer la saisie entière sans faire de distinction sur les types de données récupérés.\r\n+ `hasNext()` : retourne vrai ou faux en fonction de si le scanner a encore du contenu à lire dans sa source.\r\n+ `nextInt()` : permet de récupérer une valeur entière. Attention ! Plante si la saisie clavier ne contient pas de nombre.\r\n\r\n*Remarque* : Tout comme pour les int, il existe des méthodes pour récupérer tous les types primitifs.\r\n\r\n## Construire une interface utilisateur\r\n\r\nUne des règles d'or de la programmation est de ne jamais faire confiance à l'utilisateur. Il faut coder en partant du principe que l'utilisateur ne vas pas nous donner l'information que l'on recherche. Ainsi il existe de nombreuses astuces pour que notre programme soit parés à la majeure partie des éventualités. Le but est d'éviter à tout prix que le programme plante.\r\n\r\nLes deux notions importantes d'une interface utilisateur sont que :\r\n\r\n+ on **sait à l'avance** ce qu'on attend de l'utilisateur\r\n+ on souhaite recevoir la bonne information et ainsi on devra **retenter jusqu'a l'obtenir**\r\n\r\nEn sachant ça, deux boucles de contrôles nous seront très utiles et fonctionnent de pairs :\r\n\r\nLe **while** nous permet via l'utilisation d'une condition booléenne de \"bloquer\" l'utilisateur jusqu'a ce qu'il est indiqué l'information souhaitée.\r\n\r\nLe **switch** nous permet d'indiquer le **comportement de notre application** en fonction du résultat de la requête auprès de l'utilsateur. Il permet aussi de gérer facilement le cas ou **l'utilisateur s'est trompé**.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nScanner sc = new Scanner(System.in);\r\nBoolean isValid = false; // le choix de l'utilisateur est il bon ?\r\n\r\nwhile (!isValid){\r\n    // print au lieu de println pour que l'utilisateur écrive\r\n    // sur cette ligne\r\n    System.out.print(\"Tapez 1 pour les mails, Tapez 2 pour les SMS >\");\r\n    // on récupère une chaîne et pas un int car on veut éviter de\r\n    // faire planter le programme\r\n    String choix = sc.next();\r\n    switch(choix){\r\n        case \"1\" :\r\n            System.out.println(\"MAILS\");\r\n            // la saisie de l'utilisateur correspond à un cas valide\r\n            isValid = true;\r\n            break; // on ne veut rentrer que dans un seul case !\r\n        case \"2\" :\r\n            System.out.println(\"SMS\");\r\n            isValid = true;\r\n        default :\r\n            System.out.println(\"Saisie invalide\");\r\n            // isValid reste a false car la saisie n'est pas valide\r\n            // on repart au début du while\r\n            break;\r\n    }\r\n}\r\nSystem.out.println(\"Fin du programme\");\r\n```\r\n\r\n*Output* :\r\n\r\n`Tapez 1 pour les mails, Tapez 2 pour les SMS >`*salade*\r\n\r\n`Saisie invalide`\r\n\r\n`Tapez 1 pour les mails, Tapez 2 pour les SMS >`*2*\r\n\r\n`SMS`\r\n\r\n`Fin du programme`\r\n\r\n*Remarque : le code au dessus est seulement un exemple qui peut et doit être adapté en fonction de la situation*\r\n\r\n## Fichier externe\r\n\r\nDans cette partie nous allons voir comment utiliser le Scanner pour **lire** des données **textuelles** dans un fichier externe.\r\n\r\nTout d'abord il faut récupérer le fichier de texte grâce à un objet de type File.\r\n\r\nOn doit instancier un objet de type File avec en paramètre le chemin (relatif ou absolu) du fichier. Le plus simple est, si vous le pouvez, de placer le fichier à la racine du projet c'est à dire au même niveau que le dossier `src`. Le scanner doit ensuite être placé sur le fichier.\r\n\r\n```\r\nFile file = new File(\"toto.txt\");\r\nScanner sc = new Scanner(file);\r\n// tant que le scanner n'est pas arrivé au bout du fichier\r\nwhile(sc.hasNext()){\r\n    // affiche le fichier ligne par ligne\r\n    System.out.println(sc.nextLine());\r\n}\r\n```\r\n\r\n*Remarque : bien qu'on ne puisse pas écrire dans un fichier avec un Scanner il y a bien d'autres façons de traiter un fichier que dans cet exemple.*\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",I="# Valeurs Aléatoires\r\n\r\n## Introduction\r\n\r\nDans un programme informatique, on peut très souvent être ammené à utiliser des valeurs aléatoires ou plutôt pseudo-aléatoire. Il y'a plusieurs façons de générer des valeurs aléatoires en Java. Nous allons en voir deux.\r\n\r\n## Random\r\n\r\nLa classe `Random` permet de générer des valeurs aléatoires dans différents types primitifs. On doit cependant indiqué la borne maximale dans le cas d'une génération de nombre.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nRandom rand = new Random();\r\nint i = rand.nextInt(100);\r\n```\r\n\r\nLa valeur de `i` est comprise entre 0 et 99.\r\n\r\n## Math.random\r\n\r\nLa méthode `random()` de la classe `Math` permet de générer une valeur aléatoire entre 0 et 1.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nfloat rand = Math.random();\r\n```\r\n\r\nOutput : `0.5568515217910215`\r\n\r\n```java\r\nint rand = (int) (Math.random() * 100) + 1;\r\n```\r\n\r\nDans l'exemple ci-dessus on voit apparaître une nouvelle notion : `(int)`. C'est ce qu'on appelle un cast.\r\n\r\n## Le cast\r\n\r\nLe cast est une fonctionnalité de l'orienté objet qui permet de transformer un objet d'un type en un autre si la conversion est possible, ce qui est loin d'être toujours le cas.\r\nC'est une fonctionnalité qu'on peut être ammené à utiliser lorsqu'on manipule des bibliothèques car nombre d'entres elles utilisent leur propre système d'objets et des conversions sont parfois nécessaire pour articuler un programme.\r\n\r\n**Exemple** :\r\n\r\n```java\r\nint resultat = (int) 12.7 + 15.3669; // = 28.0669 -> 28\r\n```\r\n\r\nLe résultat de cette ligne est normalement un nombre à virgule. Ici le cast en int va tronquer le résultat pour qu'il puisse être stocké dans la variable `resultat`.\r\n\r\n## Exercices\r\n\r\n### Exercice 1 : Envoie 'AMOUR' au 8 12 12\r\n\r\nOn souhaite créer une ~~arnaque~~ fonctionnalité permettant à un utilisateur d'entrer son nom ainsi que celui de son grand amour pour que l'application lui indique son taux de compatibilité avec celui ou celle qu'il ou elle aime. L'application peut délivrer différents résultats en fonction du taux de compatibilité :\r\n\r\n+ Pour 0% : `[user1] et [user2] = bagarre`\r\n+ Entre 1% et 25% : `[user1] et [user2] = osef`\r\n+ Entre 26% et 50% : `[user1] et [user2] = potes à la compote`\r\n+ Entre 51% et 75% : `[user1] et [user2] = BFF`\r\n+ Entre 76% et 99% : `[user1] et [user2] = amour`\r\n+ Pour 100% : `[user1] et [user2] = muy caliente`\r\n\r\nDéveloppez une interface utilisateur permettant de récupérer le nom des deux utilisateurs et de produire un message aléatoire (l'amour c'est plus ce que c'était...)\r\n",S="# Dictionnaires\r\n\r\n## Introduction\r\n\r\nLes dictionnaires ou Map sont des structures de données plus complexes qui permettent **d'associer une clé à une valeur**. Il ne peut pas y avoir plusieurs fois la même clé cependant. Cette structure fonctionne de manière quasi identique à un vrai dictionnaire pour faire une comparaison pratique.\r\nNous allons voir dans ce cours l'implémentation la plus courante de Map en java : `HashMap`.\r\n\r\n## HashMap\r\n\r\nUne HashMap est un dictionnaire qui hache les données qu'il contient c'est à dire qu'il **crypte les données** pour les rendre **plus courtes en mémoire** et accélerer la recherche dans le dictionnaire. L'**ordre de parution** des valeurs du dictionnaire n'est pas garanti lors d'un parcours. On peut parcourir la liste des clés d'un dictionnaire, ou bien la liste des valeurs ou bien encore une liste des associations clé-valeur.\r\n\r\n*Remarque* : un dictionnaire ne peut stocker que des objets que ce soit les clés ou les valeurs, ainsi si l'on souhaite stocker des valeurs de types primitifs on utilisera les classes correspondantes (ex : Integer pour int, Boolean pour boolean, Character pour char, etc.)\r\n\r\nVoici une liste de quelques méthodes utiles :\r\n\r\n+ `put(key, value)` : ajoute une association `key` - `value` dans le dictionnaire, si `key` existe déjà alors elle sera écrasée avec la nouvelle valeur\r\n+ `get(key)` : retourne la valeur associé à la clé `key`\r\n+ `remove(key)` : supprime la clé ainsi que sa valeur du dictionnaire\r\n+ `size()` : retourne le nombre d'association clé-valeur dans le dictionnaire (ou plus simplement le nombre de clés)\r\n+ `clear()` : supprime le contenu du dictionnaire\r\n\r\nPour parcourir le dictionnaire on utilise :\r\n\r\n+ `keySet()` : permet de parcourir la liste de clé du dictionnaire\r\n+ `values()` : permet de parcourir la liste de valeurs du dictionnaire\r\n\r\n**Exemple** :\r\n\r\n```java\r\n// on créé un dictionnaire qui associe un caractère a un mot\r\nMap<Character, String> dico = new HashMap<>();\r\n// on ajoute la clé 'a' associé au mot 'abricot' qui sera sa valeur\r\ndico.put('a', \"abricot\");\r\ndico.put('c', \"creascio\");\r\n\r\nfor (Character c : dico.keySet()){\r\n    // pour chaque clé dans le dico on affiche cette clé et\r\n    // la valeur associée\r\n    System.out.println(\"Key :\" + c + \" value : \" + dico.get(c));\r\n}\r\n```\r\n\r\n*Remarque* : comme les listes en java sont des objets, un dictionnaire peut avoir une liste en tant que clé ou bien en tant que valeur. Cela permettrait de mieux représenter notre dico de l'exemple précédent :\r\n\r\n```java\r\n// on créer une liste de mots\r\nList<String> motsEnC = new ArrayList<>() {{\r\n    // on ajoute directement quelques mots qui commencent\r\n    // par la lettre c\r\n    add(\"clubby\");\r\n    add(\"clubbo\");\r\n}};\r\nMap<Character, ArrayList<String>> dico = new HashMap<>();\r\n// on ajoute l'association entre la lettre c et notre liste\r\n// de mot qui commence par c dans le dictionnaire\r\ndico.put('c', motsEnC);\r\n```\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",A="# Mode Debug\r\n\r\n## Introduction\r\n\r\nLorsque notre programme plante ou ne produit pas le résultat attendu sans que l'on puisse facilement trouver la cause du problème, une bonne pratique est de lancer le programme en **mode débug**. Ce mode possède plusieurs fonctionnalités permettant de faire progresser le programme **pas à pas** c'est à dire commande par commande.\r\n\r\n## Setup\r\n\r\nAvant de lancer le programme on doit déterminer des potentiels **points d'arrêts** dans notre code où le compilateur va s'arrêter et laisser la main à l'utilisateur pour poursuivre comme il le souhaite. Généralement on place des points d'arrêts avant **les instructions qui pourraient poser problème**. Si vous n'avez aucune idée d'où provient le problème vous pouvez placer le point d'arrêt **en haut du main**.\r\n\r\n*Remarque* : il existe d'autres points que les Breakpoints (points d'arrêts) mais leur usage spécifique ne sera pas couvert dans ce cours.\r\n\r\nIl faut ensuite lancer le programme en mode debug ce qui lance une configuration particulière.\r\n\r\nSur Eclipse, pour lancer le programme en mode débug on peut faire ceci :\r\n\r\n+ **Clic droit > Debug As > Java Application**\r\n+ **Icone d'insecte dans la barre d'actions > Debug As > Java Application**\r\n\r\nUne fois le programme lancé de cette manière le compilateur ammène le programme jusqu'au premier point d'arrêt rencontré dans l'exécution.\r\n\r\n*Remarque* : si le programme nécessite des entrées utilisateurs avant ou apres un point d'arrêt il faudra les remplir comme normalement dans la console.\r\n\r\n## Mécaniques de debug\r\n\r\nL'utilisateur à ensuite à sa disposition différentes fonctionnalités :\r\n\r\n+ Step Into (F5) : redirige vers le code appelant (la méthode généralement)\r\n+ Step Over (F6) : passe à la ligne suivante sans rentrer dans le code\r\n+ Step Return (F7) : retourne dans le bloc de code précédent\r\n\r\n*Remarque* : La fonctionnalité la plus utile reste le Step Into pour faire un parcours en profondeur de l'execution de votre programme.\r\n\r\nEn fonction de votre IDE vous pouvez également avoir une vue debug qui permet de voir différentes informations comme l'état de la pile d'execution ou bien encore la valeur de chaque variable de votre programme au fil du temps.\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",w="# Tests Unitaires\r\n\r\n## Introduction\r\n\r\nLa phase de test est une partie non négligeable de tout projet informatique. Les tests unitaires permettent de s'assurer du bon fonctionnement des méthodes de notre programme.\r\n\r\n## Setup\r\n\r\nPour mettre en place des tests unitaires en Java, on utilise la bibliothèque **JUnit**. On peut rédiger un test unitaire dans un fichier prévu à cet effet appelé un **JUnit Test Case**. La création d'un test case entraîne généralement l'ajout de la bibliothèque JUnit dans le projet java. Généralement on place les test case dans un package de test à part. On peut aussi les créer dans un dossier de test en dehors du dossier src.\r\n\r\nPour créer un test case (sous Eclipse) : **Clic droit > New > JUnit Test Case**\r\n\r\nPour chaque classe que l'on souhaite tester, on créer un test case qui va contenir les tests nécessaires à la **couverture** des méthodes de la classe. La **couverture** d'une classe représente tous les cas de figure possible lors de l'appel des méthodes de la classe.\r\n\r\nUn test case est alors une classe composée de tests qui sont des méthodes. Lors de l'exécution, chaque test indiquera s'il est validé ou non. S'il n'est pas validé une raison sera indiquée.\r\n\r\n*Remarque* : un test case peut donc avoir des attributs\r\n\r\nOn utilise les annotations java pour faire marcher les tests case. Les annotations sont des indications au compilateur sur la nature du bloc de code annoté.\r\n\r\n**Exemple** : on va ici créer une fausse classe à tester suivi du test case correspondant\r\n\r\n```java\r\n// une classe exemple\r\npublic class Toto {\r\n\r\n    private int note;\r\n\r\n    public Toto(){\r\n        this.note = 0;\r\n    }\r\n\r\n    public int addition(int nombre1, int nombre2){\r\n        return nombre1 + nombre2;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n// par convention on nomme la classe de test [nom_classe_a_tester]Test\r\npublic class TotoTest {\r\n\r\n    @Test // l'annotation indique que la méthode en dessous est un test\r\n    // ce test va permettre de couvrir la méthode addition\r\n    public void additionTest(){\r\n\r\n    }\r\n}\r\n```\r\n\r\n## Construction\r\n\r\nUn test unitaire est divisé en trois parties :\r\n\r\n+ l'initialisation ou l'arrangement est la section du test ou on instancie les objets donc on aura besoin (pas obligatoire)\r\n+ l'action est la section qui contient les appels de méthodes ou les modifications de valeurs éventuelles (pas obligatoire)\r\n+ l'assertion est la section qui contient la vérification que l'on souhaite faire pour valider le fonctionnement de la méthode\r\n\r\n## Les assertions\r\n\r\nLorsqu'on veut tester des méthodes, on utilise les assertions pour comparer le résultat d'un morceau de code au résultat attendu. Il existe de nombreuses assertions pour tester différents cas de figure. Toutes sont des méthodes qui nécessite le résultat attendu et/ ou la variable, l'objet, la méthode a tester\r\n\r\nVoici quelques exemples d'assertions :\r\n\r\n+ `assertEquals()` : validé si les deux valeurs sont égales\r\n+ `assertNotEquals()` : validé si les deux valeurs ne sont pas égales\r\n+ `assertTrue()` : validé si la condition booléenne testée est vraie\r\n+ `assertFalse()` : validé si la condition booléenne testée est fausse\r\n\r\n*Remarque* : ces assertions sont les plus simples et les plus communes, il en existe bien d'autres\r\n\r\n**Exemple** :\r\n\r\nUn exemple d'usage des assertions\r\n\r\n```java\r\npublic class TotoTest {\r\n\r\n    @Test\r\n    public void totoTest(){\r\n        Toto toto = new Toto();\r\n        // la note de toto a été initialisée à 0 dans le constructeur,\r\n        // le test est validé\r\n        // Premier paramètre = resultat attendu\r\n        // Deuxième paramètre = élément a tester\r\n        assertEquals(0 , toto.note)\r\n        // une autre façon de tester la même égalité\r\n        assertTrue(toto.note == 0)\r\n    }\r\n}\r\n```\r\n\r\nUn exemple plus complet\r\n\r\n```java\r\npublic class TotoTest {\r\n\r\n    @Test\r\n    public void createTotoTest(){\r\n        // Arrange\r\n        Toto toto = new Toto();\r\n\r\n        // Act\r\n        toto.setNote(12);\r\n\r\n        // Assert\r\n        assertNotEquals(0, toto.getNote());\r\n    }\r\n\r\n    @Test\r\n    public void additionTest(){\r\n        // Assert\r\n        assertEquals(13, addition(6, 7));\r\n    }\r\n}\r\n```\r\n\r\n## Les annotations\r\n\r\nIl existe d'autres annotations qui peuvent être utiles lors de l'implémentation de tests unitaires. Certains bloc de code peuvent être éxecuté à des moments précis durant l'éxecution du test case.\r\n\r\nVoici une liste d'annotations utiles et courantes :\r\n\r\n+ `@BeforeAll` : le bloc de code est exécuté **une fois** au début de l'exécution avant tous les autres tests\r\n+ `@BeforeEach` : le bloc de code est exécuté **avant chaque** test\r\n+ `@AfterAll` : le bloc de code est exécuté à la toute fin après tout les tests.\r\n+ `@AfterEach` : le bloc de code est exécuté **après chaque** test\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class TotoTest(){\r\n\r\n    private Toto toto;\r\n\r\n    @BeforeAll\r\n    public static void init(){\r\n        // instancie l'objet toto avant qu'il soit utilisé ailleurs\r\n        toto = new Toto();\r\n    }\r\n\r\n    @BeforeEach\r\n    public void reset(){\r\n        // remet la note de toto à 0 comme lors de sa création\r\n        // pour éviter les confusions entre plusieurs tests\r\n        toto.setNote(0);\r\n    }\r\n\r\n    @Test\r\n    public void test1(){\r\n        assertEquals(0, toto.getNote());\r\n        // // avant de finir le test on modifie la note de toto\r\n        toto.setNote(12);\r\n    }\r\n\r\n    public void test2(){\r\n        // le test valide, même si on a changé la note de Toto à 12\r\n        // dans le test précédent, la méthode reset a été appelée\r\n        // avant test2 et ainsi la note de toto a été remise à 0\r\n        assertEquals(0, toto.getNote());\r\n\r\n        // juste pour montrer que pourquoi pas\r\n        toto.setNote(addition(1, 5));\r\n        assertFalse(0, toto.getNote()); // le test valide\r\n    }\r\n}\r\n```\r\n\r\n## Test paramétré\r\n\r\nGrâce aux annotations, il est possible de créer des tests paramétrés qui pourront vérifier la même assertion pour plusieurs valeurs entrantes de manière plus élégante.\r\nPour cela on utilise l'annotation `@ParameterizedTest` à la place de `@Test`.\r\n\r\nIl faut ensuite pouvoir donner la liste source des valeurs à tester.\r\n\r\n+ Si le test ne prend qu'un seul paramètre d'entrée on utilise `@ValueSource`\r\n+ Si le test prend plusieurs paramètres d'entrée on utilise `@CsvSource`\r\n\r\n**Exemple** :\r\n\r\nOn part du principe qu'on a coder une méthode `multiplication(int, int)` qui permet de multiplier deux nombres entiers passés en entrée.\r\n\r\n```java\r\npublic class CalculTest {\r\n\r\n    @ParameterizedTest\r\n    @ValueSource(ints = { 1, 2, 3, 4 })\r\n    public void multiplicationTest1(int arg){\r\n        // on multiplie un par un les valeur s de ints par 0\r\n        // et on stocke le tout dans resultat\r\n        int result = multiplication(0, arg);\r\n        // on s'assure que multiplier par 0 rend toujours bien 0\r\n        assertEquals(0, result);\r\n    }\r\n\r\n    @ParameterizedTest\r\n    // un couple de valeur \"x,y,z\" tel que x * y = z\r\n    @CsvSource({ \"1,1,1\", \"2,2,4\", \"3,4,12\"})\r\n    public void multiplicationTest2(int firstNumber, int secondNumber,\r\n       int expectedResult){\r\n        int result = multiplication(firstNumber, secondNumber);\r\n        // on s'assure qu'on obtient le résultat attendu\r\n        assertEquals(expectedResult, result);\r\n    }\r\n}\r\n```\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",k="# Gestion des Exceptions\r\n\r\n## Introduction\r\n\r\nLes exceptions font partie intégrante du développement d'un programme. Elle indique le type et la provenance d'une erreur durant l'exécution du programme. Heuresement on peut se prévenir de ces erreurs et les gérer correctement pour ne pas que le programme plante.\r\n\r\n## Les exceptions\r\n\r\nLes exceptions sont des classes très simples qui stocke un **message** ou bien une **trace** qui sera inscrite dans le flux d'erreur de la console lorsque l'exception sera levée (lorsqu'elle sera provoquée). Elle stocke aussi la ou les **causes** potentielles qui pourraient se faire lever l'erreur. Si une exception est levée, un objet de sa classe sera créé puis traiter par le compilateur.\r\nPour gérer les exceptions dans notre programme on doit pouvoir les **lever nous même** si besoin, les **propager** puis les **capturer**.\r\n\r\nToutes exceptions possèdent les méthodes suivantes :\r\n\r\n+ `getMessage()` : retourne le message correspondant à l'erreur\r\n+ `printStackTrace()` : affiche l'exception ainsi que l'état de la pile d'exécution au moment de son appel\r\n\r\n### Lever une exception : throw\r\n\r\nOn peut lever une exception dans le bloc de code d'une méthode en utilisant le mot clé `throw`.\r\nLorsque le contenu du code d'une méthode risque de lever une exception, on doit l'indiquer dans son prototype grâce au mot clé `throws`.\r\nOn construit donc la méthode de cette façon :\r\n\r\n**Exemple** :\r\n\r\n```java\r\n// on indique quelles exceptions peuvent être levées\r\npublic float division(int diviseur, int dividende) throws ArithmeticException {\r\n    // le cas d'utilisation de la méthode qui va poser problème\r\n    if (diviseur == 0){\r\n        // on créer un objet de type ArithmeticException qui va levé une\r\n        // exception avec le message passé en paramètre\r\n        throw new ArithmeticException(\"On ne peut pas diviser par 0 !\");\r\n    }\r\n    return dividende / diviseur; // fonctionnement normal de la méthode\r\n}\r\n```\r\n\r\nAinsi on peut prévenir les risques de notre programme et provoquer des erreurs qui pourront être gérées plus tard. On peut également être ammené à créer nos propres erreurs. Par convention l'objet créer doit contenir \"Exception\" dans son nom.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class ErreurSaisieException extends Exception {\r\n\r\n    public ErreurSaisieException(){\r\n        super();\r\n    }\r\n\r\n    public ErreurSaisieException(String message){\r\n        super(message);\r\n    }\r\n}\r\n```\r\n\r\nC'est de cette façon qu'on peut créer une exception customisée. Nous n'expliquerons pas dans ce cours comment cela fonctionne concrétement car cela implique des notions que nous verrons plus tard. Il faut savoir que l'on peut lever des exceptions existantes avec des messages customisés (comme dans l'exemple division) donc l'usage d'exception customisée est très spécifique et peu recommandé pour les débutants.\r\n\r\n### Capturer les exceptions : try catch finally\r\n\r\nUne fois que notre programme est capable de levé des exceptions, on doit pouvoir les capturer si besoin ou alors faire en sorte que le code s'exécute correctement si tou va bien. Pour tout cela on utilise le bloc de code `try catch finally`.\r\n\r\nLe bloc `try` contient les appels de méthodes **suceptibles de lever des exceptions**\r\nLa clause `catch` contient le code à executer **si une exception à préciser est levée**\r\nLe bloc `finally` contient le code qui sera executé **peu importe si une exception a été levée ou non** (facultatif)\r\n\r\n**Exemple** :\r\n\r\n```java\r\ntry {\r\n    uneMethodeRisquée();\r\n}\r\ncatch(ErreurSaisieException e){\r\n    System.err.println(e.getMessage());\r\n}\r\ncatch (IllegalArgumentException e){\r\n    e.printStackTrace();\r\n}\r\nfinally {\r\n    resetApplication();\r\n}\r\n```\r\n\r\nSi les méthodes invoquées dans le bloc `try` peuvent lever plusieurs méthodes on pourra soit traiter toutes les exceptions de la même façon dans un **multicatch** ou bien comme ici avec plusieurs catchs. Les clauses catch **ne devrait pas contenir d'algorithmie** et seulement des appels de méthodes liés aux exceptions.\r\n\r\n**Exemple** : pour un multicatch\r\n\r\n```java\r\ntry {\r\n    uneMethodeRisquée();\r\n}\r\ncatch (IllegalArgumentException | NumberFormatException | ArithmeticException\r\n  | IOException | FileNotFoundException | IndexOutOfBoundsException e) {\r\n    e.printStackTrace();\r\n}\r\n```\r\n\r\n*Remarque* : même si cela peut paraître lourd, il ne faut pas hésitez à utiliser un bloc try catch même pour un seul appel de méthode lorsque cela est nécessaire.\r\n\r\n### Exercices\r\n\r\n*Coming soon...*\r\n",z="# Abstraction et Héritage\r\n\r\n## Introduction\r\n\r\nLe but principal du java est de pouvoir produire du code **le plus généraliste possible** pour pouvoir **faciliter la maintenance** et les **modifications ultérieures**. Ainsi on essaye toujours de coder en partant du **cas le plus général** vers **les spécialisations éventuelles** de ce cas en gardant toujours en tête que le but est de supprimer la **redondance de code**. Cette façon de coder entraîne une notion de **hiérarchie entre les classes** d'où la notion d'héritage.\r\n\r\n## Principe\r\n\r\nL'héritage repose sur une relation **\"mère-fille\"** entre les classes cette relation est representée par le mot clé `extends` dans la signature d'une classe.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Chien extends Animal {\r\n    // code goes here\r\n}\r\n```\r\n\r\nCe qu'il faut comprendre ici c'est que la classe `Chien` hérite de la classe `Animal`. Un chien **EST UN** animal. En java une classe ne peut hériter au maximum que d'**une seule autre classe**. Ce n'est pas le cas en C++ par exemple où l'on peut créer des liens d'héritages multiples entre les classes. Cependant les relations sont **infinies en profondeur**, c'est à dire qu'une classe peut hérité d'une classe qui elle même hérite d'une autre classe et ainsi de suite sans limite.\r\n\r\nUn lien d'héritage implique que la classe fille **possède les attributs de la classe mère** sans pour autant avoir besoin de les respécifier. La classe fille peut également **faire appel aux méthodes de la classe mère**. Pour faire appel à des éléments de la classe mère on utilise le mot clé `super`. `super` représente l'**objet père** la où `this` représente l'objet courant.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Animal {\r\n    private String nom;\r\n    private int age;\r\n\r\n    public Animal(String nom, int age){\r\n        this.nom = nom;\r\n        this.age = age;\r\n    }\r\n\r\n    public void manger(){\r\n        System.out.println(\"MIAM MIAM\")\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class Chien {\r\n    private String race;\r\n\r\n    // le chien a implicitement un nom et un age car c'est un animal\r\n    public Chien(String nom, int age, String race){\r\n        super(nom, age); // fait appel au constructeur de la classe mère\r\n        this.race = race;\r\n    }\r\n\r\n    public void manger(){\r\n        super.manger(); // fait appel à la méthode manger de la classe mère\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic static void main(String[] args){\r\n    Chien doggo = new Chien(\"paf\", 4, \"Labrador\");\r\n    doggo.manger();\r\n}\r\n```\r\n\r\n*Output* :\r\n\r\n`MIAM MIAM`\r\n\r\n## Abstraction\r\n\r\nLorsqu'on développe nos classes représentant le cas général et ses spécifications, la norme veut que le cas général serve de **point de concentration des éléments en commun des spécifications** (attributs et méthodes) mais il n'a pas pour but d'être instancier lui même. Si on reprend l'exemple du dessus, dans la nature il y a des chiens, des chats, des oiseaus mais pas des animaux. Aucun animal dans la nature n'est de l'espèce Animal.\r\n\r\nDans ce cas on utilise l'abstraction pour **forcer à créer une relation d'héritage** entre les classes. Ainsi une classe peut être abstraite mais aussi ces méthodes. Pour cela on utilise le mot clé `abstract`.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic abstract class Animal {\r\n    private String nom;\r\n    private int age;\r\n\r\n    // une classe abstract peut quand même avoir des constructeurs qui\r\n    // seront utilisés via super dans les classes filles\r\n    public Animal(String nom, int age){\r\n        this.nom = nom;\r\n        this.age = age;\r\n    }\r\n\r\n    public String getNom(){\r\n        return nom;\r\n    }\r\n\r\n    public abstract void crier(); // a spécifier dans les classes filles\r\n}\r\n```\r\n\r\nIci la classe `Animal` est abstract ce qui veut dire qu'**on ne peut pas directement créer des objets** de type `Animal`, on est contraint à créer une spécification de la classe `Animal`. Pour ce qui est des méthodes, `getNom()` est un getter sur un attribut de la classe ainsi peu importe quel objet l'appelera elle fera toujours la même chose que ce soit pour un `Animal` ou pour un objet d'une classe fille. Pour ce qui est de la méthode `crier()` comme un objet de type `Animal` ne peut pas exister, cet objet n'a pas de cri et ainsi la classe `Animal` n'a pas de raison de spécifier cette méthode. Ainsi la méthode est `abstract` et ne possède pas de **corps de méthode**. La spécification sera à la charge des classes filles car chaque espèce d'animal a son propre cri.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Chien extends Animal {\r\n    private String race;\r\n\r\n    public Chien(String nom, int age, String race){\r\n        super(nom, age);\r\n        this.race = race;\r\n    }\r\n\r\n    public void crier(){\r\n        System.out.println(\"OUAF !\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic static void main (String[] args){\r\n    // on créé un animal de type Chien\r\n    Animal toto = new Chien(\"Polux\", 7, \"Skye Terrier\");\r\n}\r\n```\r\n\r\nIci on voit la puissance de l'héritage qui permet d'éviter la redondance de code pour les attributs et les méthodes.\r\n\r\n## Réduire les relations\r\n\r\nEn structurant notre code avec l'usage des classes mères plutot que leurs spécification on peut **réduire les dépendances entre les classes** de notre code et le rendre plus durable.\r\n\r\n**Exemple** :\r\n\r\nOn veut représenter une animalerie qui peut contenir tous types d'animaux, la mauvaise façon de faire serait la suivante :\r\n\r\n```java\r\npublic class Animalerie {\r\n    private List<Chien> chiens;\r\n    private List<Chat> chats;\r\n    private List<Oiseau> oiseaux;\r\n}\r\n```\r\n\r\nSi on est ammené un jour à rajouter de nouveaux types d'animaux ou en supprimer certains. Il va falloir **modifier le code de toutes les classes qui utilises ces types d'animaux** (ici il n'y a que `Animalerie` mais le nombre peut très vite grimper). Ainsi pour réduire les dépendances on préfère utiliser les types les plus généraux si possible, comme ceci :\r\n\r\n```java\r\npublic class Animalerie {\r\n    private List<Animal> animaux;\r\n}\r\n```\r\n\r\nIci, en partant du principe que les classes `Chien`, `Chat` et `Oiseau` héritent de la classe `Animal`, la liste `animaux` peut contenir des objets de tous ces types. Si à l'avenir on rajoute ou bien on enlève des spécifications de la classe `Animal`, le code des classes utilisant des animaux n'aura pas besoin d'être modifié pour continuer de fonctionner... c'est magique !!\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",T="# Polymorphisme\r\n\r\n## Introduction\r\n\r\nLorsqu'un programme contient des liens d'héritages, cela implique un lien entre les **implémentations des méthodes de la classe mère dans les classes filles**. Le polymorphisme est une mécanique de l'orientée objet qui permet d'encore plus réduire la **redondance** et la **dépendance entre les classes**.\r\n\r\n## Principe\r\n\r\nPour utiliser le polymorphisme entre les méthodes d'une classe mère et d'une classe fille, il faut que les méthodes possèdent **le même prototype** c'est à dire le même nom, les mêmes paramètres d'entrée **dans le même ordre** et la même valeur de retour (la première ligne doit être identique).\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Animal {\r\n    public void cri(){\r\n        System.out.println(\"owo\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class Chien extends Animal {\r\n    @Override\r\n    public void cri(){\r\n        System.out.println(\"ouaf\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class Chat extends Animal {\r\n    @Override\r\n    public void cri(){\r\n        System.out.println(\"miaou\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class Cochon extends Animal {\r\n\r\n}\r\n```\r\n\r\n```java\r\npublic static void main(String[] args){\r\n    Animal clubbo = new Animal();\r\n    Animal pito = new Chien();\r\n    Animal malo = new Chat();\r\n    Animal porky = new Cochon();\r\n\r\n    clubbo.cri();\r\n    pito.cri();\r\n    malo.cri();\r\n    porky.cri();\r\n}\r\n```\r\n\r\n*Output* :\r\n\r\n`owo`\r\n\r\n`ouaf`\r\n\r\n`miaou`\r\n\r\n`owo`\r\n\r\nL'annotation `@Override` indique au compilateur de préférer la version de la méthode appelée plutot qu'une autre. Lorsqu'une classe ne contient pas de spécification de la méthode appelée, comme par exemple la classe `Cochon`, la version de la méthode la plus proche dans la hierachie sera utilisée, ici la version de la classe mère `Animal`.\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",P="# Abstraction et Interface\r\n\r\n## Introduction\r\n\r\nIl existe d'autres moyens que les liens d'héritage pour rendre durable du code java. On peut établir des **contrats** avec les classes pour qu'elles implémente des **comportements**. Cela se fait au travers des **interfaces**.\r\n\r\n## Principe\r\n\r\nUne interface n'est pas une classe, elle contient uniquement les **prototypes des méthodes** qui devront être implémenté par la classe qui signe le contrat. On représente ce contrat par le mot clé `implements`.\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic interface Machine {\r\n    public void démarrer();\r\n    public void veille();\r\n    public void arrêter();\r\n}\r\n```\r\n\r\n```java\r\npublic class Ordinateur implements Machine {\r\n    private int id;\r\n\r\n    public Ordinateur(int id){\r\n        this.id = id;\r\n    }\r\n\r\n    @Override\r\n    public void démarrer(){\r\n        System.out.println(\"Démarrage en cours...\");\r\n    }\r\n\r\n    @Override\r\n    public void veille(){\r\n        System.out.println(\"Mise en veille...\");\r\n    }\r\n\r\n    @Override\r\n    public void arrêter(){\r\n        System.out.println(\"Arrêt en cours...\");\r\n    }\r\n}\r\n```\r\n\r\nDans cet exemple, la classe `Ordinateur` est contrainte à spécifier les méthodes de l'interface `Machine`.\r\n\r\nUne interface ne peut pas contenir d'attributs, **on ne peut pas instancier des objets du type de l'interface**. Une classe peut implémenter **plusieurs interfaces à la fois**. Une classe peut `extends` une classe et en même temps `implements` une interface. Une interface peut permettre de réduire les dépendances également :\r\n\r\n**Exemple** :\r\n\r\n```java\r\npublic class Usine {\r\n    // cette liste peut contenir des objets de n'importe\r\n    // quel type qui implémente l'interface machine (ex: ordinateur, etc.)\r\n    private List<Machine> machines;\r\n}\r\n```\r\n\r\n```java\r\npublic static void main(String[] args){\r\n    // on ne peut pas instancier d'objet de type Machine mais on peut\r\n    // s'en servir pour instancier des implémentations\r\n    Machine machine = new Ordinateur(42);\r\n}\r\n```\r\n\r\n## Héritage ou Interface ?\r\n\r\nL'héritage et l'interface sont des mécanismes qui **ne sont pas incompatibles**, ils ne répondent juste pas aux mêmes problématiques. On choisira l'héritage lorsqu'on a besoin de **représenter un cas général** donc les propriétés pourront être spécifiées dans des classes filles. On choisira l'interface pour décrire **les comportements abstraits** d'une catégorie d'objets.\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",D={environnement_travail_java:f,classes_attributs:q,methodes:x,programme_principal:j,enumerations:y,bibliotheques:L,collection_iterable:C,interface_utilisateur:E,valeurs_aleatoires:I,dictionnaires:S,mode_debug:A,tests_unitaires:w,gestion_exceptions:k,abstraction_heritage:z,polymorphisme:T,abstraction_interface:P},_="# Bases de Javascript\r\n\r\n## Introduction\r\n\r\nLe Javascript est un langage de programmation permettant de construire des applications logicielles ou web. C'est un langage proche du script extrêmement polyvalent qui est utilisé dans de nombreux domaines. Il est également la base de nombreux frameworks et autres outils spécialisés. Le but de ce cours est de vous présenter le fonctionnement de ce langage pour pouvoir ensuite l'exploiter dans un contexte d'application web.\r\n\r\n## Structure\r\n\r\n### Types\r\n\r\nLe Javascript est un langage faiblement typé. Ils ne sont pas requis pour la manipulation de donnée mais il existe quand même des types de base :\r\n\r\n+ ``number`` : nombre entier, relatif, etc.\r\n+ ``string`` : chaîne de caractères\r\n+ ``boolean`` : information booléenne\r\n+ ``null, undefined`` : variable vide\r\n+ ``symbol``\r\n\r\n### Variables\r\n\r\nLes variables fonctionnent comme dans n'importe quel autre langage de programmation, elles permettent de stocker une information, une valeur, pour pouvoir être traiter. Il y a plusieurs façon d'instancier une variable :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nvar prenom = 'titi' // string\r\nlet nom = 'toto' // string\r\nlet age = 2 // number\r\nvar sexe = true // boolean\r\nconst vérité = 'Les chats sont mieux que les chiens'\r\n```\r\n\r\nIl existe de subtiles différences entre les mots clés `var` et `let`, les deux permettent d'instancier des variables et il est préférables d'utiliser `let` la majeure partie du temps. Le but de cet exemple était de présenter les possibilités mais nous n'allons pas nous attarder sur une vraie comparaison.\r\n\r\nLe mot clé `const` permet d'instancier une constante, c'est à dire qu'une fois que cette variable se verra attribuer une première fois une valeur, cette valeur ne pourra plus être changée par la suite. Il est très fréquent d'utiliser des constantes en Javascript car on manipule souvent des références mais nous y reviendrons.\r\n\r\n*Remarque : les fins d'instructions n'ont pas besoin d'être représentées en Javascript, le `;` n'est pas obligatoire*\r\n\r\n*Remarque : les opérandes entre les données de type number (+, -, /, etc) restent inchangées.*\r\n\r\n*Remarque : Il est possible de définir des strings avec les simples `''` ou les doubles cotes `\"\"`. Le contexte web utilise les doubles cotes dans certains contextes et il est donc possibles d'utiliser des simples cotes à l'intérieur de doubles cotes (Ex : machin()=\"'phrase'\")*\r\n\r\n### Tableaux\r\n\r\nEn Javascript les tableaux sont eux aussi non typés et peuvent contenir tous types de valeurs.\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet membres = ['titi', 'toto', 'tutu']\r\n\r\nlet premierMembre = membres[0] // 'titi'\r\n```\r\n\r\nLes tableaux possèdent leur propre logique :\r\n\r\n+ `length` : un attribut qui indique la taille du tableau c'est à dire le nombre d'éléments qu'il contient\r\n+ `push(element)` : ajoute un élément à la fin du tableau\r\n+ `unshift(element)` : ajoute un element au début du tableau\r\n+ `pop()` : retire le dernier élément du tableau\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet membres = []\r\nmembres.push('titi') // membres = ['titi']\r\nmembres.unshift('toto') // membres = ['toto', 'titi']\r\nlet taille = membres.length // 2\r\nmembres.pop() // membres = ['toto']\r\n```\r\n\r\n### Objets\r\n\r\nLes objets Javascript permettent de réunir plusieurs informations ou caractéristiques derrière une seule variable par association clé-valeur. Ils sont décrits par le biais de blocs qui contiennent leurs attributs :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet chat = {\r\n  nom: 'pito',\r\n  age : 2\r\n}\r\n\r\nlet nomDuChat = chat.nom // 'pito'\r\nlet ageDuChat = chat['age'] // 2\r\n```\r\n\r\n*Remarque : il est possible d'utiliser la syntaxe par pointeur ou par crochet pour accéder à la valeur d'un attribut d'un objet. Tout dépend des informations disponibles sur l'objet en fonction du contexte mais la syntaxe par pointeur reste la plus courante.*\r\n\r\nLes éléments d'un tableau ainsi que les attributs d'un objet sont accédés par référence, c'est à dire que modifier ces éléments ne modifie pas le tableau ou l'objet en lui même. De ce fait les tableaux et les objets sont généralement déclarés comme des constantes :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nconst membre = {\r\n  nom : 'toto',\r\n  age: 21\r\n}\r\n\r\nconst membres = [membre] // un tableau contenant l'objet membre\r\n\r\nmembre.age = 22 // on modifie l'objet\r\n\r\nconsole.log(membres) // Output : { nom: 'toto', age: 22 }\r\n```\r\n\r\n## Algoritmie\r\n\r\n### Conditions\r\n\r\nLes instructions `if / else / switch`, les opérateurs `<, >, <=, >=, !=` et `&&, ||` fonctionnent de manières similaires aux autres langages.\r\n\r\n*Remarque : La comparaison `==` vérifie uniquement la valeur des deux variables, `===` permet de vérifier la valeur et le type des deux variables*\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet titi = 6\r\nlet toto = '6'\r\n\r\nconsole.log(titi == toto) // true\r\nconsole.log(titi === toto) // false\r\n```\r\n\r\n### Boucles de contrôle\r\n\r\nLa boucle `while` est présente en Javascript mais pas la boucle `do while`. Il existe plusieurs types de boucles `for` :\r\n\r\n+ le for \"classique\"\r\n+ le for...in\r\n+ le for...of\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet membres = ['titi', 'toto', 'tutu']\r\n\r\nfor (let i = 0; i < membres.length; i++) {\r\n  console.log('Tu es un membre !')\r\n}\r\n\r\nfor (let i in members) {\r\n  console.log(members[i] + ' est un SUPER membre !)\r\n}\r\n\r\nfor (let member of members) {\r\n  console.log(member + 'est un INCROYABLE membre)\r\n}\r\n```\r\n\r\n*Remarque : le for...in n'est quasiment jamais utilisé au profit du for...of.*\r\n\r\n### Fonctions\r\n\r\nLes fonctions en Javascript fonctionnent légerement différement du au contexte sous typé. De plus elles possèdent des propriétés différentes que dans les autres langages mais nous n'aborderons ces propriétés qu'a partir des cours en contexte web.\r\n\r\n**Exemple** :\r\n\r\n```js\r\nfunction afficherDesValeurs(valeur1, valeur2) {\r\n  console.log('Première valeur : ' + valeur1)\r\n  console.log('Deuxième valeur : ' + valeur2)\r\n}\r\n\r\nfunction additionner(nombre1, nombre2) {\r\n  return nombre1 + nombre2\r\n}\r\n\r\nafficherDesValeurs(6, 'toto') // Output : Première valeur : 6 Deuxième valeur : toto\r\nconsole.log(additionner(2, 7)) // Output : 9\r\n```\r\n\r\n*Remarque : la recursivité est possible en Javascript.*\r\n\r\n### Exceptions\r\n\r\nLe bloc `try catch` est présent en Javascript et se construit de cette manière :\r\n\r\n```js\r\ntry {\r\n\r\n// code susceptible à l'erreur ici\r\n\r\n} catch (error) {\r\n\r\n// réaction aux erreurs ici\r\n\r\n}\r\n```\r\n\r\n## Classes et méthodes\r\n\r\nLes classes sont des blocs qui permettent de réunir à la fois un modèle de données pour un objet mais aussi des fonctions qui lui sont propres grâce aux méthodes d'instances. Les types de données ainsi créés fonctionnent commes les autres types du Javascript à l'exception de l'instanciation.\r\n\r\n**Exemple** :\r\n\r\n```js\r\nclass Chat {\r\n\r\n  constructor(nom, age) {\r\n    this.nom = nom\r\n    this.age = age\r\n  }\r\n\r\n  miauler() {\r\n    console.log('miaou !')\r\n  }\r\n\r\n  static verite(nombre) {\r\n    return 'Les chats sont ' + nombre + ' fois meilleurs que les chiens :)'\r\n  }\r\n\r\n}\r\n\r\nlet chat = new Chat('malo', 3)\r\nchat.miauler() // 'miaou !'\r\nconst laVerite = Chat.verite(10) // 'Les chats sont 10 fois meilleurs que les chiens :)'\r\n```\r\n\r\n## Tests unitaires\r\n\r\n*Coming soon...*\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",O="# Bases de Javascript pour le Web\r\n\r\n## Introduction\r\n\r\nLe Javascript est une pièce maitresse du développement Web, c'est le langage de compilation de tous les navigateurs existants, c'est à dire que c'est ce langage qui permet au navigateur de produire des pages web sous la forme à laquelle nous sommes habitués. Le Javascript permet également de rendre le contenu d'une page web dynamique, d'y injecter de l'algorithmie et du traitement de donnée, d'intéragir avec des API, bref, la liste est longue.\r\n\r\nHistoriquement le Javascript était reservé à la construction de la partie front-end d'une application Web, c'est à dire le contenu visible et les interactions avec l'utilisateur. Ce n'est aujourd'hui plus le cas et de plus de nombreux outils modernes, des frameworks, permettent de créer des applications web très puissantes de A à Z et bien plus facilement qu'auparavant.\r\n\r\nDans ce cours nous allons découvrir le fonctionnement de base du Javascript et de son interaction avec le contenu d'une page Web. Chaque interaction sera accompagnées d'exemples mais il est impossible et inutile de couvrir tous les cas possibles dans ce cours, ainsi il est fortement conseillé de consulter la documentation en ligne sur [Developper Mozilla](https://developer.mozilla.org/fr/)\r\n\r\n## Compilation\r\n\r\nLorsqu'on déploie une application Web composé notamment d'éléments HTML (ou de balises) accompagnées de style CSS et éventuellement de script JS, tout ce contenu est d'abord réuni en un seul fichier pour faciliter la compilation auprès du navigateur. Tout est mis en oeuvre pour que cette compilation soit la plus rapide possible car tout le monde sait qu'une page web qui ralentit fait fuir les utilisateurs et peut entraîner des bugs.\r\n\r\nIl existe de nombreux outils, couplés aux fonctionnalités du Javascript, qui permettent d'optimiser au maximum la compilation. Le fichier produit ensuite est bien sur absolument illisible pour un être humain mais bien pratique pour le navigateur de votre choix.\r\n\r\n## Le DOM\r\n\r\nLe Document Object Model, ou DOM, pose les fondations de l'architecture d'une application Web, c'est ce modèle qui explique les interactions entre les balises HTML et c'est auprès de celui-ci que les scripts JS se réfère pour accéder à des éléments dans la page web.\r\n\r\n*Remarque : On réfère au DOM dans le Javascript via le mot clé `document`.*\r\n\r\n## Interactions\r\n\r\nLes interactions de bases possibles entre un script JS et une page web sont les suivantes :\r\n\r\n+ récupérer un élément HTML et son contenu\r\n+ modifier un élément HTML\r\n+ modifier le style d'un élément\r\n+ écouter des évènements sur un élément\r\n\r\n*Remarque : un évènement est une action qui s'effectue sur la page, un évènement peut être un changement d'état d'un élément de la page (ex: chargement de l'élément terminé) ou bien une intervention de l'utilisateur (ex: clic sur un bouton, un Link).*\r\n\r\n### Recuperer un élément HTML\r\n\r\nLes balises HTML sont caractérisées par differentes propriétés qui permettent de facilement récupérer ce que l'on souhaite dans une page. Toute balise possède un type et eventuellement une classe, ces deux caractéristiques permettent d'isoler des groupes de balise dans la page. Une balise peut également posséder un id qui va alors permettre d'identifier une balise de manière unique.\r\n\r\nLe Javascript permet d'exploiter ces caractéristiques avec différents sélécteurs :\r\n\r\n+ `getElementsByTagName('tag')` : retourne un tableau contenant les éléments de type `tag` (nom de la balise)\r\n+ `getElementsByClassName('class')` : retourne un tableau contenant les éléments possèdant la classe `class`\r\n+ `getElementById('id')` : retourne l'élément identifié par `id`\r\n\r\n**Exemple** :\r\n\r\n```js\r\nconst monTableau = document.getElementById('tableau')\r\nconst cellules = monTableau.getElementsByTagName('td')\r\n```\r\n\r\nIl est possible d'effectuer une recherche plus pointue avec le querySelector qui permet de combiner différents outils de recherche :\r\n\r\n**Exemple** :\r\n\r\n```html\r\n<div id=\"myId\">\r\n    <p>\r\n        <span><a href=\"#\">Link 1</a></span>\r\n        <a href=\"#\">Link 2</a>\r\n        <span><a href=\"#\">Link 3</a></span>\r\n    </p>\r\n    <p class=\"toto\">\r\n        <span><a href=\"#\">Link 4</a></span>\r\n        <span><a href=\"#\">Link 5</a></span>\r\n        <a href=\"#\">Link 6</a>\r\n    </p>\r\n    <p>\r\n        <a href=\"#\">Link 7</a>\r\n        <span><a href=\"#\">Link 8</a></span>\r\n        <span><a href=\"#\">Link 9</a></span>\r\n    </p>\r\n</div>\r\n```\r\n\r\n```js\r\nconst preciseElement = document.querySelector(\"#myId p.toto > a\")\r\n```\r\n\r\nOn recherche dans un élément ayant pour id 'myId' les éléments de type `<p>` ayant pour classe `toto` afin de récupérer l'enfant direct de type Link `<a>`. `preciseElement` contient donc le Link 6.\r\n\r\nOn peut également récupérer des éléments liés hierarchiquement avec d'autres :\r\n\r\n+ `element.children` : retourne un tableau contenant tous les éléments enfants de `element`\r\n+ `element.parentElement` : retourne l'élément parent de `element`\r\n+ `element.nextElementSibling / element.previousElementSibling` : retourne l'élément suivant ou précédent `element` au même niveau hierarchique.\r\n\r\n**Exemple** :\r\n\r\n```html\r\n<div id=\"parent\">\r\n    <div id=\"toto\">Previous</div>\r\n    <div id=\"main\">\r\n        <p>Text 1</p>\r\n        <p>Text 2</p>\r\n    </div>\r\n    <div id=\"titi\">Next</div>\r\n</div>\r\n```\r\n\r\n```js\r\nconst elt = document.getElementById('main')\r\n```\r\n\r\n+ `elt.children` renvoient les éléments `<p>` enfants de la div ayant pour id `main`\r\n+ `elt.parentElement` renvoie la div ayant pour id `parent`\r\n+ `elt.nextElementSibling` renvoie la div ayant pour id `titi`\r\n\r\n*Remarque : Toutes ces méthodes de recherche renvoie un élément `null` si la recherche ne porte pas ses fruits, le programme ne plante pas nécessairement.*\r\n\r\n### Modifier un élément\r\n\r\nUne fois que l'on a récupéré un élément du DOM on peut modifier ses propriétés. La modification la plus courante est celle du contenu HTML lui même de cet élément. Plusieurs méthodes existent :\r\n\r\n+ `innerHTML` : remplace le contenu actuel de l'élément par un nouveau contenu HTML\r\n+ `textContent` : remplace le contenu actuel de l'élément par un nouveua contenu textuel\r\n\r\n*Remarque : Il existe d'autres façons, celles-ci sont les plus courantes. `textContent` ne peut pas interpréter la syntaxe html et est donc beaucoup moins utile.*\r\n\r\n**Exemple** :\r\n\r\n```js\r\nlet elt = document.getElementById('toto')\r\nelt.innerHTML = \"<ul><li>Ligne 1</li><li>Ligne 2</li></ul>\"\r\n```\r\n\r\nRésultat :\r\n\r\n```html\r\n<div id=\"toto\">\r\n    <ul>\r\n        <li>Ligne 1</li>\r\n        <li>Ligne 2</li>\r\n    </ul>\r\n</div>\r\n```\r\n\r\nUne autre modification possible est le changement de classe d'un élément grâce à la propriété `classList` :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nelt.classList.add(\"nouvelleClasse\")           // Ajoute la classe nouvelleClasse à l'élément\r\nelt.classList.remove(\"nouvelleClasse\")        // Supprime la classe nouvelleClasse que l'on venait d'ajouter\r\nelt.classList.contains(\"nouvelleClasse\")      // Retournera false car on vient de la supprimer\r\nelt.classList.replace(\"oldClass\", \"newClass\") // Remplacera oldClass par newClass si oldClass était présente sur l'élément\r\n```\r\n\r\n*Remarque : il est possible d'ajouter et de retirer plusieurs classes à la fois.*\r\n\r\nOn peut modifier le style d'un élément sans passer par une feuille de style CSS grâce à la propriété `style` :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nelt.style.color = \"#fff\";           // Change la couleur du texte de l'élément à blanche\r\nelt.style.backgroundColor = \"#000\"; // Change la couleur de fond de l'élément en noir\r\nelt.style.fontWeight = \"bold\";      // Met le texte de l'élément en gras\r\n```\r\n\r\nSi un élément peut posséder des attributs, on peut les modifier :\r\n\r\n**Exemple** :\r\n\r\nPour un élément de type input qui est un type possédant des attributs\r\n\r\n```js\r\nelt.setAttribute(\"type\", \"password\");    // Change le type de l'input en un type password\r\nelt.setAttribute(\"name\", \"my-password\"); // Change le nom de l'input en my-password\r\nelt.getAttribute(\"name\");                // Retourne my-password\r\n```\r\n\r\n### Créer un élément\r\n\r\nIl est possible de créer de nouveaux éléments depuis un script JS cependant pour que ces éléments soient visibles sur la page il faut impérativement les rattacher à des éléments déjà existants dans le DOM.\r\n\r\nPour créer un élément on utilise `createElement` puis `appendChild` pour le rattacher à la page via un autre élément :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nconst newElt = document.createElement(\"div\");\r\nlet parent = document.getElementById(\"toto\");\r\n\r\nparent.appendChild(newElt);\r\n```\r\n\r\nComme il est possible de créer, il est également possible de supprimer un élément si celui-ci est enfant d'un élément du DOM, pour cela on utilise `removeChild` ou bien `replaceChild` :\r\n\r\n**Exemple** :\r\n\r\n```js\r\nconst newElt = document.createElement(\"div\");\r\nlet elt = document.getElementById(\"main\");\r\nelt.appendChild(newElt);\r\n\r\nelt.removeChild(newElt);                                     // Supprime l'élément newElt de l'élément elt\r\nelt.replaceChild(document.createElement(\"article\"), newElt); // Remplace l'élément newElt par un nouvel élément de type article\r\n```\r\n\r\n## Exercices\r\n\r\n*Coming soon...*\r\n",R={bases_javascript:_,bases_javascript_web:O};const M=[{id:"1",title:"Creascio",icon:"https://cdn.discordapp.com/attachments/822839106001829908/822839194099384360/discord_pdp.png",chapters:[{id:"1-1",title:"Présentation de Creascio",icon:"",markdown:i.presentation_creascio},{id:"1-2",title:"Devenir Helper",icon:"",markdown:i.devenir_helper}]},{id:"2",title:"Git",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850371933118791690/AdKzmNKdPeteAAAAABJRU5ErkJggg.png",chapters:[{id:"2-1",title:"Environnement de travail (Git)",icon:"",markdown:d.environnement_travail_git},{id:"2-2",title:"GitHub",icon:"",markdown:d.bases_github},{id:"2-3",title:"GitHub Desktop",icon:"",markdown:d.bases_github_desktop},{id:"2-4",title:"Merge Request",icon:"",markdown:d.merge_request},{id:"2-5",title:"Pull Request",icon:"",markdown:d.pull_request}]},{id:"3",title:"Bases de la Programmation",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850372098277900318/c-programming.png",chapters:[{id:"3-1",title:"Environnement de travail (C)",icon:"",markdown:g.environnement_travail_c},{id:"3-2",title:"Variables et Types primitifs",icon:"",markdown:g.types_primitifs_variables},{id:"3-3",title:"Affichage Console",icon:"",markdown:g.affichage_console},{id:"3-4",title:"Conditions Booléennes",icon:"",markdown:g.conditions_booleennes},{id:"3-5",title:"Boucles de contrôles",icon:"",markdown:g.boucles_controle}]},{id:"4",title:"Programmation Orientée Objet",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850372498871681034/226777.png",chapters:[{id:"4-1",title:"Environnement de travail (Java)",icon:"",markdown:D.environnement_travail_java},{id:"4-2",title:"Classes et Attributs",icon:"",markdown:D.classes_attributs},{id:"4-3",title:"Méthodes",icon:"",markdown:D.methodes},{id:"4-4",title:"Programme principal",icon:"",markdown:D.programme_principal},{id:"4-5",title:"Enumérations",icon:"",markdown:D.enumerations},{id:"4-6",title:"Bibliothèques",icon:"",markdown:D.bibliotheques},{id:"4-7",title:"Collection et Iterable",icon:"",markdown:D.collection_iterable},{id:"4-8",title:"Interface Utilisateur",icon:"",markdown:D.interface_utilisateur},{id:"4-9",title:"Valeur Aléatoire",icon:"",markdown:D.valeurs_aleatoires},{id:"4-10",title:"Dictionnaires",icon:"",markdown:D.dictionnaires},{id:"4-11",title:"Mode Debug",icon:"",markdown:D.mode_debug},{id:"4-12",title:"Tests Unitaires",icon:"",markdown:D.tests_unitaires},{id:"4-13",title:"Gestion des Exceptions",icon:"",markdown:D.gestion_exceptions},{id:"4-14",title:"Abstraction et Héritage",icon:"",markdown:D.abstraction_heritage},{id:"4-15",title:"Polymorphisme",icon:"",markdown:D.polymorphisme},{id:"4-16",title:"Abstraction et Interface",icon:"",markdown:D.abstraction_interface}]},{id:"5",title:"Programmation Orientée Web",icon:"https://cdn.discordapp.com/attachments/822839106001829908/850373060645093406/javascript.png",chapters:[{id:"5-1",title:"Bases de Javascript",icon:"",markdown:R.bases_javascript},{id:"5-2",title:"Javascript pour le Web",icon:"",markdown:R.bases_javascript_web}]}];n["a"]=M},bb95:function(e,n,r){"use strict";r("863e")}}]);